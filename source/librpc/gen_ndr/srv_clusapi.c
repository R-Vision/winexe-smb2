/*
 * Unix SMB/CIFS implementation.
 * server auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "ntdomain.h"
#include "bin/default/librpc/gen_ndr/srv_clusapi.h"

static bool api_clusapi_OpenCluster(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OpenCluster *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_OPENCLUSTER];

	r = talloc(talloc_tos(), struct clusapi_OpenCluster);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenCluster, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.Cluster = talloc_zero(r, struct policy_handle);
	if (r->out.Cluster == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_OpenCluster(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenCluster, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CloseCluster(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CloseCluster *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CLOSECLUSTER];

	r = talloc(talloc_tos(), struct clusapi_CloseCluster);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseCluster, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Cluster = r->in.Cluster;
	r->out.result = _clusapi_CloseCluster(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseCluster, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_SetClusterName(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_SetClusterName *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_SETCLUSTERNAME];

	r = talloc(talloc_tos(), struct clusapi_SetClusterName);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetClusterName, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_SetClusterName(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetClusterName, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetClusterName(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetClusterName *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETCLUSTERNAME];

	r = talloc(talloc_tos(), struct clusapi_GetClusterName);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetClusterName, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.ClusterName = talloc_zero(r, const char *);
	if (r->out.ClusterName == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.NodeName = talloc_zero(r, const char *);
	if (r->out.NodeName == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetClusterName(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetClusterName, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetClusterVersion(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetClusterVersion *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETCLUSTERVERSION];

	r = talloc(talloc_tos(), struct clusapi_GetClusterVersion);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetClusterVersion, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpwMajorVersion = talloc_zero(r, uint16_t);
	if (r->out.lpwMajorVersion == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpwMinorVersion = talloc_zero(r, uint16_t);
	if (r->out.lpwMinorVersion == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpwBuildNumber = talloc_zero(r, uint16_t);
	if (r->out.lpwBuildNumber == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpszVendorId = talloc_zero(r, const char *);
	if (r->out.lpszVendorId == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpszCSDVersion = talloc_zero(r, const char *);
	if (r->out.lpszCSDVersion == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetClusterVersion(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetClusterVersion, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetQuorumResource(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetQuorumResource *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETQUORUMRESOURCE];

	r = talloc(talloc_tos(), struct clusapi_GetQuorumResource);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetQuorumResource, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpszResourceName = talloc_zero(r, const char *);
	if (r->out.lpszResourceName == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpszDeviceName = talloc_zero(r, const char *);
	if (r->out.lpszDeviceName == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.pdwMaxQuorumLogSize = talloc_zero(r, uint32_t);
	if (r->out.pdwMaxQuorumLogSize == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetQuorumResource(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetQuorumResource, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_SetQuorumResource(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_SetQuorumResource *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_SETQUORUMRESOURCE];

	r = talloc(talloc_tos(), struct clusapi_SetQuorumResource);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetQuorumResource, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_SetQuorumResource(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetQuorumResource, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateEnum(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateEnum *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATEENUM];

	r = talloc(talloc_tos(), struct clusapi_CreateEnum);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateEnum, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.ReturnEnum = talloc_zero(r, struct ENUM_LIST *);
	if (r->out.ReturnEnum == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_CreateEnum(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateEnum, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OpenResource(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OpenResource *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_OPENRESOURCE];

	r = talloc(talloc_tos(), struct clusapi_OpenResource);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenResource, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.hResource = talloc_zero(r, struct policy_handle);
	if (r->out.hResource == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_OpenResource(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenResource, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateResource(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateResource *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATERESOURCE];

	r = talloc(talloc_tos(), struct clusapi_CreateResource);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateResource, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.hResource = talloc_zero(r, struct policy_handle);
	if (r->out.hResource == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_CreateResource(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateResource, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_DeleteResource(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_DeleteResource *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_DELETERESOURCE];

	r = talloc(talloc_tos(), struct clusapi_DeleteResource);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_DeleteResource, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_DeleteResource(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_DeleteResource, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CloseResource(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CloseResource *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CLOSERESOURCE];

	r = talloc(talloc_tos(), struct clusapi_CloseResource);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseResource, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Resource = r->in.Resource;
	r->out.result = _clusapi_CloseResource(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseResource, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetResourceState(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetResourceState *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETRESOURCESTATE];

	r = talloc(talloc_tos(), struct clusapi_GetResourceState);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetResourceState, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.State = talloc_zero(r, enum clusapi_ClusterResourceState);
	if (r->out.State == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.NodeName = talloc_zero(r, const char *);
	if (r->out.NodeName == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.GroupName = talloc_zero(r, const char *);
	if (r->out.GroupName == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetResourceState(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetResourceState, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_SetResourceName(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_SetResourceName *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_SETRESOURCENAME];

	r = talloc(talloc_tos(), struct clusapi_SetResourceName);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetResourceName, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_SetResourceName(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetResourceName, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetResourceId(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetResourceId *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETRESOURCEID];

	r = talloc(talloc_tos(), struct clusapi_GetResourceId);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetResourceId, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.pGuid = talloc_zero(r, const char *);
	if (r->out.pGuid == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetResourceId(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetResourceId, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetResourceType(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetResourceType *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETRESOURCETYPE];

	r = talloc(talloc_tos(), struct clusapi_GetResourceType);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetResourceType, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpszResourceType = talloc_zero(r, const char *);
	if (r->out.lpszResourceType == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetResourceType(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetResourceType, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_FailResource(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_FailResource *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_FAILRESOURCE];

	r = talloc(talloc_tos(), struct clusapi_FailResource);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_FailResource, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_FailResource(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_FailResource, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OnlineResource(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OnlineResource *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_ONLINERESOURCE];

	r = talloc(talloc_tos(), struct clusapi_OnlineResource);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OnlineResource, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_OnlineResource(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OnlineResource, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OfflineResource(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OfflineResource *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_OFFLINERESOURCE];

	r = talloc(talloc_tos(), struct clusapi_OfflineResource);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OfflineResource, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_OfflineResource(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OfflineResource, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_AddResourceDependency(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_AddResourceDependency *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_ADDRESOURCEDEPENDENCY];

	r = talloc(talloc_tos(), struct clusapi_AddResourceDependency);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddResourceDependency, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_AddResourceDependency(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddResourceDependency, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_RemoveResourceDependency(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_RemoveResourceDependency *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_REMOVERESOURCEDEPENDENCY];

	r = talloc(talloc_tos(), struct clusapi_RemoveResourceDependency);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_RemoveResourceDependency, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_RemoveResourceDependency(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_RemoveResourceDependency, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CanResourceBeDependent(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CanResourceBeDependent *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CANRESOURCEBEDEPENDENT];

	r = talloc(talloc_tos(), struct clusapi_CanResourceBeDependent);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CanResourceBeDependent, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_CanResourceBeDependent(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CanResourceBeDependent, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateResEnum(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateResEnum *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATERESENUM];

	r = talloc(talloc_tos(), struct clusapi_CreateResEnum);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateResEnum, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.ReturnEnum = talloc_zero(r, struct ENUM_LIST *);
	if (r->out.ReturnEnum == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_CreateResEnum(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateResEnum, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_AddResourceNode(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_AddResourceNode *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_ADDRESOURCENODE];

	r = talloc(talloc_tos(), struct clusapi_AddResourceNode);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddResourceNode, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_AddResourceNode(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddResourceNode, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_RemoveResourceNode(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_RemoveResourceNode *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_REMOVERESOURCENODE];

	r = talloc(talloc_tos(), struct clusapi_RemoveResourceNode);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_RemoveResourceNode, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_RemoveResourceNode(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_RemoveResourceNode, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_ChangeResourceGroup(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_ChangeResourceGroup *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CHANGERESOURCEGROUP];

	r = talloc(talloc_tos(), struct clusapi_ChangeResourceGroup);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ChangeResourceGroup, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_ChangeResourceGroup(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ChangeResourceGroup, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateResourceType(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateResourceType *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATERESOURCETYPE];

	r = talloc(talloc_tos(), struct clusapi_CreateResourceType);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateResourceType, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_CreateResourceType(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateResourceType, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_DeleteResourceType(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_DeleteResourceType *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_DELETERESOURCETYPE];

	r = talloc(talloc_tos(), struct clusapi_DeleteResourceType);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_DeleteResourceType, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_DeleteResourceType(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_DeleteResourceType, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetRootKey(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetRootKey *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETROOTKEY];

	r = talloc(talloc_tos(), struct clusapi_GetRootKey);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetRootKey, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.phKey = talloc_zero(r, struct policy_handle);
	if (r->out.phKey == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_GetRootKey(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetRootKey, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateKey(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateKey *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATEKEY];

	r = talloc(talloc_tos(), struct clusapi_CreateKey);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateKey, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpdwDisposition = talloc_zero(r, uint32_t);
	if (r->out.lpdwDisposition == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.phKey = talloc_zero(r, struct policy_handle);
	if (r->out.phKey == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_CreateKey(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateKey, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OpenKey(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OpenKey *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_OPENKEY];

	r = talloc(talloc_tos(), struct clusapi_OpenKey);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenKey, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.phKey = talloc_zero(r, struct policy_handle);
	if (r->out.phKey == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_OpenKey(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenKey, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_EnumKey(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_EnumKey *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_ENUMKEY];

	r = talloc(talloc_tos(), struct clusapi_EnumKey);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_EnumKey, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.KeyName = talloc_zero(r, const char *);
	if (r->out.KeyName == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpftLastWriteTime = talloc_zero(r, NTTIME);
	if (r->out.lpftLastWriteTime == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_EnumKey(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_EnumKey, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_SetValue(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_SetValue *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_SETVALUE];

	r = talloc(talloc_tos(), struct clusapi_SetValue);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetValue, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_SetValue(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetValue, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_DeleteValue(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_DeleteValue *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_DELETEVALUE];

	r = talloc(talloc_tos(), struct clusapi_DeleteValue);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_DeleteValue, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_DeleteValue(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_DeleteValue, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_QueryValue(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_QueryValue *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_QUERYVALUE];

	r = talloc(talloc_tos(), struct clusapi_QueryValue);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_QueryValue, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpValueType = talloc_zero(r, enum winreg_Type);
	if (r->out.lpValueType == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpData = talloc_zero_array(r, uint8_t, r->in.cbData);
	if (r->out.lpData == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbRequired = talloc_zero(r, uint32_t);
	if (r->out.lpcbRequired == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_QueryValue(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_QueryValue, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_DeleteKey(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_DeleteKey *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_DELETEKEY];

	r = talloc(talloc_tos(), struct clusapi_DeleteKey);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_DeleteKey, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_DeleteKey(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_DeleteKey, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_EnumValue(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_EnumValue *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_ENUMVALUE];

	r = talloc(talloc_tos(), struct clusapi_EnumValue);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_EnumValue, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpcbData = r->in.lpcbData;
	r->out.lpValueName = talloc_zero(r, const char *);
	if (r->out.lpValueName == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpType = talloc_zero(r, enum winreg_Type);
	if (r->out.lpType == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpData = talloc_zero_array(r, uint8_t, *r->out.lpcbData);
	if (r->out.lpData == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.TotalSize = talloc_zero(r, uint32_t);
	if (r->out.TotalSize == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_EnumValue(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_EnumValue, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CloseKey(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CloseKey *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CLOSEKEY];

	r = talloc(talloc_tos(), struct clusapi_CloseKey);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseKey, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.pKey = r->in.pKey;
	r->out.result = _clusapi_CloseKey(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseKey, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_QueryInfoKey(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_QueryInfoKey *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_QUERYINFOKEY];

	r = talloc(talloc_tos(), struct clusapi_QueryInfoKey);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_QueryInfoKey, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpcSubKeys = talloc_zero(r, uint32_t);
	if (r->out.lpcSubKeys == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbMaxSubKeyLen = talloc_zero(r, uint32_t);
	if (r->out.lpcbMaxSubKeyLen == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcValues = talloc_zero(r, uint32_t);
	if (r->out.lpcValues == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbMaxValueNameLen = talloc_zero(r, uint32_t);
	if (r->out.lpcbMaxValueNameLen == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbMaxValueLen = talloc_zero(r, uint32_t);
	if (r->out.lpcbMaxValueLen == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbSecurityDescriptor = talloc_zero(r, uint32_t);
	if (r->out.lpcbSecurityDescriptor == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpftLastWriteTime = talloc_zero(r, NTTIME);
	if (r->out.lpftLastWriteTime == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_QueryInfoKey(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_QueryInfoKey, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_SetKeySecurity(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_SetKeySecurity *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_SETKEYSECURITY];

	r = talloc(talloc_tos(), struct clusapi_SetKeySecurity);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetKeySecurity, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_SetKeySecurity(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetKeySecurity, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetKeySecurity(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetKeySecurity *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETKEYSECURITY];

	r = talloc(talloc_tos(), struct clusapi_GetKeySecurity);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetKeySecurity, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.pRpcSecurityDescriptor = r->in.pRpcSecurityDescriptor;
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetKeySecurity(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetKeySecurity, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OpenGroup(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OpenGroup *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_OPENGROUP];

	r = talloc(talloc_tos(), struct clusapi_OpenGroup);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenGroup, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.hGroup = talloc_zero(r, struct policy_handle);
	if (r->out.hGroup == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_OpenGroup(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenGroup, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateGroup(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateGroup *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATEGROUP];

	r = talloc(talloc_tos(), struct clusapi_CreateGroup);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateGroup, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.hGroup = talloc_zero(r, struct policy_handle);
	if (r->out.hGroup == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_CreateGroup(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateGroup, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_DeleteGroup(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_DeleteGroup *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_DELETEGROUP];

	r = talloc(talloc_tos(), struct clusapi_DeleteGroup);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_DeleteGroup, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_DeleteGroup(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_DeleteGroup, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CloseGroup(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CloseGroup *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CLOSEGROUP];

	r = talloc(talloc_tos(), struct clusapi_CloseGroup);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseGroup, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Group = r->in.Group;
	r->out.result = _clusapi_CloseGroup(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseGroup, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetGroupState(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetGroupState *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETGROUPSTATE];

	r = talloc(talloc_tos(), struct clusapi_GetGroupState);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetGroupState, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.State = talloc_zero(r, enum clusapi_ClusterGroupState);
	if (r->out.State == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.NodeName = talloc_zero(r, const char *);
	if (r->out.NodeName == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetGroupState(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetGroupState, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_SetGroupName(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_SetGroupName *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_SETGROUPNAME];

	r = talloc(talloc_tos(), struct clusapi_SetGroupName);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetGroupName, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_SetGroupName(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetGroupName, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetGroupId(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetGroupId *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETGROUPID];

	r = talloc(talloc_tos(), struct clusapi_GetGroupId);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetGroupId, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.pGuid = talloc_zero(r, const char *);
	if (r->out.pGuid == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetGroupId(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetGroupId, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetNodeId(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetNodeId *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETNODEID];

	r = talloc(talloc_tos(), struct clusapi_GetNodeId);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNodeId, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.pGuid = talloc_zero(r, const char *);
	if (r->out.pGuid == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetNodeId(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNodeId, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OnlineGroup(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OnlineGroup *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_ONLINEGROUP];

	r = talloc(talloc_tos(), struct clusapi_OnlineGroup);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OnlineGroup, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_OnlineGroup(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OnlineGroup, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OfflineGroup(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OfflineGroup *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_OFFLINEGROUP];

	r = talloc(talloc_tos(), struct clusapi_OfflineGroup);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OfflineGroup, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_OfflineGroup(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OfflineGroup, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_MoveGroup(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_MoveGroup *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_MOVEGROUP];

	r = talloc(talloc_tos(), struct clusapi_MoveGroup);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_MoveGroup, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_MoveGroup(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_MoveGroup, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_MoveGroupToNode(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_MoveGroupToNode *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_MOVEGROUPTONODE];

	r = talloc(talloc_tos(), struct clusapi_MoveGroupToNode);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_MoveGroupToNode, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_MoveGroupToNode(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_MoveGroupToNode, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateGroupResourceEnum(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateGroupResourceEnum *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATEGROUPRESOURCEENUM];

	r = talloc(talloc_tos(), struct clusapi_CreateGroupResourceEnum);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateGroupResourceEnum, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.ReturnEnum = talloc_zero(r, struct ENUM_LIST *);
	if (r->out.ReturnEnum == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_CreateGroupResourceEnum(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateGroupResourceEnum, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_SetGroupNodeList(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_SetGroupNodeList *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_SETGROUPNODELIST];

	r = talloc(talloc_tos(), struct clusapi_SetGroupNodeList);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetGroupNodeList, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_SetGroupNodeList(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetGroupNodeList, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateNotify(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateNotify *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATENOTIFY];

	r = talloc(talloc_tos(), struct clusapi_CreateNotify);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateNotify, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.hNotify = talloc_zero(r, struct policy_handle);
	if (r->out.hNotify == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_CreateNotify(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateNotify, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CloseNotify(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CloseNotify *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CLOSENOTIFY];

	r = talloc(talloc_tos(), struct clusapi_CloseNotify);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseNotify, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Notify = r->in.Notify;
	r->out.result = _clusapi_CloseNotify(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseNotify, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_AddNotifyCluster(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_AddNotifyCluster *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_ADDNOTIFYCLUSTER];

	r = talloc(talloc_tos(), struct clusapi_AddNotifyCluster);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddNotifyCluster, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_AddNotifyCluster(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddNotifyCluster, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_AddNotifyNode(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_AddNotifyNode *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_ADDNOTIFYNODE];

	r = talloc(talloc_tos(), struct clusapi_AddNotifyNode);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddNotifyNode, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.dwStateSequence = talloc_zero(r, uint32_t);
	if (r->out.dwStateSequence == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_AddNotifyNode(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddNotifyNode, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_AddNotifyGroup(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_AddNotifyGroup *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_ADDNOTIFYGROUP];

	r = talloc(talloc_tos(), struct clusapi_AddNotifyGroup);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddNotifyGroup, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.dwStateSequence = talloc_zero(r, uint32_t);
	if (r->out.dwStateSequence == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_AddNotifyGroup(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddNotifyGroup, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_AddNotifyResource(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_AddNotifyResource *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_ADDNOTIFYRESOURCE];

	r = talloc(talloc_tos(), struct clusapi_AddNotifyResource);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddNotifyResource, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.dwStateSequence = talloc_zero(r, uint32_t);
	if (r->out.dwStateSequence == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_AddNotifyResource(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddNotifyResource, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_AddNotifyKey(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_AddNotifyKey *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_ADDNOTIFYKEY];

	r = talloc(talloc_tos(), struct clusapi_AddNotifyKey);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddNotifyKey, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_AddNotifyKey(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddNotifyKey, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_ReAddNotifyNode(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_ReAddNotifyNode *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_READDNOTIFYNODE];

	r = talloc(talloc_tos(), struct clusapi_ReAddNotifyNode);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ReAddNotifyNode, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_ReAddNotifyNode(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ReAddNotifyNode, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_ReAddNotifyGroup(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_ReAddNotifyGroup *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_READDNOTIFYGROUP];

	r = talloc(talloc_tos(), struct clusapi_ReAddNotifyGroup);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ReAddNotifyGroup, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_ReAddNotifyGroup(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ReAddNotifyGroup, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_ReAddNotifyResource(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_ReAddNotifyResource *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_READDNOTIFYRESOURCE];

	r = talloc(talloc_tos(), struct clusapi_ReAddNotifyResource);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ReAddNotifyResource, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_ReAddNotifyResource(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ReAddNotifyResource, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetNotify(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetNotify *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETNOTIFY];

	r = talloc(talloc_tos(), struct clusapi_GetNotify);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNotify, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.dwNotifyKey = talloc_zero(r, uint32_t);
	if (r->out.dwNotifyKey == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.dwFilter = talloc_zero(r, uint32_t);
	if (r->out.dwFilter == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.dwStateSequence = talloc_zero(r, uint32_t);
	if (r->out.dwStateSequence == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.Name = talloc_zero(r, const char *);
	if (r->out.Name == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetNotify(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNotify, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OpenNode(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OpenNode *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_OPENNODE];

	r = talloc(talloc_tos(), struct clusapi_OpenNode);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenNode, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.hNode = talloc_zero(r, struct policy_handle);
	if (r->out.hNode == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_OpenNode(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenNode, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CloseNode(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CloseNode *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CLOSENODE];

	r = talloc(talloc_tos(), struct clusapi_CloseNode);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseNode, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Node = r->in.Node;
	r->out.result = _clusapi_CloseNode(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseNode, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetNodeState(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetNodeState *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETNODESTATE];

	r = talloc(talloc_tos(), struct clusapi_GetNodeState);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNodeState, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.State = talloc_zero(r, enum clusapi_ClusterNodeState);
	if (r->out.State == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetNodeState(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNodeState, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_PauseNode(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_PauseNode *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_PAUSENODE];

	r = talloc(talloc_tos(), struct clusapi_PauseNode);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_PauseNode, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_PauseNode(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_PauseNode, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_ResumeNode(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_ResumeNode *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_RESUMENODE];

	r = talloc(talloc_tos(), struct clusapi_ResumeNode);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ResumeNode, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_ResumeNode(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ResumeNode, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_EvictNode(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_EvictNode *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_EVICTNODE];

	r = talloc(talloc_tos(), struct clusapi_EvictNode);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_EvictNode, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_EvictNode(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_EvictNode, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_NodeResourceControl(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_NodeResourceControl *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_NODERESOURCECONTROL];

	r = talloc(talloc_tos(), struct clusapi_NodeResourceControl);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NodeResourceControl, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpOutBuffer = talloc_zero_array(r, uint8_t, r->in.nOutBufferSize);
	if (r->out.lpOutBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpBytesReturned = talloc_zero(r, uint32_t);
	if (r->out.lpBytesReturned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbRequired = talloc_zero(r, uint32_t);
	if (r->out.lpcbRequired == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_NodeResourceControl(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NodeResourceControl, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_ResourceControl(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_ResourceControl *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_RESOURCECONTROL];

	r = talloc(talloc_tos(), struct clusapi_ResourceControl);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ResourceControl, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpOutBuffer = talloc_zero_array(r, uint8_t, r->in.nOutBufferSize);
	if (r->out.lpOutBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpBytesReturned = talloc_zero(r, uint32_t);
	if (r->out.lpBytesReturned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbRequired = talloc_zero(r, uint32_t);
	if (r->out.lpcbRequired == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_ResourceControl(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ResourceControl, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_NodeResourceTypeControl(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_NodeResourceTypeControl *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_NODERESOURCETYPECONTROL];

	r = talloc(talloc_tos(), struct clusapi_NodeResourceTypeControl);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NodeResourceTypeControl, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpOutBuffer = talloc_zero_array(r, uint8_t, r->in.nOutBufferSize);
	if (r->out.lpOutBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpBytesReturned = talloc_zero(r, uint32_t);
	if (r->out.lpBytesReturned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbRequired = talloc_zero(r, uint32_t);
	if (r->out.lpcbRequired == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_NodeResourceTypeControl(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NodeResourceTypeControl, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_ResourceTypeControl(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_ResourceTypeControl *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_RESOURCETYPECONTROL];

	r = talloc(talloc_tos(), struct clusapi_ResourceTypeControl);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ResourceTypeControl, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpOutBuffer = talloc_zero_array(r, uint8_t, r->in.nOutBufferSize);
	if (r->out.lpOutBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpBytesReturned = talloc_zero(r, uint32_t);
	if (r->out.lpBytesReturned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbRequired = talloc_zero(r, uint32_t);
	if (r->out.lpcbRequired == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_ResourceTypeControl(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ResourceTypeControl, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_NodeGroupControl(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_NodeGroupControl *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_NODEGROUPCONTROL];

	r = talloc(talloc_tos(), struct clusapi_NodeGroupControl);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NodeGroupControl, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpOutBuffer = talloc_zero_array(r, uint8_t, r->in.nOutBufferSize);
	if (r->out.lpOutBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpBytesReturned = talloc_zero(r, uint32_t);
	if (r->out.lpBytesReturned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbRequired = talloc_zero(r, uint32_t);
	if (r->out.lpcbRequired == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_NodeGroupControl(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NodeGroupControl, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GroupControl(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GroupControl *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GROUPCONTROL];

	r = talloc(talloc_tos(), struct clusapi_GroupControl);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GroupControl, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpOutBuffer = talloc_zero_array(r, uint8_t, r->in.nOutBufferSize);
	if (r->out.lpOutBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpBytesReturned = talloc_zero(r, uint32_t);
	if (r->out.lpBytesReturned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbRequired = talloc_zero(r, uint32_t);
	if (r->out.lpcbRequired == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GroupControl(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GroupControl, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_NodeNodeControl(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_NodeNodeControl *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_NODENODECONTROL];

	r = talloc(talloc_tos(), struct clusapi_NodeNodeControl);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NodeNodeControl, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpOutBuffer = talloc_zero_array(r, uint8_t, r->in.nOutBufferSize);
	if (r->out.lpOutBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpBytesReturned = talloc_zero(r, uint32_t);
	if (r->out.lpBytesReturned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbRequired = talloc_zero(r, uint32_t);
	if (r->out.lpcbRequired == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_NodeNodeControl(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NodeNodeControl, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_NodeControl(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_NodeControl *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_NODECONTROL];

	r = talloc(talloc_tos(), struct clusapi_NodeControl);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NodeControl, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpOutBuffer = talloc_zero_array(r, uint8_t, r->in.nOutBufferSize);
	if (r->out.lpOutBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpBytesReturned = talloc_zero(r, uint32_t);
	if (r->out.lpBytesReturned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbRequired = talloc_zero(r, uint32_t);
	if (r->out.lpcbRequired == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_NodeControl(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NodeControl, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_Opnum80NotUsedOnWire(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct Opnum80NotUsedOnWire *r;

	call = &ndr_table_clusapi.calls[NDR_OPNUM80NOTUSEDONWIRE];

	r = talloc(talloc_tos(), struct Opnum80NotUsedOnWire);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(Opnum80NotUsedOnWire, NDR_IN, r);
	}

	r->out.result = _Opnum80NotUsedOnWire(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(Opnum80NotUsedOnWire, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OpenNetwork(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OpenNetwork *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_OPENNETWORK];

	r = talloc(talloc_tos(), struct clusapi_OpenNetwork);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenNetwork, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.hNetwork = talloc_zero(r, struct policy_handle);
	if (r->out.hNetwork == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_OpenNetwork(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenNetwork, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CloseNetwork(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CloseNetwork *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CLOSENETWORK];

	r = talloc(talloc_tos(), struct clusapi_CloseNetwork);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseNetwork, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Network = r->in.Network;
	r->out.result = _clusapi_CloseNetwork(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseNetwork, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetNetworkState(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetNetworkState *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETNETWORKSTATE];

	r = talloc(talloc_tos(), struct clusapi_GetNetworkState);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNetworkState, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.State = talloc_zero(r, enum clusapi_ClusterNetworkState);
	if (r->out.State == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetNetworkState(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNetworkState, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_SetNetworkName(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_SetNetworkName *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_SETNETWORKNAME];

	r = talloc(talloc_tos(), struct clusapi_SetNetworkName);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetNetworkName, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_SetNetworkName(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetNetworkName, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateNetworkEnum(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateNetworkEnum *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATENETWORKENUM];

	r = talloc(talloc_tos(), struct clusapi_CreateNetworkEnum);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateNetworkEnum, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.ReturnEnum = talloc_zero(r, struct ENUM_LIST *);
	if (r->out.ReturnEnum == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_CreateNetworkEnum(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateNetworkEnum, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetNetworkId(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetNetworkId *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETNETWORKID];

	r = talloc(talloc_tos(), struct clusapi_GetNetworkId);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNetworkId, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.pGuid = talloc_zero(r, const char *);
	if (r->out.pGuid == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetNetworkId(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNetworkId, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_SetNetworkPriorityOrder(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_SetNetworkPriorityOrder *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_SETNETWORKPRIORITYORDER];

	r = talloc(talloc_tos(), struct clusapi_SetNetworkPriorityOrder);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetNetworkPriorityOrder, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_SetNetworkPriorityOrder(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetNetworkPriorityOrder, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_NodeNetworkControl(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_NodeNetworkControl *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_NODENETWORKCONTROL];

	r = talloc(talloc_tos(), struct clusapi_NodeNetworkControl);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NodeNetworkControl, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpOutBuffer = talloc_zero_array(r, uint8_t, r->in.nOutBufferSize);
	if (r->out.lpOutBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpBytesReturned = talloc_zero(r, uint32_t);
	if (r->out.lpBytesReturned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbRequired = talloc_zero(r, uint32_t);
	if (r->out.lpcbRequired == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_NodeNetworkControl(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NodeNetworkControl, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_NetworkControl(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_NetworkControl *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_NETWORKCONTROL];

	r = talloc(talloc_tos(), struct clusapi_NetworkControl);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NetworkControl, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpOutBuffer = talloc_zero_array(r, uint8_t, r->in.nOutBufferSize);
	if (r->out.lpOutBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpBytesReturned = talloc_zero(r, uint32_t);
	if (r->out.lpBytesReturned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbRequired = talloc_zero(r, uint32_t);
	if (r->out.lpcbRequired == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_NetworkControl(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NetworkControl, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_AddNotifyNetwork(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_AddNotifyNetwork *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_ADDNOTIFYNETWORK];

	r = talloc(talloc_tos(), struct clusapi_AddNotifyNetwork);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddNotifyNetwork, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.dwStateSequence = talloc_zero(r, uint32_t);
	if (r->out.dwStateSequence == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_AddNotifyNetwork(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddNotifyNetwork, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_ReAddNotifyNetwork(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_ReAddNotifyNetwork *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_READDNOTIFYNETWORK];

	r = talloc(talloc_tos(), struct clusapi_ReAddNotifyNetwork);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ReAddNotifyNetwork, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_ReAddNotifyNetwork(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ReAddNotifyNetwork, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OpenNetInterface(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OpenNetInterface *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_OPENNETINTERFACE];

	r = talloc(talloc_tos(), struct clusapi_OpenNetInterface);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenNetInterface, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.hNetInterface = talloc_zero(r, struct policy_handle);
	if (r->out.hNetInterface == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_OpenNetInterface(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenNetInterface, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CloseNetInterface(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CloseNetInterface *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CLOSENETINTERFACE];

	r = talloc(talloc_tos(), struct clusapi_CloseNetInterface);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseNetInterface, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.NetInterface = r->in.NetInterface;
	r->out.result = _clusapi_CloseNetInterface(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseNetInterface, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetNetInterfaceState(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetNetInterfaceState *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETNETINTERFACESTATE];

	r = talloc(talloc_tos(), struct clusapi_GetNetInterfaceState);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNetInterfaceState, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.State = talloc_zero(r, enum clusapi_ClusterNetInterfaceState);
	if (r->out.State == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetNetInterfaceState(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNetInterfaceState, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetNetInterface(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetNetInterface *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETNETINTERFACE];

	r = talloc(talloc_tos(), struct clusapi_GetNetInterface);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNetInterface, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lppszInterfaceName = talloc_zero(r, const char *);
	if (r->out.lppszInterfaceName == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetNetInterface(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNetInterface, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetNetInterfaceId(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetNetInterfaceId *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETNETINTERFACEID];

	r = talloc(talloc_tos(), struct clusapi_GetNetInterfaceId);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNetInterfaceId, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.pGuid = talloc_zero(r, const char *);
	if (r->out.pGuid == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetNetInterfaceId(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNetInterfaceId, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_NodeNetInterfaceControl(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_NodeNetInterfaceControl *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_NODENETINTERFACECONTROL];

	r = talloc(talloc_tos(), struct clusapi_NodeNetInterfaceControl);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NodeNetInterfaceControl, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpOutBuffer = talloc_zero_array(r, uint8_t, r->in.nOutBufferSize);
	if (r->out.lpOutBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpBytesReturned = talloc_zero(r, uint32_t);
	if (r->out.lpBytesReturned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbRequired = talloc_zero(r, uint32_t);
	if (r->out.lpcbRequired == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_NodeNetInterfaceControl(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NodeNetInterfaceControl, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_NetInterfaceControl(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_NetInterfaceControl *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_NETINTERFACECONTROL];

	r = talloc(talloc_tos(), struct clusapi_NetInterfaceControl);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NetInterfaceControl, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpOutBuffer = talloc_zero_array(r, uint8_t, r->in.nOutBufferSize);
	if (r->out.lpOutBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpBytesReturned = talloc_zero(r, uint32_t);
	if (r->out.lpBytesReturned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbRequired = talloc_zero(r, uint32_t);
	if (r->out.lpcbRequired == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_NetInterfaceControl(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NetInterfaceControl, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_AddNotifyNetInterface(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_AddNotifyNetInterface *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_ADDNOTIFYNETINTERFACE];

	r = talloc(talloc_tos(), struct clusapi_AddNotifyNetInterface);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddNotifyNetInterface, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.dwStateSequence = talloc_zero(r, uint32_t);
	if (r->out.dwStateSequence == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_AddNotifyNetInterface(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddNotifyNetInterface, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_ReAddNotifyNetInterface(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_ReAddNotifyNetInterface *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_READDNOTIFYNETINTERFACE];

	r = talloc(talloc_tos(), struct clusapi_ReAddNotifyNetInterface);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ReAddNotifyNetInterface, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_ReAddNotifyNetInterface(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ReAddNotifyNetInterface, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateNodeEnum(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateNodeEnum *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATENODEENUM];

	r = talloc(talloc_tos(), struct clusapi_CreateNodeEnum);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateNodeEnum, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.ReturnEnum = talloc_zero(r, struct ENUM_LIST *);
	if (r->out.ReturnEnum == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_CreateNodeEnum(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateNodeEnum, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetClusterVersion2(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetClusterVersion2 *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETCLUSTERVERSION2];

	r = talloc(talloc_tos(), struct clusapi_GetClusterVersion2);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetClusterVersion2, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpwMajorVersion = talloc_zero(r, uint16_t);
	if (r->out.lpwMajorVersion == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpwMinorVersion = talloc_zero(r, uint16_t);
	if (r->out.lpwMinorVersion == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpwBuildNumber = talloc_zero(r, uint16_t);
	if (r->out.lpwBuildNumber == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpszVendorId = talloc_zero(r, const char *);
	if (r->out.lpszVendorId == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpszCSDVersion = talloc_zero(r, const char *);
	if (r->out.lpszCSDVersion == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.ppClusterOpVerInfo = talloc_zero(r, struct CLUSTER_OPERATIONAL_VERSION_INFO *);
	if (r->out.ppClusterOpVerInfo == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetClusterVersion2(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetClusterVersion2, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateResTypeEnum(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateResTypeEnum *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATERESTYPEENUM];

	r = talloc(talloc_tos(), struct clusapi_CreateResTypeEnum);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateResTypeEnum, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.ReturnEnum = talloc_zero(r, struct ENUM_LIST *);
	if (r->out.ReturnEnum == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_CreateResTypeEnum(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateResTypeEnum, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_BackupClusterDatabase(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_BackupClusterDatabase *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_BACKUPCLUSTERDATABASE];

	r = talloc(talloc_tos(), struct clusapi_BackupClusterDatabase);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_BackupClusterDatabase, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_BackupClusterDatabase(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_BackupClusterDatabase, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_NodeClusterControl(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_NodeClusterControl *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_NODECLUSTERCONTROL];

	r = talloc(talloc_tos(), struct clusapi_NodeClusterControl);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NodeClusterControl, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpOutBuffer = talloc_zero_array(r, uint8_t, r->in.nOutBufferSize);
	if (r->out.lpOutBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpBytesReturned = talloc_zero(r, uint32_t);
	if (r->out.lpBytesReturned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbRequired = talloc_zero(r, uint32_t);
	if (r->out.lpcbRequired == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_NodeClusterControl(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_NodeClusterControl, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_ClusterControl(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_ClusterControl *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CLUSTERCONTROL];

	r = talloc(talloc_tos(), struct clusapi_ClusterControl);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ClusterControl, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpOutBuffer = talloc_zero_array(r, uint8_t, r->in.nOutBufferSize);
	if (r->out.lpOutBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpBytesReturned = talloc_zero(r, uint32_t);
	if (r->out.lpBytesReturned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpcbRequired = talloc_zero(r, uint32_t);
	if (r->out.lpcbRequired == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_ClusterControl(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ClusterControl, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_UnblockGetNotifyCall(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_UnblockGetNotifyCall *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_UNBLOCKGETNOTIFYCALL];

	r = talloc(talloc_tos(), struct clusapi_UnblockGetNotifyCall);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_UnblockGetNotifyCall, NDR_IN, r);
	}

	r->out.result = _clusapi_UnblockGetNotifyCall(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_UnblockGetNotifyCall, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_SetServiceAccountPassword(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_SetServiceAccountPassword *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_SETSERVICEACCOUNTPASSWORD];

	r = talloc(talloc_tos(), struct clusapi_SetServiceAccountPassword);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetServiceAccountPassword, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.ReturnStatusBufferPtr = talloc_zero_array(r, struct IDL_CLUSTER_SET_PASSWORD_STATUS, r->in.ReturnStatusBufferSize);
	if (r->out.ReturnStatusBufferPtr == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.SizeReturned = talloc_zero(r, uint32_t);
	if (r->out.SizeReturned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.ExpectedBufferSize = talloc_zero(r, uint32_t);
	if (r->out.ExpectedBufferSize == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_SetServiceAccountPassword(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetServiceAccountPassword, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_SetResourceDependencyExpression(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_SetResourceDependencyExpression *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_SETRESOURCEDEPENDENCYEXPRESSION];

	r = talloc(talloc_tos(), struct clusapi_SetResourceDependencyExpression);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetResourceDependencyExpression, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_SetResourceDependencyExpression(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_SetResourceDependencyExpression, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetResourceDependencyExpression(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetResourceDependencyExpression *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETRESOURCEDEPENDENCYEXPRESSION];

	r = talloc(talloc_tos(), struct clusapi_GetResourceDependencyExpression);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetResourceDependencyExpression, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpszDependencyExpression = talloc_zero(r, const char *);
	if (r->out.lpszDependencyExpression == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetResourceDependencyExpression(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetResourceDependencyExpression, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_Opnum111NotUsedOnWire(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct Opnum111NotUsedOnWire *r;

	call = &ndr_table_clusapi.calls[NDR_OPNUM111NOTUSEDONWIRE];

	r = talloc(talloc_tos(), struct Opnum111NotUsedOnWire);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(Opnum111NotUsedOnWire, NDR_IN, r);
	}

	r->out.result = _Opnum111NotUsedOnWire(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(Opnum111NotUsedOnWire, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetResourceNetworkName(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetResourceNetworkName *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETRESOURCENETWORKNAME];

	r = talloc(talloc_tos(), struct clusapi_GetResourceNetworkName);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetResourceNetworkName, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpszName = talloc_zero(r, const char *);
	if (r->out.lpszName == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetResourceNetworkName(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetResourceNetworkName, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_ExecuteBatch(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_ExecuteBatch *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_EXECUTEBATCH];

	r = talloc(talloc_tos(), struct clusapi_ExecuteBatch);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ExecuteBatch, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.pdwFailedCommand = talloc_zero(r, int32_t);
	if (r->out.pdwFailedCommand == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_ExecuteBatch(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ExecuteBatch, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateBatchPort(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateBatchPort *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATEBATCHPORT];

	r = talloc(talloc_tos(), struct clusapi_CreateBatchPort);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateBatchPort, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.phBatchPort = talloc_zero(r, struct policy_handle);
	if (r->out.phBatchPort == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_CreateBatchPort(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateBatchPort, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetBatchNotification(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetBatchNotification *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETBATCHNOTIFICATION];

	r = talloc(talloc_tos(), struct clusapi_GetBatchNotification);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetBatchNotification, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.cbData = talloc_zero(r, uint32_t);
	if (r->out.cbData == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpData = talloc_zero(r, uint8_t *);
	if (r->out.lpData == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetBatchNotification(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetBatchNotification, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CloseBatchPort(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CloseBatchPort *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CLOSEBATCHPORT];

	r = talloc(talloc_tos(), struct clusapi_CloseBatchPort);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseBatchPort, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.phBatchPort = r->in.phBatchPort;
	r->out.result = _clusapi_CloseBatchPort(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CloseBatchPort, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OpenClusterEx(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OpenClusterEx *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_OPENCLUSTEREX];

	r = talloc(talloc_tos(), struct clusapi_OpenClusterEx);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenClusterEx, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpdwGrantedAccess = talloc_zero(r, uint32_t);
	if (r->out.lpdwGrantedAccess == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.hCluster = talloc_zero(r, struct policy_handle);
	if (r->out.hCluster == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_OpenClusterEx(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenClusterEx, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OpenNodeEx(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OpenNodeEx *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_OPENNODEEX];

	r = talloc(talloc_tos(), struct clusapi_OpenNodeEx);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenNodeEx, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpdwGrantedAccess = talloc_zero(r, uint32_t);
	if (r->out.lpdwGrantedAccess == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.hNode = talloc_zero(r, struct policy_handle);
	if (r->out.hNode == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_OpenNodeEx(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenNodeEx, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OpenGroupEx(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OpenGroupEx *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_OPENGROUPEX];

	r = talloc(talloc_tos(), struct clusapi_OpenGroupEx);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenGroupEx, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpdwGrantedAccess = talloc_zero(r, uint32_t);
	if (r->out.lpdwGrantedAccess == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.hGroup = talloc_zero(r, struct policy_handle);
	if (r->out.hGroup == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_OpenGroupEx(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenGroupEx, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OpenResourceEx(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OpenResourceEx *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_OPENRESOURCEEX];

	r = talloc(talloc_tos(), struct clusapi_OpenResourceEx);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenResourceEx, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpdwGrantedAccess = talloc_zero(r, uint32_t);
	if (r->out.lpdwGrantedAccess == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.hResource = talloc_zero(r, struct policy_handle);
	if (r->out.hResource == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_OpenResourceEx(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenResourceEx, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OpenNetworkEx(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OpenNetworkEx *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_OPENNETWORKEX];

	r = talloc(talloc_tos(), struct clusapi_OpenNetworkEx);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenNetworkEx, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpdwGrantedAccess = talloc_zero(r, uint32_t);
	if (r->out.lpdwGrantedAccess == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.hNetwork = talloc_zero(r, struct policy_handle);
	if (r->out.hNetwork == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_OpenNetworkEx(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenNetworkEx, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OpenNetInterfaceEx(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OpenNetInterfaceEx *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_OPENNETINTERFACEEX];

	r = talloc(talloc_tos(), struct clusapi_OpenNetInterfaceEx);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenNetInterfaceEx, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lpdwGrantedAccess = talloc_zero(r, uint32_t);
	if (r->out.lpdwGrantedAccess == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.hNetInterface = talloc_zero(r, struct policy_handle);
	if (r->out.hNetInterface == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_OpenNetInterfaceEx(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OpenNetInterfaceEx, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_ChangeCsvState(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_ChangeCsvState *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CHANGECSVSTATE];

	r = talloc(talloc_tos(), struct clusapi_ChangeCsvState);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ChangeCsvState, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_ChangeCsvState(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ChangeCsvState, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateNodeEnumEx(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateNodeEnumEx *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATENODEENUMEX];

	r = talloc(talloc_tos(), struct clusapi_CreateNodeEnumEx);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateNodeEnumEx, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.ReturnIdEnum = talloc_zero(r, struct ENUM_LIST *);
	if (r->out.ReturnIdEnum == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.ReturnNameEnum = talloc_zero(r, struct ENUM_LIST *);
	if (r->out.ReturnNameEnum == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_CreateNodeEnumEx(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateNodeEnumEx, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateEnumEx(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateEnumEx *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATEENUMEX];

	r = talloc(talloc_tos(), struct clusapi_CreateEnumEx);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateEnumEx, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.ReturnIdEnum = talloc_zero(r, struct ENUM_LIST *);
	if (r->out.ReturnIdEnum == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.ReturnNameEnum = talloc_zero(r, struct ENUM_LIST *);
	if (r->out.ReturnNameEnum == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_CreateEnumEx(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateEnumEx, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_PauseNodeEx(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_PauseNodeEx *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_PAUSENODEEX];

	r = talloc(talloc_tos(), struct clusapi_PauseNodeEx);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_PauseNodeEx, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_PauseNodeEx(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_PauseNodeEx, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_PauseNodeWithDrainTarget(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_PauseNodeWithDrainTarget *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_PAUSENODEWITHDRAINTARGET];

	r = talloc(talloc_tos(), struct clusapi_PauseNodeWithDrainTarget);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_PauseNodeWithDrainTarget, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_PauseNodeWithDrainTarget(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_PauseNodeWithDrainTarget, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_ResumeNodeEx(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_ResumeNodeEx *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_RESUMENODEEX];

	r = talloc(talloc_tos(), struct clusapi_ResumeNodeEx);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ResumeNodeEx, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_ResumeNodeEx(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ResumeNodeEx, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateGroupEx(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateGroupEx *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATEGROUPEX];

	r = talloc(talloc_tos(), struct clusapi_CreateGroupEx);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateGroupEx, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Status = talloc_zero(r, WERROR);
	if (r->out.Status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.hGroup = talloc_zero(r, struct policy_handle);
	if (r->out.hGroup == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_CreateGroupEx(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateGroupEx, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OnlineGroupEx(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OnlineGroupEx *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_ONLINEGROUPEX];

	r = talloc(talloc_tos(), struct clusapi_OnlineGroupEx);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OnlineGroupEx, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_OnlineGroupEx(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OnlineGroupEx, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OfflineGroupEx(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OfflineGroupEx *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_OFFLINEGROUPEX];

	r = talloc(talloc_tos(), struct clusapi_OfflineGroupEx);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OfflineGroupEx, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_OfflineGroupEx(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OfflineGroupEx, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_MoveGroupEx(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_MoveGroupEx *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_MOVEGROUPEX];

	r = talloc(talloc_tos(), struct clusapi_MoveGroupEx);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_MoveGroupEx, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_MoveGroupEx(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_MoveGroupEx, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_MoveGroupToNodeEx(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_MoveGroupToNodeEx *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_MOVEGROUPTONODEEX];

	r = talloc(talloc_tos(), struct clusapi_MoveGroupToNodeEx);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_MoveGroupToNodeEx, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_MoveGroupToNodeEx(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_MoveGroupToNodeEx, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CancelClusterGroupOperation(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CancelClusterGroupOperation *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CANCELCLUSTERGROUPOPERATION];

	r = talloc(talloc_tos(), struct clusapi_CancelClusterGroupOperation);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CancelClusterGroupOperation, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_CancelClusterGroupOperation(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CancelClusterGroupOperation, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OnlineResourceEx(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OnlineResourceEx *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_ONLINERESOURCEEX];

	r = talloc(talloc_tos(), struct clusapi_OnlineResourceEx);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OnlineResourceEx, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_OnlineResourceEx(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OnlineResourceEx, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_OfflineResourceEx(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_OfflineResourceEx *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_OFFLINERESOURCEEX];

	r = talloc(talloc_tos(), struct clusapi_OfflineResourceEx);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OfflineResourceEx, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_OfflineResourceEx(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_OfflineResourceEx, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateNotifyV2(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateNotifyV2 *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATENOTIFYV2];

	r = talloc(talloc_tos(), struct clusapi_CreateNotifyV2);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateNotifyV2, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_error = talloc_zero(r, WERROR);
	if (r->out.rpc_error == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.hNotify = talloc_zero(r, struct policy_handle);
	if (r->out.hNotify == NULL) {
		talloc_free(r);
		return false;
	}

	_clusapi_CreateNotifyV2(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateNotifyV2, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_AddNotifyV2(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_AddNotifyV2 *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_ADDNOTIFYV2];

	r = talloc(talloc_tos(), struct clusapi_AddNotifyV2);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddNotifyV2, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_AddNotifyV2(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_AddNotifyV2, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetNotifyV2(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetNotifyV2 *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETNOTIFYV2];

	r = talloc(talloc_tos(), struct clusapi_GetNotifyV2);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNotifyV2, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Notifications = talloc_zero(r, struct NOTIFICATION_RPC *);
	if (r->out.Notifications == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.dwNumNotifications = talloc_zero(r, uint32_t);
	if (r->out.dwNumNotifications == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetNotifyV2(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNotifyV2, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_QueryAllValues(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_QueryAllValues *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_QUERYALLVALUES];

	r = talloc(talloc_tos(), struct clusapi_QueryAllValues);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_QueryAllValues, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.pcbData = talloc_zero(r, uint32_t);
	if (r->out.pcbData == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.ppData = talloc_zero_array(r, uint8_t *, 1);
	if (r->out.ppData == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_QueryAllValues(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_QueryAllValues, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_StmFindDisk(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_StmFindDisk *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_STMFINDDISK];

	r = talloc(talloc_tos(), struct clusapi_StmFindDisk);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_StmFindDisk, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.pDiskId = r->in.pDiskId;
	r->out.ppszDeviceName = talloc_zero(r, const char *);
	if (r->out.ppszDeviceName == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_StmFindDisk(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_StmFindDisk, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_ClusterMrr(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_ClusterMrr *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CLUSTERMRR];

	r = talloc(talloc_tos(), struct clusapi_ClusterMrr);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ClusterMrr, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.ppInfo = talloc_zero_array(r, struct CLUSTER_MRR_RESPONSE *, 1);
	if (r->out.ppInfo == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_ClusterMrr(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ClusterMrr, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateGroupEnum(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateGroupEnum *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATEGROUPENUM];

	r = talloc(talloc_tos(), struct clusapi_CreateGroupEnum);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateGroupEnum, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.ppResultList = talloc_zero(r, struct GROUP_ENUM_LIST *);
	if (r->out.ppResultList == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_CreateGroupEnum(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateGroupEnum, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_CreateResourceEnum(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_CreateResourceEnum *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_CREATERESOURCEENUM];

	r = talloc(talloc_tos(), struct clusapi_CreateResourceEnum);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateResourceEnum, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.ppResultList = talloc_zero(r, struct RESOURCE_ENUM_LIST *);
	if (r->out.ppResultList == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_CreateResourceEnum(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_CreateResourceEnum, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_ExecuteReadBatch(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_ExecuteReadBatch *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_EXECUTEREADBATCH];

	r = talloc(talloc_tos(), struct clusapi_ExecuteReadBatch);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ExecuteReadBatch, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.cbOutData = talloc_zero(r, uint32_t);
	if (r->out.cbOutData == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.lpOutData = talloc_zero(r, uint8_t *);
	if (r->out.lpOutData == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_ExecuteReadBatch(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_ExecuteReadBatch, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_RestartResource(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_RestartResource *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_RESTARTRESOURCE];

	r = talloc(talloc_tos(), struct clusapi_RestartResource);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_RestartResource, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.rpc_status = talloc_zero(r, WERROR);
	if (r->out.rpc_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_RestartResource(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_RestartResource, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_clusapi_GetNotifyAsync(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct clusapi_GetNotifyAsync *r;

	call = &ndr_table_clusapi.calls[NDR_CLUSAPI_GETNOTIFYASYNC];

	r = talloc(talloc_tos(), struct clusapi_GetNotifyAsync);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNotifyAsync, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.Notifications = talloc_zero(r, struct NOTIFICATION_DATA_ASYNC_RPC *);
	if (r->out.Notifications == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.dwNumNotifications = talloc_zero(r, uint32_t);
	if (r->out.dwNumNotifications == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _clusapi_GetNotifyAsync(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(clusapi_GetNotifyAsync, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}


/* Tables */
static const struct api_struct api_clusapi_cmds[] = 
{
	{"CLUSAPI_OPENCLUSTER", NDR_CLUSAPI_OPENCLUSTER, api_clusapi_OpenCluster},
	{"CLUSAPI_CLOSECLUSTER", NDR_CLUSAPI_CLOSECLUSTER, api_clusapi_CloseCluster},
	{"CLUSAPI_SETCLUSTERNAME", NDR_CLUSAPI_SETCLUSTERNAME, api_clusapi_SetClusterName},
	{"CLUSAPI_GETCLUSTERNAME", NDR_CLUSAPI_GETCLUSTERNAME, api_clusapi_GetClusterName},
	{"CLUSAPI_GETCLUSTERVERSION", NDR_CLUSAPI_GETCLUSTERVERSION, api_clusapi_GetClusterVersion},
	{"CLUSAPI_GETQUORUMRESOURCE", NDR_CLUSAPI_GETQUORUMRESOURCE, api_clusapi_GetQuorumResource},
	{"CLUSAPI_SETQUORUMRESOURCE", NDR_CLUSAPI_SETQUORUMRESOURCE, api_clusapi_SetQuorumResource},
	{"CLUSAPI_CREATEENUM", NDR_CLUSAPI_CREATEENUM, api_clusapi_CreateEnum},
	{"CLUSAPI_OPENRESOURCE", NDR_CLUSAPI_OPENRESOURCE, api_clusapi_OpenResource},
	{"CLUSAPI_CREATERESOURCE", NDR_CLUSAPI_CREATERESOURCE, api_clusapi_CreateResource},
	{"CLUSAPI_DELETERESOURCE", NDR_CLUSAPI_DELETERESOURCE, api_clusapi_DeleteResource},
	{"CLUSAPI_CLOSERESOURCE", NDR_CLUSAPI_CLOSERESOURCE, api_clusapi_CloseResource},
	{"CLUSAPI_GETRESOURCESTATE", NDR_CLUSAPI_GETRESOURCESTATE, api_clusapi_GetResourceState},
	{"CLUSAPI_SETRESOURCENAME", NDR_CLUSAPI_SETRESOURCENAME, api_clusapi_SetResourceName},
	{"CLUSAPI_GETRESOURCEID", NDR_CLUSAPI_GETRESOURCEID, api_clusapi_GetResourceId},
	{"CLUSAPI_GETRESOURCETYPE", NDR_CLUSAPI_GETRESOURCETYPE, api_clusapi_GetResourceType},
	{"CLUSAPI_FAILRESOURCE", NDR_CLUSAPI_FAILRESOURCE, api_clusapi_FailResource},
	{"CLUSAPI_ONLINERESOURCE", NDR_CLUSAPI_ONLINERESOURCE, api_clusapi_OnlineResource},
	{"CLUSAPI_OFFLINERESOURCE", NDR_CLUSAPI_OFFLINERESOURCE, api_clusapi_OfflineResource},
	{"CLUSAPI_ADDRESOURCEDEPENDENCY", NDR_CLUSAPI_ADDRESOURCEDEPENDENCY, api_clusapi_AddResourceDependency},
	{"CLUSAPI_REMOVERESOURCEDEPENDENCY", NDR_CLUSAPI_REMOVERESOURCEDEPENDENCY, api_clusapi_RemoveResourceDependency},
	{"CLUSAPI_CANRESOURCEBEDEPENDENT", NDR_CLUSAPI_CANRESOURCEBEDEPENDENT, api_clusapi_CanResourceBeDependent},
	{"CLUSAPI_CREATERESENUM", NDR_CLUSAPI_CREATERESENUM, api_clusapi_CreateResEnum},
	{"CLUSAPI_ADDRESOURCENODE", NDR_CLUSAPI_ADDRESOURCENODE, api_clusapi_AddResourceNode},
	{"CLUSAPI_REMOVERESOURCENODE", NDR_CLUSAPI_REMOVERESOURCENODE, api_clusapi_RemoveResourceNode},
	{"CLUSAPI_CHANGERESOURCEGROUP", NDR_CLUSAPI_CHANGERESOURCEGROUP, api_clusapi_ChangeResourceGroup},
	{"CLUSAPI_CREATERESOURCETYPE", NDR_CLUSAPI_CREATERESOURCETYPE, api_clusapi_CreateResourceType},
	{"CLUSAPI_DELETERESOURCETYPE", NDR_CLUSAPI_DELETERESOURCETYPE, api_clusapi_DeleteResourceType},
	{"CLUSAPI_GETROOTKEY", NDR_CLUSAPI_GETROOTKEY, api_clusapi_GetRootKey},
	{"CLUSAPI_CREATEKEY", NDR_CLUSAPI_CREATEKEY, api_clusapi_CreateKey},
	{"CLUSAPI_OPENKEY", NDR_CLUSAPI_OPENKEY, api_clusapi_OpenKey},
	{"CLUSAPI_ENUMKEY", NDR_CLUSAPI_ENUMKEY, api_clusapi_EnumKey},
	{"CLUSAPI_SETVALUE", NDR_CLUSAPI_SETVALUE, api_clusapi_SetValue},
	{"CLUSAPI_DELETEVALUE", NDR_CLUSAPI_DELETEVALUE, api_clusapi_DeleteValue},
	{"CLUSAPI_QUERYVALUE", NDR_CLUSAPI_QUERYVALUE, api_clusapi_QueryValue},
	{"CLUSAPI_DELETEKEY", NDR_CLUSAPI_DELETEKEY, api_clusapi_DeleteKey},
	{"CLUSAPI_ENUMVALUE", NDR_CLUSAPI_ENUMVALUE, api_clusapi_EnumValue},
	{"CLUSAPI_CLOSEKEY", NDR_CLUSAPI_CLOSEKEY, api_clusapi_CloseKey},
	{"CLUSAPI_QUERYINFOKEY", NDR_CLUSAPI_QUERYINFOKEY, api_clusapi_QueryInfoKey},
	{"CLUSAPI_SETKEYSECURITY", NDR_CLUSAPI_SETKEYSECURITY, api_clusapi_SetKeySecurity},
	{"CLUSAPI_GETKEYSECURITY", NDR_CLUSAPI_GETKEYSECURITY, api_clusapi_GetKeySecurity},
	{"CLUSAPI_OPENGROUP", NDR_CLUSAPI_OPENGROUP, api_clusapi_OpenGroup},
	{"CLUSAPI_CREATEGROUP", NDR_CLUSAPI_CREATEGROUP, api_clusapi_CreateGroup},
	{"CLUSAPI_DELETEGROUP", NDR_CLUSAPI_DELETEGROUP, api_clusapi_DeleteGroup},
	{"CLUSAPI_CLOSEGROUP", NDR_CLUSAPI_CLOSEGROUP, api_clusapi_CloseGroup},
	{"CLUSAPI_GETGROUPSTATE", NDR_CLUSAPI_GETGROUPSTATE, api_clusapi_GetGroupState},
	{"CLUSAPI_SETGROUPNAME", NDR_CLUSAPI_SETGROUPNAME, api_clusapi_SetGroupName},
	{"CLUSAPI_GETGROUPID", NDR_CLUSAPI_GETGROUPID, api_clusapi_GetGroupId},
	{"CLUSAPI_GETNODEID", NDR_CLUSAPI_GETNODEID, api_clusapi_GetNodeId},
	{"CLUSAPI_ONLINEGROUP", NDR_CLUSAPI_ONLINEGROUP, api_clusapi_OnlineGroup},
	{"CLUSAPI_OFFLINEGROUP", NDR_CLUSAPI_OFFLINEGROUP, api_clusapi_OfflineGroup},
	{"CLUSAPI_MOVEGROUP", NDR_CLUSAPI_MOVEGROUP, api_clusapi_MoveGroup},
	{"CLUSAPI_MOVEGROUPTONODE", NDR_CLUSAPI_MOVEGROUPTONODE, api_clusapi_MoveGroupToNode},
	{"CLUSAPI_CREATEGROUPRESOURCEENUM", NDR_CLUSAPI_CREATEGROUPRESOURCEENUM, api_clusapi_CreateGroupResourceEnum},
	{"CLUSAPI_SETGROUPNODELIST", NDR_CLUSAPI_SETGROUPNODELIST, api_clusapi_SetGroupNodeList},
	{"CLUSAPI_CREATENOTIFY", NDR_CLUSAPI_CREATENOTIFY, api_clusapi_CreateNotify},
	{"CLUSAPI_CLOSENOTIFY", NDR_CLUSAPI_CLOSENOTIFY, api_clusapi_CloseNotify},
	{"CLUSAPI_ADDNOTIFYCLUSTER", NDR_CLUSAPI_ADDNOTIFYCLUSTER, api_clusapi_AddNotifyCluster},
	{"CLUSAPI_ADDNOTIFYNODE", NDR_CLUSAPI_ADDNOTIFYNODE, api_clusapi_AddNotifyNode},
	{"CLUSAPI_ADDNOTIFYGROUP", NDR_CLUSAPI_ADDNOTIFYGROUP, api_clusapi_AddNotifyGroup},
	{"CLUSAPI_ADDNOTIFYRESOURCE", NDR_CLUSAPI_ADDNOTIFYRESOURCE, api_clusapi_AddNotifyResource},
	{"CLUSAPI_ADDNOTIFYKEY", NDR_CLUSAPI_ADDNOTIFYKEY, api_clusapi_AddNotifyKey},
	{"CLUSAPI_READDNOTIFYNODE", NDR_CLUSAPI_READDNOTIFYNODE, api_clusapi_ReAddNotifyNode},
	{"CLUSAPI_READDNOTIFYGROUP", NDR_CLUSAPI_READDNOTIFYGROUP, api_clusapi_ReAddNotifyGroup},
	{"CLUSAPI_READDNOTIFYRESOURCE", NDR_CLUSAPI_READDNOTIFYRESOURCE, api_clusapi_ReAddNotifyResource},
	{"CLUSAPI_GETNOTIFY", NDR_CLUSAPI_GETNOTIFY, api_clusapi_GetNotify},
	{"CLUSAPI_OPENNODE", NDR_CLUSAPI_OPENNODE, api_clusapi_OpenNode},
	{"CLUSAPI_CLOSENODE", NDR_CLUSAPI_CLOSENODE, api_clusapi_CloseNode},
	{"CLUSAPI_GETNODESTATE", NDR_CLUSAPI_GETNODESTATE, api_clusapi_GetNodeState},
	{"CLUSAPI_PAUSENODE", NDR_CLUSAPI_PAUSENODE, api_clusapi_PauseNode},
	{"CLUSAPI_RESUMENODE", NDR_CLUSAPI_RESUMENODE, api_clusapi_ResumeNode},
	{"CLUSAPI_EVICTNODE", NDR_CLUSAPI_EVICTNODE, api_clusapi_EvictNode},
	{"CLUSAPI_NODERESOURCECONTROL", NDR_CLUSAPI_NODERESOURCECONTROL, api_clusapi_NodeResourceControl},
	{"CLUSAPI_RESOURCECONTROL", NDR_CLUSAPI_RESOURCECONTROL, api_clusapi_ResourceControl},
	{"CLUSAPI_NODERESOURCETYPECONTROL", NDR_CLUSAPI_NODERESOURCETYPECONTROL, api_clusapi_NodeResourceTypeControl},
	{"CLUSAPI_RESOURCETYPECONTROL", NDR_CLUSAPI_RESOURCETYPECONTROL, api_clusapi_ResourceTypeControl},
	{"CLUSAPI_NODEGROUPCONTROL", NDR_CLUSAPI_NODEGROUPCONTROL, api_clusapi_NodeGroupControl},
	{"CLUSAPI_GROUPCONTROL", NDR_CLUSAPI_GROUPCONTROL, api_clusapi_GroupControl},
	{"CLUSAPI_NODENODECONTROL", NDR_CLUSAPI_NODENODECONTROL, api_clusapi_NodeNodeControl},
	{"CLUSAPI_NODECONTROL", NDR_CLUSAPI_NODECONTROL, api_clusapi_NodeControl},
	{"OPNUM80NOTUSEDONWIRE", NDR_OPNUM80NOTUSEDONWIRE, api_Opnum80NotUsedOnWire},
	{"CLUSAPI_OPENNETWORK", NDR_CLUSAPI_OPENNETWORK, api_clusapi_OpenNetwork},
	{"CLUSAPI_CLOSENETWORK", NDR_CLUSAPI_CLOSENETWORK, api_clusapi_CloseNetwork},
	{"CLUSAPI_GETNETWORKSTATE", NDR_CLUSAPI_GETNETWORKSTATE, api_clusapi_GetNetworkState},
	{"CLUSAPI_SETNETWORKNAME", NDR_CLUSAPI_SETNETWORKNAME, api_clusapi_SetNetworkName},
	{"CLUSAPI_CREATENETWORKENUM", NDR_CLUSAPI_CREATENETWORKENUM, api_clusapi_CreateNetworkEnum},
	{"CLUSAPI_GETNETWORKID", NDR_CLUSAPI_GETNETWORKID, api_clusapi_GetNetworkId},
	{"CLUSAPI_SETNETWORKPRIORITYORDER", NDR_CLUSAPI_SETNETWORKPRIORITYORDER, api_clusapi_SetNetworkPriorityOrder},
	{"CLUSAPI_NODENETWORKCONTROL", NDR_CLUSAPI_NODENETWORKCONTROL, api_clusapi_NodeNetworkControl},
	{"CLUSAPI_NETWORKCONTROL", NDR_CLUSAPI_NETWORKCONTROL, api_clusapi_NetworkControl},
	{"CLUSAPI_ADDNOTIFYNETWORK", NDR_CLUSAPI_ADDNOTIFYNETWORK, api_clusapi_AddNotifyNetwork},
	{"CLUSAPI_READDNOTIFYNETWORK", NDR_CLUSAPI_READDNOTIFYNETWORK, api_clusapi_ReAddNotifyNetwork},
	{"CLUSAPI_OPENNETINTERFACE", NDR_CLUSAPI_OPENNETINTERFACE, api_clusapi_OpenNetInterface},
	{"CLUSAPI_CLOSENETINTERFACE", NDR_CLUSAPI_CLOSENETINTERFACE, api_clusapi_CloseNetInterface},
	{"CLUSAPI_GETNETINTERFACESTATE", NDR_CLUSAPI_GETNETINTERFACESTATE, api_clusapi_GetNetInterfaceState},
	{"CLUSAPI_GETNETINTERFACE", NDR_CLUSAPI_GETNETINTERFACE, api_clusapi_GetNetInterface},
	{"CLUSAPI_GETNETINTERFACEID", NDR_CLUSAPI_GETNETINTERFACEID, api_clusapi_GetNetInterfaceId},
	{"CLUSAPI_NODENETINTERFACECONTROL", NDR_CLUSAPI_NODENETINTERFACECONTROL, api_clusapi_NodeNetInterfaceControl},
	{"CLUSAPI_NETINTERFACECONTROL", NDR_CLUSAPI_NETINTERFACECONTROL, api_clusapi_NetInterfaceControl},
	{"CLUSAPI_ADDNOTIFYNETINTERFACE", NDR_CLUSAPI_ADDNOTIFYNETINTERFACE, api_clusapi_AddNotifyNetInterface},
	{"CLUSAPI_READDNOTIFYNETINTERFACE", NDR_CLUSAPI_READDNOTIFYNETINTERFACE, api_clusapi_ReAddNotifyNetInterface},
	{"CLUSAPI_CREATENODEENUM", NDR_CLUSAPI_CREATENODEENUM, api_clusapi_CreateNodeEnum},
	{"CLUSAPI_GETCLUSTERVERSION2", NDR_CLUSAPI_GETCLUSTERVERSION2, api_clusapi_GetClusterVersion2},
	{"CLUSAPI_CREATERESTYPEENUM", NDR_CLUSAPI_CREATERESTYPEENUM, api_clusapi_CreateResTypeEnum},
	{"CLUSAPI_BACKUPCLUSTERDATABASE", NDR_CLUSAPI_BACKUPCLUSTERDATABASE, api_clusapi_BackupClusterDatabase},
	{"CLUSAPI_NODECLUSTERCONTROL", NDR_CLUSAPI_NODECLUSTERCONTROL, api_clusapi_NodeClusterControl},
	{"CLUSAPI_CLUSTERCONTROL", NDR_CLUSAPI_CLUSTERCONTROL, api_clusapi_ClusterControl},
	{"CLUSAPI_UNBLOCKGETNOTIFYCALL", NDR_CLUSAPI_UNBLOCKGETNOTIFYCALL, api_clusapi_UnblockGetNotifyCall},
	{"CLUSAPI_SETSERVICEACCOUNTPASSWORD", NDR_CLUSAPI_SETSERVICEACCOUNTPASSWORD, api_clusapi_SetServiceAccountPassword},
	{"CLUSAPI_SETRESOURCEDEPENDENCYEXPRESSION", NDR_CLUSAPI_SETRESOURCEDEPENDENCYEXPRESSION, api_clusapi_SetResourceDependencyExpression},
	{"CLUSAPI_GETRESOURCEDEPENDENCYEXPRESSION", NDR_CLUSAPI_GETRESOURCEDEPENDENCYEXPRESSION, api_clusapi_GetResourceDependencyExpression},
	{"OPNUM111NOTUSEDONWIRE", NDR_OPNUM111NOTUSEDONWIRE, api_Opnum111NotUsedOnWire},
	{"CLUSAPI_GETRESOURCENETWORKNAME", NDR_CLUSAPI_GETRESOURCENETWORKNAME, api_clusapi_GetResourceNetworkName},
	{"CLUSAPI_EXECUTEBATCH", NDR_CLUSAPI_EXECUTEBATCH, api_clusapi_ExecuteBatch},
	{"CLUSAPI_CREATEBATCHPORT", NDR_CLUSAPI_CREATEBATCHPORT, api_clusapi_CreateBatchPort},
	{"CLUSAPI_GETBATCHNOTIFICATION", NDR_CLUSAPI_GETBATCHNOTIFICATION, api_clusapi_GetBatchNotification},
	{"CLUSAPI_CLOSEBATCHPORT", NDR_CLUSAPI_CLOSEBATCHPORT, api_clusapi_CloseBatchPort},
	{"CLUSAPI_OPENCLUSTEREX", NDR_CLUSAPI_OPENCLUSTEREX, api_clusapi_OpenClusterEx},
	{"CLUSAPI_OPENNODEEX", NDR_CLUSAPI_OPENNODEEX, api_clusapi_OpenNodeEx},
	{"CLUSAPI_OPENGROUPEX", NDR_CLUSAPI_OPENGROUPEX, api_clusapi_OpenGroupEx},
	{"CLUSAPI_OPENRESOURCEEX", NDR_CLUSAPI_OPENRESOURCEEX, api_clusapi_OpenResourceEx},
	{"CLUSAPI_OPENNETWORKEX", NDR_CLUSAPI_OPENNETWORKEX, api_clusapi_OpenNetworkEx},
	{"CLUSAPI_OPENNETINTERFACEEX", NDR_CLUSAPI_OPENNETINTERFACEEX, api_clusapi_OpenNetInterfaceEx},
	{"CLUSAPI_CHANGECSVSTATE", NDR_CLUSAPI_CHANGECSVSTATE, api_clusapi_ChangeCsvState},
	{"CLUSAPI_CREATENODEENUMEX", NDR_CLUSAPI_CREATENODEENUMEX, api_clusapi_CreateNodeEnumEx},
	{"CLUSAPI_CREATEENUMEX", NDR_CLUSAPI_CREATEENUMEX, api_clusapi_CreateEnumEx},
	{"CLUSAPI_PAUSENODEEX", NDR_CLUSAPI_PAUSENODEEX, api_clusapi_PauseNodeEx},
	{"CLUSAPI_PAUSENODEWITHDRAINTARGET", NDR_CLUSAPI_PAUSENODEWITHDRAINTARGET, api_clusapi_PauseNodeWithDrainTarget},
	{"CLUSAPI_RESUMENODEEX", NDR_CLUSAPI_RESUMENODEEX, api_clusapi_ResumeNodeEx},
	{"CLUSAPI_CREATEGROUPEX", NDR_CLUSAPI_CREATEGROUPEX, api_clusapi_CreateGroupEx},
	{"CLUSAPI_ONLINEGROUPEX", NDR_CLUSAPI_ONLINEGROUPEX, api_clusapi_OnlineGroupEx},
	{"CLUSAPI_OFFLINEGROUPEX", NDR_CLUSAPI_OFFLINEGROUPEX, api_clusapi_OfflineGroupEx},
	{"CLUSAPI_MOVEGROUPEX", NDR_CLUSAPI_MOVEGROUPEX, api_clusapi_MoveGroupEx},
	{"CLUSAPI_MOVEGROUPTONODEEX", NDR_CLUSAPI_MOVEGROUPTONODEEX, api_clusapi_MoveGroupToNodeEx},
	{"CLUSAPI_CANCELCLUSTERGROUPOPERATION", NDR_CLUSAPI_CANCELCLUSTERGROUPOPERATION, api_clusapi_CancelClusterGroupOperation},
	{"CLUSAPI_ONLINERESOURCEEX", NDR_CLUSAPI_ONLINERESOURCEEX, api_clusapi_OnlineResourceEx},
	{"CLUSAPI_OFFLINERESOURCEEX", NDR_CLUSAPI_OFFLINERESOURCEEX, api_clusapi_OfflineResourceEx},
	{"CLUSAPI_CREATENOTIFYV2", NDR_CLUSAPI_CREATENOTIFYV2, api_clusapi_CreateNotifyV2},
	{"CLUSAPI_ADDNOTIFYV2", NDR_CLUSAPI_ADDNOTIFYV2, api_clusapi_AddNotifyV2},
	{"CLUSAPI_GETNOTIFYV2", NDR_CLUSAPI_GETNOTIFYV2, api_clusapi_GetNotifyV2},
	{"CLUSAPI_QUERYALLVALUES", NDR_CLUSAPI_QUERYALLVALUES, api_clusapi_QueryAllValues},
	{"CLUSAPI_STMFINDDISK", NDR_CLUSAPI_STMFINDDISK, api_clusapi_StmFindDisk},
	{"CLUSAPI_CLUSTERMRR", NDR_CLUSAPI_CLUSTERMRR, api_clusapi_ClusterMrr},
	{"CLUSAPI_CREATEGROUPENUM", NDR_CLUSAPI_CREATEGROUPENUM, api_clusapi_CreateGroupEnum},
	{"CLUSAPI_CREATERESOURCEENUM", NDR_CLUSAPI_CREATERESOURCEENUM, api_clusapi_CreateResourceEnum},
	{"CLUSAPI_EXECUTEREADBATCH", NDR_CLUSAPI_EXECUTEREADBATCH, api_clusapi_ExecuteReadBatch},
	{"CLUSAPI_RESTARTRESOURCE", NDR_CLUSAPI_RESTARTRESOURCE, api_clusapi_RestartResource},
	{"CLUSAPI_GETNOTIFYASYNC", NDR_CLUSAPI_GETNOTIFYASYNC, api_clusapi_GetNotifyAsync},
};

const struct api_struct *clusapi_get_pipe_fns(int *n_fns)
{
	*n_fns = sizeof(api_clusapi_cmds) / sizeof(struct api_struct);
	return api_clusapi_cmds;
}

NTSTATUS rpc_clusapi_init(const struct rpc_srv_callbacks *rpc_srv_cb)
{
	return rpc_srv_register(SMB_RPC_INTERFACE_VERSION, "clusapi", "clusapi", &ndr_table_clusapi, api_clusapi_cmds, sizeof(api_clusapi_cmds) / sizeof(struct api_struct), rpc_srv_cb);
}

NTSTATUS rpc_clusapi_shutdown(void)
{
	return rpc_srv_unregister(&ndr_table_clusapi);
}
