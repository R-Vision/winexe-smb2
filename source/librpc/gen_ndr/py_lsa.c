
/* Python wrapper functions auto-generated by pidl */
#define PY_SSIZE_T_CLEAN 1 /* We use Py_ssize_t for PyArg_ParseTupleAndKeywords */
#include <Python.h>
#include "python/py3compat.h"
#include "includes.h"
#include <pytalloc.h>
#include "librpc/rpc/pyrpc.h"
#include "librpc/rpc/pyrpc_util.h"
#include "bin/default/librpc/gen_ndr/ndr_lsa.h"
#include "bin/default/librpc/gen_ndr/ndr_lsa_c.h"

/*
 * These functions are here to ensure they can be optimized out by
 * the compiler based on the constant input values
 */

static inline unsigned long long ndr_sizeof2uintmax(size_t var_size)
{
	switch (var_size) {
	case 8:
		return UINT64_MAX;
	case 4:
		return UINT32_MAX;
	case 2:
		return UINT16_MAX;
	case 1:
		return UINT8_MAX;
	}

	return 0;
}

static inline long long ndr_sizeof2intmax(size_t var_size)
{
	switch (var_size) {
	case 8:
		return INT64_MAX;
	case 4:
		return INT32_MAX;
	case 2:
		return INT16_MAX;
	case 1:
		return INT8_MAX;
	}

	return 0;
}

static inline PyObject *ndr_PyLong_FromLongLong(long long v)
{
	if (v > LONG_MAX || v < LONG_MIN) {
		return PyLong_FromLongLong(v);
	} else {
		return PyInt_FromLong(v);
	}
}

static inline PyObject *ndr_PyLong_FromUnsignedLongLong(unsigned long long v)
{
	if (v > LONG_MAX) {
		return PyLong_FromUnsignedLongLong(v);
	} else {
		return PyInt_FromLong(v);
	}
}

#include "librpc/gen_ndr/misc.h"
#include "librpc/gen_ndr/security.h"
static PyTypeObject lsa_String_Type;
static PyTypeObject lsa_StringLarge_Type;
static PyTypeObject lsa_Strings_Type;
static PyTypeObject lsa_AsciiString_Type;
static PyTypeObject lsa_AsciiStringLarge_Type;
static PyTypeObject lsa_BinaryString_Type;
static PyTypeObject lsa_LUID_Type;
static PyTypeObject lsa_PrivEntry_Type;
static PyTypeObject lsa_PrivArray_Type;
static PyTypeObject lsa_QosInfo_Type;
static PyTypeObject lsa_ObjectAttribute_Type;
static PyTypeObject lsa_AuditLogInfo_Type;
static PyTypeObject lsa_AuditEventsInfo_Type;
static PyTypeObject lsa_DomainInfo_Type;
static PyTypeObject lsa_PDAccountInfo_Type;
static PyTypeObject lsa_ServerRole_Type;
static PyTypeObject lsa_ReplicaSourceInfo_Type;
static PyTypeObject lsa_DefaultQuotaInfo_Type;
static PyTypeObject lsa_ModificationInfo_Type;
static PyTypeObject lsa_AuditFullSetInfo_Type;
static PyTypeObject lsa_AuditFullQueryInfo_Type;
static PyTypeObject lsa_DnsDomainInfo_Type;
static PyTypeObject lsa_PolicyInformation_Type;
static PyTypeObject lsa_SidPtr_Type;
static PyTypeObject lsa_SidArray_Type;
static PyTypeObject lsa_DomainList_Type;
static PyTypeObject lsa_TranslatedSid_Type;
static PyTypeObject lsa_TransSidArray_Type;
static PyTypeObject lsa_RefDomainList_Type;
static PyTypeObject lsa_TranslatedName_Type;
static PyTypeObject lsa_TransNameArray_Type;
static PyTypeObject lsa_LUIDAttribute_Type;
static PyTypeObject lsa_PrivilegeSet_Type;
static PyTypeObject lsa_DATA_BUF_Type;
static PyTypeObject lsa_DATA_BUF2_Type;
static PyTypeObject lsa_TrustDomainInfoName_Type;
static PyTypeObject lsa_TrustDomainInfoControllers_Type;
static PyTypeObject lsa_TrustDomainInfoPosixOffset_Type;
static PyTypeObject lsa_TrustDomainInfoPassword_Type;
static PyTypeObject lsa_TrustDomainInfoBasic_Type;
static PyTypeObject lsa_TrustDomainInfoInfoEx_Type;
static PyTypeObject lsa_TrustDomainInfoBuffer_Type;
static PyTypeObject lsa_TrustDomainInfoAuthInfo_Type;
static PyTypeObject lsa_TrustDomainInfoFullInfo_Type;
static PyTypeObject lsa_TrustDomainInfoAuthInfoInternal_Type;
static PyTypeObject lsa_TrustDomainInfoFullInfoInternal_Type;
static PyTypeObject lsa_TrustDomainInfoInfoEx2Internal_Type;
static PyTypeObject lsa_TrustDomainInfoFullInfo2Internal_Type;
static PyTypeObject lsa_TrustDomainInfoSupportedEncTypes_Type;
static PyTypeObject lsa_TrustedDomainInfo_Type;
static PyTypeObject lsa_DATA_BUF_PTR_Type;
static PyTypeObject lsa_RightAttribute_Type;
static PyTypeObject lsa_RightSet_Type;
static PyTypeObject lsa_DomainListEx_Type;
static PyTypeObject lsa_DomainInfoKerberos_Type;
static PyTypeObject lsa_DomainInfoEfs_Type;
static PyTypeObject lsa_DomainInformationPolicy_Type;
static PyTypeObject lsa_TranslatedName2_Type;
static PyTypeObject lsa_TransNameArray2_Type;
static PyTypeObject lsa_TranslatedSid2_Type;
static PyTypeObject lsa_TransSidArray2_Type;
static PyTypeObject lsa_TranslatedSid3_Type;
static PyTypeObject lsa_TransSidArray3_Type;
static PyTypeObject lsa_ForestTrustBinaryData_Type;
static PyTypeObject lsa_ForestTrustDomainInfo_Type;
static PyTypeObject lsa_ForestTrustData_Type;
static PyTypeObject lsa_ForestTrustRecord_Type;
static PyTypeObject lsa_ForestTrustInformation_Type;
static PyTypeObject lsa_ForestTrustCollisionRecord_Type;
static PyTypeObject lsa_ForestTrustCollisionInfo_Type;
static PyTypeObject lsarpc_InterfaceType;
static PyTypeObject lsa_Close_Type;
static PyTypeObject lsa_Delete_Type;
static PyTypeObject lsa_EnumPrivs_Type;
static PyTypeObject lsa_QuerySecurity_Type;
static PyTypeObject lsa_SetSecObj_Type;
static PyTypeObject lsa_OpenPolicy_Type;
static PyTypeObject lsa_QueryInfoPolicy_Type;
static PyTypeObject lsa_SetInfoPolicy_Type;
static PyTypeObject lsa_CreateAccount_Type;
static PyTypeObject lsa_EnumAccounts_Type;
static PyTypeObject lsa_CreateTrustedDomain_Type;
static PyTypeObject lsa_EnumTrustDom_Type;
static PyTypeObject lsa_LookupNames_Type;
static PyTypeObject lsa_LookupSids_Type;
static PyTypeObject lsa_CreateSecret_Type;
static PyTypeObject lsa_OpenAccount_Type;
static PyTypeObject lsa_EnumPrivsAccount_Type;
static PyTypeObject lsa_AddPrivilegesToAccount_Type;
static PyTypeObject lsa_RemovePrivilegesFromAccount_Type;
static PyTypeObject lsa_GetSystemAccessAccount_Type;
static PyTypeObject lsa_SetSystemAccessAccount_Type;
static PyTypeObject lsa_OpenTrustedDomain_Type;
static PyTypeObject lsa_QueryTrustedDomainInfo_Type;
static PyTypeObject lsa_SetInformationTrustedDomain_Type;
static PyTypeObject lsa_OpenSecret_Type;
static PyTypeObject lsa_SetSecret_Type;
static PyTypeObject lsa_QuerySecret_Type;
static PyTypeObject lsa_LookupPrivValue_Type;
static PyTypeObject lsa_LookupPrivName_Type;
static PyTypeObject lsa_LookupPrivDisplayName_Type;
static PyTypeObject lsa_DeleteObject_Type;
static PyTypeObject lsa_EnumAccountsWithUserRight_Type;
static PyTypeObject lsa_EnumAccountRights_Type;
static PyTypeObject lsa_AddAccountRights_Type;
static PyTypeObject lsa_RemoveAccountRights_Type;
static PyTypeObject lsa_QueryTrustedDomainInfoBySid_Type;
static PyTypeObject lsa_SetTrustedDomainInfo_Type;
static PyTypeObject lsa_DeleteTrustedDomain_Type;
static PyTypeObject lsa_StorePrivateData_Type;
static PyTypeObject lsa_RetrievePrivateData_Type;
static PyTypeObject lsa_OpenPolicy2_Type;
static PyTypeObject lsa_GetUserName_Type;
static PyTypeObject lsa_QueryInfoPolicy2_Type;
static PyTypeObject lsa_SetInfoPolicy2_Type;
static PyTypeObject lsa_QueryTrustedDomainInfoByName_Type;
static PyTypeObject lsa_SetTrustedDomainInfoByName_Type;
static PyTypeObject lsa_EnumTrustedDomainsEx_Type;
static PyTypeObject lsa_CreateTrustedDomainEx_Type;
static PyTypeObject lsa_CloseTrustedDomainEx_Type;
static PyTypeObject lsa_QueryDomainInformationPolicy_Type;
static PyTypeObject lsa_SetDomainInformationPolicy_Type;
static PyTypeObject lsa_OpenTrustedDomainByName_Type;
static PyTypeObject lsa_LookupSids2_Type;
static PyTypeObject lsa_LookupNames2_Type;
static PyTypeObject lsa_CreateTrustedDomainEx2_Type;
static PyTypeObject lsa_LookupNames3_Type;
static PyTypeObject lsa_lsaRQueryForestTrustInformation_Type;
static PyTypeObject lsa_lsaRSetForestTrustInformation_Type;
static PyTypeObject lsa_LookupSids3_Type;
static PyTypeObject lsa_LookupNames4_Type;

static PyTypeObject *BaseObject_Type;
static PyTypeObject *security_descriptor_Type;
static PyTypeObject *dom_sid_Type;
static PyTypeObject *GUID_Type;
static PyTypeObject *policy_handle_Type;
static PyTypeObject *sec_desc_buf_Type;
static PyTypeObject *ClientConnection_Type;
static PyTypeObject *ndr_syntax_id_Type;
#include "librpc/ndr/py_lsa.c"


static PyObject *py_lsa_String_get_length(PyObject *obj, void *closure)
{
	struct lsa_String *object = (struct lsa_String *)pytalloc_get_ptr(obj);
	PyObject *py_length;
	py_length = PyInt_FromLong((uint16_t)object->length);
	return py_length;
}

static int py_lsa_String_set_length(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_String *object = (struct lsa_String *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->length");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->length));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->length = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->length = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_String_get_size(PyObject *obj, void *closure)
{
	struct lsa_String *object = (struct lsa_String *)pytalloc_get_ptr(obj);
	PyObject *py_size;
	py_size = PyInt_FromLong((uint16_t)object->size);
	return py_size;
}

static int py_lsa_String_set_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_String *object = (struct lsa_String *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_String_get_string(PyObject *obj, void *closure)
{
	struct lsa_String *object = (struct lsa_String *)pytalloc_get_ptr(obj);
	PyObject *py_string;
	if (object->string == NULL) {
		py_string = Py_None;
		Py_INCREF(py_string);
	} else {
		if (object->string == NULL) {
			py_string = Py_None;
			Py_INCREF(py_string);
		} else {
			py_string = PyUnicode_Decode(object->string, strlen(object->string), "utf-8", "ignore");
		}
	}
	return py_string;
}

static int py_lsa_String_set_string(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_String *object = (struct lsa_String *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->string");
		return -1;
	}
	if (value == Py_None) {
		object->string = NULL;
	} else {
		object->string = NULL;
		{
			const char *test_str;
			const char *talloc_str;
			PyObject *unicode = NULL;
			if (PyUnicode_Check(value)) {
				unicode = PyUnicode_AsEncodedString(value, "utf-8", "ignore");
				if (unicode == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				test_str = PyBytes_AS_STRING(unicode);
			} else if (PyBytes_Check(value)) {
				test_str = PyBytes_AS_STRING(value);
			} else {
				PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
				return -1;
			}
			talloc_str = talloc_strdup(pytalloc_get_mem_ctx(py_obj), test_str);
			if (unicode != NULL) {
				Py_DECREF(unicode);
			}
			if (talloc_str == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->string = talloc_str;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_String_getsetters[] = {
	{
		.name = discard_const_p(char, "length"),
		.get = py_lsa_String_get_length,
		.set = py_lsa_String_set_length,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "size"),
		.get = py_lsa_String_get_size,
		.set = py_lsa_String_set_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "string"),
		.get = py_lsa_String_get_string,
		.set = py_lsa_String_set_string,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_String_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_String, type);
}

static PyObject *py_lsa_String_ndr_pack(PyObject *py_obj)
{
	struct lsa_String *object = (struct lsa_String *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_lsa_String);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_lsa_String_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct lsa_String *object = (struct lsa_String *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_String);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_String);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_lsa_String_ndr_print(PyObject *py_obj)
{
	struct lsa_String *object = (struct lsa_String *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_lsa_String, "lsa_String", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_lsa_String_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_lsa_String_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_lsa_String_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_lsa_String_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_String_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.String",
	.tp_getset = py_lsa_String_getsetters,
	.tp_methods = py_lsa_String_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_String_new,
};


static PyObject *py_lsa_StringLarge_get_length(PyObject *obj, void *closure)
{
	struct lsa_StringLarge *object = (struct lsa_StringLarge *)pytalloc_get_ptr(obj);
	PyObject *py_length;
	py_length = PyInt_FromLong((uint16_t)object->length);
	return py_length;
}

static int py_lsa_StringLarge_set_length(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_StringLarge *object = (struct lsa_StringLarge *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->length");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->length));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->length = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->length = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_StringLarge_get_size(PyObject *obj, void *closure)
{
	struct lsa_StringLarge *object = (struct lsa_StringLarge *)pytalloc_get_ptr(obj);
	PyObject *py_size;
	py_size = PyInt_FromLong((uint16_t)object->size);
	return py_size;
}

static int py_lsa_StringLarge_set_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_StringLarge *object = (struct lsa_StringLarge *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_StringLarge_get_string(PyObject *obj, void *closure)
{
	struct lsa_StringLarge *object = (struct lsa_StringLarge *)pytalloc_get_ptr(obj);
	PyObject *py_string;
	if (object->string == NULL) {
		py_string = Py_None;
		Py_INCREF(py_string);
	} else {
		if (object->string == NULL) {
			py_string = Py_None;
			Py_INCREF(py_string);
		} else {
			py_string = PyUnicode_Decode(object->string, strlen(object->string), "utf-8", "ignore");
		}
	}
	return py_string;
}

static int py_lsa_StringLarge_set_string(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_StringLarge *object = (struct lsa_StringLarge *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->string");
		return -1;
	}
	if (value == Py_None) {
		object->string = NULL;
	} else {
		object->string = NULL;
		{
			const char *test_str;
			const char *talloc_str;
			PyObject *unicode = NULL;
			if (PyUnicode_Check(value)) {
				unicode = PyUnicode_AsEncodedString(value, "utf-8", "ignore");
				if (unicode == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				test_str = PyBytes_AS_STRING(unicode);
			} else if (PyBytes_Check(value)) {
				test_str = PyBytes_AS_STRING(value);
			} else {
				PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
				return -1;
			}
			talloc_str = talloc_strdup(pytalloc_get_mem_ctx(py_obj), test_str);
			if (unicode != NULL) {
				Py_DECREF(unicode);
			}
			if (talloc_str == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->string = talloc_str;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_StringLarge_getsetters[] = {
	{
		.name = discard_const_p(char, "length"),
		.get = py_lsa_StringLarge_get_length,
		.set = py_lsa_StringLarge_set_length,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "size"),
		.get = py_lsa_StringLarge_get_size,
		.set = py_lsa_StringLarge_set_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "string"),
		.get = py_lsa_StringLarge_get_string,
		.set = py_lsa_StringLarge_set_string,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_StringLarge_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_StringLarge, type);
}

static PyObject *py_lsa_StringLarge_ndr_pack(PyObject *py_obj)
{
	struct lsa_StringLarge *object = (struct lsa_StringLarge *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_lsa_StringLarge);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_lsa_StringLarge_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct lsa_StringLarge *object = (struct lsa_StringLarge *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_StringLarge);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_StringLarge);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_lsa_StringLarge_ndr_print(PyObject *py_obj)
{
	struct lsa_StringLarge *object = (struct lsa_StringLarge *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_lsa_StringLarge, "lsa_StringLarge", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_lsa_StringLarge_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_lsa_StringLarge_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_lsa_StringLarge_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_lsa_StringLarge_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_StringLarge_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.StringLarge",
	.tp_getset = py_lsa_StringLarge_getsetters,
	.tp_methods = py_lsa_StringLarge_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_StringLarge_new,
};


static PyObject *py_lsa_Strings_get_count(PyObject *obj, void *closure)
{
	struct lsa_Strings *object = (struct lsa_Strings *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->count);
	return py_count;
}

static int py_lsa_Strings_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_Strings *object = (struct lsa_Strings *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_Strings_get_names(PyObject *obj, void *closure)
{
	struct lsa_Strings *object = (struct lsa_Strings *)pytalloc_get_ptr(obj);
	PyObject *py_names;
	if (object->names == NULL) {
		py_names = Py_None;
		Py_INCREF(py_names);
	} else {
		py_names = PyList_New(object->count);
		if (py_names == NULL) {
			return NULL;
		}
		{
			int names_cntr_1;
			for (names_cntr_1 = 0; names_cntr_1 < (object->count); names_cntr_1++) {
				PyObject *py_names_1;
				py_names_1 = pytalloc_reference_ex(&lsa_String_Type, object->names, &object->names[names_cntr_1]);
				PyList_SetItem(py_names, names_cntr_1, py_names_1);
			}
		}
	}
	return py_names;
}

static int py_lsa_Strings_set_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_Strings *object = (struct lsa_Strings *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->names));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->names");
		return -1;
	}
	if (value == Py_None) {
		object->names = NULL;
	} else {
		object->names = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int names_cntr_1;
			object->names = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->names, PyList_GET_SIZE(value));
			if (!object->names) { return -1;; }
			talloc_set_name_const(object->names, "ARRAY: object->names");
			for (names_cntr_1 = 0; names_cntr_1 < PyList_GET_SIZE(value); names_cntr_1++) {
				if (PyList_GET_ITEM(value, names_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->names[names_cntr_1]");
					return -1;
				}
				PY_CHECK_TYPE(&lsa_String_Type, PyList_GET_ITEM(value, names_cntr_1), return -1;);
				if (talloc_reference(object->names, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, names_cntr_1))) == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				object->names[names_cntr_1] = *(struct lsa_String *)pytalloc_get_ptr(PyList_GET_ITEM(value, names_cntr_1));
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_Strings_getsetters[] = {
	{
		.name = discard_const_p(char, "count"),
		.get = py_lsa_Strings_get_count,
		.set = py_lsa_Strings_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "names"),
		.get = py_lsa_Strings_get_names,
		.set = py_lsa_Strings_set_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_Strings_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_Strings, type);
}

static PyObject *py_lsa_Strings_ndr_pack(PyObject *py_obj)
{
	struct lsa_Strings *object = (struct lsa_Strings *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_lsa_Strings);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_lsa_Strings_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct lsa_Strings *object = (struct lsa_Strings *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_Strings);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_Strings);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_lsa_Strings_ndr_print(PyObject *py_obj)
{
	struct lsa_Strings *object = (struct lsa_Strings *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_lsa_Strings, "lsa_Strings", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_lsa_Strings_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_lsa_Strings_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_lsa_Strings_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_lsa_Strings_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_Strings_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.Strings",
	.tp_getset = py_lsa_Strings_getsetters,
	.tp_methods = py_lsa_Strings_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_Strings_new,
};


static PyObject *py_lsa_AsciiString_get_length(PyObject *obj, void *closure)
{
	struct lsa_AsciiString *object = (struct lsa_AsciiString *)pytalloc_get_ptr(obj);
	PyObject *py_length;
	py_length = PyInt_FromLong((uint16_t)object->length);
	return py_length;
}

static int py_lsa_AsciiString_set_length(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AsciiString *object = (struct lsa_AsciiString *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->length");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->length));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->length = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->length = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_AsciiString_get_size(PyObject *obj, void *closure)
{
	struct lsa_AsciiString *object = (struct lsa_AsciiString *)pytalloc_get_ptr(obj);
	PyObject *py_size;
	py_size = PyInt_FromLong((uint16_t)object->size);
	return py_size;
}

static int py_lsa_AsciiString_set_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AsciiString *object = (struct lsa_AsciiString *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_AsciiString_get_string(PyObject *obj, void *closure)
{
	struct lsa_AsciiString *object = (struct lsa_AsciiString *)pytalloc_get_ptr(obj);
	PyObject *py_string;
	if (object->string == NULL) {
		py_string = Py_None;
		Py_INCREF(py_string);
	} else {
		if (object->string == NULL) {
			py_string = Py_None;
			Py_INCREF(py_string);
		} else {
			py_string = PyUnicode_Decode(object->string, strlen(object->string), "utf-8", "ignore");
		}
	}
	return py_string;
}

static int py_lsa_AsciiString_set_string(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AsciiString *object = (struct lsa_AsciiString *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->string");
		return -1;
	}
	if (value == Py_None) {
		object->string = NULL;
	} else {
		object->string = NULL;
		{
			const char *test_str;
			const char *talloc_str;
			PyObject *unicode = NULL;
			if (PyUnicode_Check(value)) {
				unicode = PyUnicode_AsEncodedString(value, "utf-8", "ignore");
				if (unicode == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				test_str = PyBytes_AS_STRING(unicode);
			} else if (PyBytes_Check(value)) {
				test_str = PyBytes_AS_STRING(value);
			} else {
				PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
				return -1;
			}
			talloc_str = talloc_strdup(pytalloc_get_mem_ctx(py_obj), test_str);
			if (unicode != NULL) {
				Py_DECREF(unicode);
			}
			if (talloc_str == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->string = talloc_str;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_AsciiString_getsetters[] = {
	{
		.name = discard_const_p(char, "length"),
		.get = py_lsa_AsciiString_get_length,
		.set = py_lsa_AsciiString_set_length,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "size"),
		.get = py_lsa_AsciiString_get_size,
		.set = py_lsa_AsciiString_set_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "string"),
		.get = py_lsa_AsciiString_get_string,
		.set = py_lsa_AsciiString_set_string,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_AsciiString_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_AsciiString, type);
}

static PyObject *py_lsa_AsciiString_ndr_pack(PyObject *py_obj)
{
	struct lsa_AsciiString *object = (struct lsa_AsciiString *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_lsa_AsciiString);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_lsa_AsciiString_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct lsa_AsciiString *object = (struct lsa_AsciiString *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_AsciiString);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_AsciiString);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_lsa_AsciiString_ndr_print(PyObject *py_obj)
{
	struct lsa_AsciiString *object = (struct lsa_AsciiString *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_lsa_AsciiString, "lsa_AsciiString", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_lsa_AsciiString_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_lsa_AsciiString_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_lsa_AsciiString_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_lsa_AsciiString_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_AsciiString_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.AsciiString",
	.tp_getset = py_lsa_AsciiString_getsetters,
	.tp_methods = py_lsa_AsciiString_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_AsciiString_new,
};


static PyObject *py_lsa_AsciiStringLarge_get_length(PyObject *obj, void *closure)
{
	struct lsa_AsciiStringLarge *object = (struct lsa_AsciiStringLarge *)pytalloc_get_ptr(obj);
	PyObject *py_length;
	py_length = PyInt_FromLong((uint16_t)object->length);
	return py_length;
}

static int py_lsa_AsciiStringLarge_set_length(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AsciiStringLarge *object = (struct lsa_AsciiStringLarge *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->length");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->length));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->length = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->length = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_AsciiStringLarge_get_size(PyObject *obj, void *closure)
{
	struct lsa_AsciiStringLarge *object = (struct lsa_AsciiStringLarge *)pytalloc_get_ptr(obj);
	PyObject *py_size;
	py_size = PyInt_FromLong((uint16_t)object->size);
	return py_size;
}

static int py_lsa_AsciiStringLarge_set_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AsciiStringLarge *object = (struct lsa_AsciiStringLarge *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_AsciiStringLarge_get_string(PyObject *obj, void *closure)
{
	struct lsa_AsciiStringLarge *object = (struct lsa_AsciiStringLarge *)pytalloc_get_ptr(obj);
	PyObject *py_string;
	if (object->string == NULL) {
		py_string = Py_None;
		Py_INCREF(py_string);
	} else {
		if (object->string == NULL) {
			py_string = Py_None;
			Py_INCREF(py_string);
		} else {
			py_string = PyUnicode_Decode(object->string, strlen(object->string), "utf-8", "ignore");
		}
	}
	return py_string;
}

static int py_lsa_AsciiStringLarge_set_string(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AsciiStringLarge *object = (struct lsa_AsciiStringLarge *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->string");
		return -1;
	}
	if (value == Py_None) {
		object->string = NULL;
	} else {
		object->string = NULL;
		{
			const char *test_str;
			const char *talloc_str;
			PyObject *unicode = NULL;
			if (PyUnicode_Check(value)) {
				unicode = PyUnicode_AsEncodedString(value, "utf-8", "ignore");
				if (unicode == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				test_str = PyBytes_AS_STRING(unicode);
			} else if (PyBytes_Check(value)) {
				test_str = PyBytes_AS_STRING(value);
			} else {
				PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
				return -1;
			}
			talloc_str = talloc_strdup(pytalloc_get_mem_ctx(py_obj), test_str);
			if (unicode != NULL) {
				Py_DECREF(unicode);
			}
			if (talloc_str == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->string = talloc_str;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_AsciiStringLarge_getsetters[] = {
	{
		.name = discard_const_p(char, "length"),
		.get = py_lsa_AsciiStringLarge_get_length,
		.set = py_lsa_AsciiStringLarge_set_length,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "size"),
		.get = py_lsa_AsciiStringLarge_get_size,
		.set = py_lsa_AsciiStringLarge_set_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "string"),
		.get = py_lsa_AsciiStringLarge_get_string,
		.set = py_lsa_AsciiStringLarge_set_string,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_AsciiStringLarge_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_AsciiStringLarge, type);
}

static PyObject *py_lsa_AsciiStringLarge_ndr_pack(PyObject *py_obj)
{
	struct lsa_AsciiStringLarge *object = (struct lsa_AsciiStringLarge *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_lsa_AsciiStringLarge);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_lsa_AsciiStringLarge_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct lsa_AsciiStringLarge *object = (struct lsa_AsciiStringLarge *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_AsciiStringLarge);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_AsciiStringLarge);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_lsa_AsciiStringLarge_ndr_print(PyObject *py_obj)
{
	struct lsa_AsciiStringLarge *object = (struct lsa_AsciiStringLarge *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_lsa_AsciiStringLarge, "lsa_AsciiStringLarge", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_lsa_AsciiStringLarge_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_lsa_AsciiStringLarge_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_lsa_AsciiStringLarge_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_lsa_AsciiStringLarge_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_AsciiStringLarge_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.AsciiStringLarge",
	.tp_getset = py_lsa_AsciiStringLarge_getsetters,
	.tp_methods = py_lsa_AsciiStringLarge_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_AsciiStringLarge_new,
};


static PyObject *py_lsa_BinaryString_get_length(PyObject *obj, void *closure)
{
	struct lsa_BinaryString *object = (struct lsa_BinaryString *)pytalloc_get_ptr(obj);
	PyObject *py_length;
	py_length = PyInt_FromLong((uint16_t)object->length);
	return py_length;
}

static int py_lsa_BinaryString_set_length(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_BinaryString *object = (struct lsa_BinaryString *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->length");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->length));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->length = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->length = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_BinaryString_get_size(PyObject *obj, void *closure)
{
	struct lsa_BinaryString *object = (struct lsa_BinaryString *)pytalloc_get_ptr(obj);
	PyObject *py_size;
	py_size = PyInt_FromLong((uint16_t)object->size);
	return py_size;
}

static int py_lsa_BinaryString_set_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_BinaryString *object = (struct lsa_BinaryString *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_BinaryString_get_array(PyObject *obj, void *closure)
{
	struct lsa_BinaryString *object = (struct lsa_BinaryString *)pytalloc_get_ptr(obj);
	PyObject *py_array;
	if (object->array == NULL) {
		py_array = Py_None;
		Py_INCREF(py_array);
	} else {
		py_array = PyList_New(object->length / 2);
		if (py_array == NULL) {
			return NULL;
		}
		{
			int array_cntr_1;
			for (array_cntr_1 = 0; array_cntr_1 < (object->length / 2); array_cntr_1++) {
				PyObject *py_array_1;
				py_array_1 = PyInt_FromLong((uint16_t)object->array[array_cntr_1]);
				PyList_SetItem(py_array, array_cntr_1, py_array_1);
			}
		}
	}
	return py_array;
}

static int py_lsa_BinaryString_set_array(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_BinaryString *object = (struct lsa_BinaryString *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->array));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->array");
		return -1;
	}
	if (value == Py_None) {
		object->array = NULL;
	} else {
		object->array = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int array_cntr_1;
			object->array = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->array, PyList_GET_SIZE(value));
			if (!object->array) { return -1;; }
			talloc_set_name_const(object->array, "ARRAY: object->array");
			for (array_cntr_1 = 0; array_cntr_1 < PyList_GET_SIZE(value); array_cntr_1++) {
				if (PyList_GET_ITEM(value, array_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->array[array_cntr_1]");
					return -1;
				}
				{
					const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->array[array_cntr_1]));
					if (PyLong_Check(PyList_GET_ITEM(value, array_cntr_1))) {
						unsigned long long test_var;
						test_var = PyLong_AsUnsignedLongLong(PyList_GET_ITEM(value, array_cntr_1));
						if (PyErr_Occurred() != NULL) {
							return -1;
						}
						if (test_var > uint_max) {
							PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
							  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
							return -1;
						}
						object->array[array_cntr_1] = test_var;
					} else if (PyInt_Check(PyList_GET_ITEM(value, array_cntr_1))) {
						long test_var;
						test_var = PyInt_AsLong(PyList_GET_ITEM(value, array_cntr_1));
						if (test_var < 0 || test_var > uint_max) {
							PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
							  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
							return -1;
						}
						object->array[array_cntr_1] = test_var;
					} else {
						PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
						  PyInt_Type.tp_name, PyLong_Type.tp_name);
						return -1;
					}
				}
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_BinaryString_getsetters[] = {
	{
		.name = discard_const_p(char, "length"),
		.get = py_lsa_BinaryString_get_length,
		.set = py_lsa_BinaryString_set_length,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "size"),
		.get = py_lsa_BinaryString_get_size,
		.set = py_lsa_BinaryString_set_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "array"),
		.get = py_lsa_BinaryString_get_array,
		.set = py_lsa_BinaryString_set_array,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_BinaryString_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_BinaryString, type);
}

static PyObject *py_lsa_BinaryString_ndr_pack(PyObject *py_obj)
{
	struct lsa_BinaryString *object = (struct lsa_BinaryString *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_lsa_BinaryString);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_lsa_BinaryString_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct lsa_BinaryString *object = (struct lsa_BinaryString *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_BinaryString);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_BinaryString);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_lsa_BinaryString_ndr_print(PyObject *py_obj)
{
	struct lsa_BinaryString *object = (struct lsa_BinaryString *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_lsa_BinaryString, "lsa_BinaryString", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_lsa_BinaryString_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_lsa_BinaryString_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_lsa_BinaryString_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_lsa_BinaryString_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_BinaryString_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.BinaryString",
	.tp_getset = py_lsa_BinaryString_getsetters,
	.tp_methods = py_lsa_BinaryString_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_BinaryString_new,
};


static PyObject *py_lsa_LUID_get_low(PyObject *obj, void *closure)
{
	struct lsa_LUID *object = (struct lsa_LUID *)pytalloc_get_ptr(obj);
	PyObject *py_low;
	py_low = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->low);
	return py_low;
}

static int py_lsa_LUID_set_low(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LUID *object = (struct lsa_LUID *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->low");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->low));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->low = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->low = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LUID_get_high(PyObject *obj, void *closure)
{
	struct lsa_LUID *object = (struct lsa_LUID *)pytalloc_get_ptr(obj);
	PyObject *py_high;
	py_high = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->high);
	return py_high;
}

static int py_lsa_LUID_set_high(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LUID *object = (struct lsa_LUID *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->high");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->high));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->high = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->high = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_LUID_getsetters[] = {
	{
		.name = discard_const_p(char, "low"),
		.get = py_lsa_LUID_get_low,
		.set = py_lsa_LUID_set_low,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "high"),
		.get = py_lsa_LUID_get_high,
		.set = py_lsa_LUID_set_high,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_LUID_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_LUID, type);
}


static PyTypeObject lsa_LUID_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.LUID",
	.tp_getset = py_lsa_LUID_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_LUID_new,
};


static PyObject *py_lsa_PrivEntry_get_name(PyObject *obj, void *closure)
{
	struct lsa_PrivEntry *object = (struct lsa_PrivEntry *)pytalloc_get_ptr(obj);
	PyObject *py_name;
	py_name = pytalloc_reference_ex(&lsa_StringLarge_Type, pytalloc_get_mem_ctx(obj), &object->name);
	return py_name;
}

static int py_lsa_PrivEntry_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_PrivEntry *object = (struct lsa_PrivEntry *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->name");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_StringLarge_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->name = *(struct lsa_StringLarge *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_PrivEntry_get_luid(PyObject *obj, void *closure)
{
	struct lsa_PrivEntry *object = (struct lsa_PrivEntry *)pytalloc_get_ptr(obj);
	PyObject *py_luid;
	py_luid = pytalloc_reference_ex(&lsa_LUID_Type, pytalloc_get_mem_ctx(obj), &object->luid);
	return py_luid;
}

static int py_lsa_PrivEntry_set_luid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_PrivEntry *object = (struct lsa_PrivEntry *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->luid");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_LUID_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->luid = *(struct lsa_LUID *)pytalloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_lsa_PrivEntry_getsetters[] = {
	{
		.name = discard_const_p(char, "name"),
		.get = py_lsa_PrivEntry_get_name,
		.set = py_lsa_PrivEntry_set_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_StringLarge")
	},
	{
		.name = discard_const_p(char, "luid"),
		.get = py_lsa_PrivEntry_get_luid,
		.set = py_lsa_PrivEntry_set_luid,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_LUID")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_PrivEntry_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_PrivEntry, type);
}


static PyTypeObject lsa_PrivEntry_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.PrivEntry",
	.tp_getset = py_lsa_PrivEntry_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_PrivEntry_new,
};


static PyObject *py_lsa_PrivArray_get_count(PyObject *obj, void *closure)
{
	struct lsa_PrivArray *object = (struct lsa_PrivArray *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->count);
	return py_count;
}

static int py_lsa_PrivArray_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_PrivArray *object = (struct lsa_PrivArray *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_PrivArray_get_privs(PyObject *obj, void *closure)
{
	struct lsa_PrivArray *object = (struct lsa_PrivArray *)pytalloc_get_ptr(obj);
	PyObject *py_privs;
	if (object->privs == NULL) {
		py_privs = Py_None;
		Py_INCREF(py_privs);
	} else {
		py_privs = PyList_New(object->count);
		if (py_privs == NULL) {
			return NULL;
		}
		{
			int privs_cntr_1;
			for (privs_cntr_1 = 0; privs_cntr_1 < (object->count); privs_cntr_1++) {
				PyObject *py_privs_1;
				py_privs_1 = pytalloc_reference_ex(&lsa_PrivEntry_Type, object->privs, &object->privs[privs_cntr_1]);
				PyList_SetItem(py_privs, privs_cntr_1, py_privs_1);
			}
		}
	}
	return py_privs;
}

static int py_lsa_PrivArray_set_privs(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_PrivArray *object = (struct lsa_PrivArray *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->privs));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->privs");
		return -1;
	}
	if (value == Py_None) {
		object->privs = NULL;
	} else {
		object->privs = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int privs_cntr_1;
			object->privs = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->privs, PyList_GET_SIZE(value));
			if (!object->privs) { return -1;; }
			talloc_set_name_const(object->privs, "ARRAY: object->privs");
			for (privs_cntr_1 = 0; privs_cntr_1 < PyList_GET_SIZE(value); privs_cntr_1++) {
				if (PyList_GET_ITEM(value, privs_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->privs[privs_cntr_1]");
					return -1;
				}
				PY_CHECK_TYPE(&lsa_PrivEntry_Type, PyList_GET_ITEM(value, privs_cntr_1), return -1;);
				if (talloc_reference(object->privs, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, privs_cntr_1))) == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				object->privs[privs_cntr_1] = *(struct lsa_PrivEntry *)pytalloc_get_ptr(PyList_GET_ITEM(value, privs_cntr_1));
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_PrivArray_getsetters[] = {
	{
		.name = discard_const_p(char, "count"),
		.get = py_lsa_PrivArray_get_count,
		.set = py_lsa_PrivArray_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "privs"),
		.get = py_lsa_PrivArray_get_privs,
		.set = py_lsa_PrivArray_set_privs,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_PrivEntry")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_PrivArray_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_PrivArray, type);
}


static PyTypeObject lsa_PrivArray_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.PrivArray",
	.tp_getset = py_lsa_PrivArray_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_PrivArray_new,
};


static PyObject *py_lsa_QosInfo_get_len(PyObject *obj, void *closure)
{
	struct lsa_QosInfo *object = (struct lsa_QosInfo *)pytalloc_get_ptr(obj);
	PyObject *py_len;
	py_len = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->len);
	return py_len;
}

static int py_lsa_QosInfo_set_len(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QosInfo *object = (struct lsa_QosInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->len");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->len));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->len = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->len = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_QosInfo_get_impersonation_level(PyObject *obj, void *closure)
{
	struct lsa_QosInfo *object = (struct lsa_QosInfo *)pytalloc_get_ptr(obj);
	PyObject *py_impersonation_level;
	py_impersonation_level = PyInt_FromLong((uint16_t)object->impersonation_level);
	return py_impersonation_level;
}

static int py_lsa_QosInfo_set_impersonation_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QosInfo *object = (struct lsa_QosInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->impersonation_level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->impersonation_level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->impersonation_level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->impersonation_level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_QosInfo_get_context_mode(PyObject *obj, void *closure)
{
	struct lsa_QosInfo *object = (struct lsa_QosInfo *)pytalloc_get_ptr(obj);
	PyObject *py_context_mode;
	py_context_mode = PyInt_FromLong((uint16_t)object->context_mode);
	return py_context_mode;
}

static int py_lsa_QosInfo_set_context_mode(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QosInfo *object = (struct lsa_QosInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->context_mode");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->context_mode));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->context_mode = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->context_mode = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_QosInfo_get_effective_only(PyObject *obj, void *closure)
{
	struct lsa_QosInfo *object = (struct lsa_QosInfo *)pytalloc_get_ptr(obj);
	PyObject *py_effective_only;
	py_effective_only = PyInt_FromLong((uint16_t)object->effective_only);
	return py_effective_only;
}

static int py_lsa_QosInfo_set_effective_only(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QosInfo *object = (struct lsa_QosInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->effective_only");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->effective_only));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->effective_only = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->effective_only = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_QosInfo_getsetters[] = {
	{
		.name = discard_const_p(char, "len"),
		.get = py_lsa_QosInfo_get_len,
		.set = py_lsa_QosInfo_set_len,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint3264")
	},
	{
		.name = discard_const_p(char, "impersonation_level"),
		.get = py_lsa_QosInfo_get_impersonation_level,
		.set = py_lsa_QosInfo_set_impersonation_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "context_mode"),
		.get = py_lsa_QosInfo_get_context_mode,
		.set = py_lsa_QosInfo_set_context_mode,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{
		.name = discard_const_p(char, "effective_only"),
		.get = py_lsa_QosInfo_get_effective_only,
		.set = py_lsa_QosInfo_set_effective_only,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_QosInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_QosInfo, type);
}


static PyTypeObject lsa_QosInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.QosInfo",
	.tp_getset = py_lsa_QosInfo_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_QosInfo_new,
};


static PyObject *py_lsa_ObjectAttribute_get_len(PyObject *obj, void *closure)
{
	struct lsa_ObjectAttribute *object = (struct lsa_ObjectAttribute *)pytalloc_get_ptr(obj);
	PyObject *py_len;
	py_len = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->len);
	return py_len;
}

static int py_lsa_ObjectAttribute_set_len(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ObjectAttribute *object = (struct lsa_ObjectAttribute *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->len");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->len));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->len = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->len = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_ObjectAttribute_get_root_dir(PyObject *obj, void *closure)
{
	struct lsa_ObjectAttribute *object = (struct lsa_ObjectAttribute *)pytalloc_get_ptr(obj);
	PyObject *py_root_dir;
	if (object->root_dir == NULL) {
		py_root_dir = Py_None;
		Py_INCREF(py_root_dir);
	} else {
		py_root_dir = PyInt_FromLong((uint16_t)*object->root_dir);
	}
	return py_root_dir;
}

static int py_lsa_ObjectAttribute_set_root_dir(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ObjectAttribute *object = (struct lsa_ObjectAttribute *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->root_dir));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->root_dir");
		return -1;
	}
	if (value == Py_None) {
		object->root_dir = NULL;
	} else {
		object->root_dir = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->root_dir);
		if (object->root_dir == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		{
			const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->root_dir));
			if (PyLong_Check(value)) {
				unsigned long long test_var;
				test_var = PyLong_AsUnsignedLongLong(value);
				if (PyErr_Occurred() != NULL) {
					return -1;
				}
				if (test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return -1;
				}
				*object->root_dir = test_var;
			} else if (PyInt_Check(value)) {
				long test_var;
				test_var = PyInt_AsLong(value);
				if (test_var < 0 || test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return -1;
				}
				*object->root_dir = test_var;
			} else {
				PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name);
				return -1;
			}
		}
	}
	return 0;
}

static PyObject *py_lsa_ObjectAttribute_get_object_name(PyObject *obj, void *closure)
{
	struct lsa_ObjectAttribute *object = (struct lsa_ObjectAttribute *)pytalloc_get_ptr(obj);
	PyObject *py_object_name;
	if (object->object_name == NULL) {
		py_object_name = Py_None;
		Py_INCREF(py_object_name);
	} else {
		if (object->object_name == NULL) {
			py_object_name = Py_None;
			Py_INCREF(py_object_name);
		} else {
			py_object_name = PyUnicode_Decode(object->object_name, strlen(object->object_name), "utf-8", "ignore");
		}
	}
	return py_object_name;
}

static int py_lsa_ObjectAttribute_set_object_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ObjectAttribute *object = (struct lsa_ObjectAttribute *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->object_name");
		return -1;
	}
	if (value == Py_None) {
		object->object_name = NULL;
	} else {
		object->object_name = NULL;
		{
			const char *test_str;
			const char *talloc_str;
			PyObject *unicode = NULL;
			if (PyUnicode_Check(value)) {
				unicode = PyUnicode_AsEncodedString(value, "utf-8", "ignore");
				if (unicode == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				test_str = PyBytes_AS_STRING(unicode);
			} else if (PyBytes_Check(value)) {
				test_str = PyBytes_AS_STRING(value);
			} else {
				PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
				return -1;
			}
			talloc_str = talloc_strdup(pytalloc_get_mem_ctx(py_obj), test_str);
			if (unicode != NULL) {
				Py_DECREF(unicode);
			}
			if (talloc_str == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->object_name = talloc_str;
		}
	}
	return 0;
}

static PyObject *py_lsa_ObjectAttribute_get_attributes(PyObject *obj, void *closure)
{
	struct lsa_ObjectAttribute *object = (struct lsa_ObjectAttribute *)pytalloc_get_ptr(obj);
	PyObject *py_attributes;
	py_attributes = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->attributes);
	return py_attributes;
}

static int py_lsa_ObjectAttribute_set_attributes(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ObjectAttribute *object = (struct lsa_ObjectAttribute *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->attributes");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->attributes));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->attributes = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->attributes = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_ObjectAttribute_get_sec_desc(PyObject *obj, void *closure)
{
	struct lsa_ObjectAttribute *object = (struct lsa_ObjectAttribute *)pytalloc_get_ptr(obj);
	PyObject *py_sec_desc;
	if (object->sec_desc == NULL) {
		py_sec_desc = Py_None;
		Py_INCREF(py_sec_desc);
	} else {
		py_sec_desc = pytalloc_reference_ex(security_descriptor_Type, object->sec_desc, object->sec_desc);
	}
	return py_sec_desc;
}

static int py_lsa_ObjectAttribute_set_sec_desc(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ObjectAttribute *object = (struct lsa_ObjectAttribute *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->sec_desc));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sec_desc");
		return -1;
	}
	if (value == Py_None) {
		object->sec_desc = NULL;
	} else {
		object->sec_desc = NULL;
		PY_CHECK_TYPE(security_descriptor_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->sec_desc = (struct security_descriptor *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_ObjectAttribute_get_sec_qos(PyObject *obj, void *closure)
{
	struct lsa_ObjectAttribute *object = (struct lsa_ObjectAttribute *)pytalloc_get_ptr(obj);
	PyObject *py_sec_qos;
	if (object->sec_qos == NULL) {
		py_sec_qos = Py_None;
		Py_INCREF(py_sec_qos);
	} else {
		py_sec_qos = pytalloc_reference_ex(&lsa_QosInfo_Type, object->sec_qos, object->sec_qos);
	}
	return py_sec_qos;
}

static int py_lsa_ObjectAttribute_set_sec_qos(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ObjectAttribute *object = (struct lsa_ObjectAttribute *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->sec_qos));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sec_qos");
		return -1;
	}
	if (value == Py_None) {
		object->sec_qos = NULL;
	} else {
		object->sec_qos = NULL;
		PY_CHECK_TYPE(&lsa_QosInfo_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->sec_qos = (struct lsa_QosInfo *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyGetSetDef py_lsa_ObjectAttribute_getsetters[] = {
	{
		.name = discard_const_p(char, "len"),
		.get = py_lsa_ObjectAttribute_get_len,
		.set = py_lsa_ObjectAttribute_set_len,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint3264")
	},
	{
		.name = discard_const_p(char, "root_dir"),
		.get = py_lsa_ObjectAttribute_get_root_dir,
		.set = py_lsa_ObjectAttribute_set_root_dir,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{
		.name = discard_const_p(char, "object_name"),
		.get = py_lsa_ObjectAttribute_get_object_name,
		.set = py_lsa_ObjectAttribute_set_object_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "attributes"),
		.get = py_lsa_ObjectAttribute_get_attributes,
		.set = py_lsa_ObjectAttribute_set_attributes,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "sec_desc"),
		.get = py_lsa_ObjectAttribute_get_sec_desc,
		.set = py_lsa_ObjectAttribute_set_sec_desc,
		.doc = discard_const_p(char, "PIDL-generated element of base type security_descriptor")
	},
	{
		.name = discard_const_p(char, "sec_qos"),
		.get = py_lsa_ObjectAttribute_get_sec_qos,
		.set = py_lsa_ObjectAttribute_set_sec_qos,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_QosInfo")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_ObjectAttribute_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_ObjectAttribute, type);
}


static PyTypeObject lsa_ObjectAttribute_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.ObjectAttribute",
	.tp_getset = py_lsa_ObjectAttribute_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_ObjectAttribute_new,
};


static PyObject *py_lsa_AuditLogInfo_get_percent_full(PyObject *obj, void *closure)
{
	struct lsa_AuditLogInfo *object = (struct lsa_AuditLogInfo *)pytalloc_get_ptr(obj);
	PyObject *py_percent_full;
	py_percent_full = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->percent_full);
	return py_percent_full;
}

static int py_lsa_AuditLogInfo_set_percent_full(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AuditLogInfo *object = (struct lsa_AuditLogInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->percent_full");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->percent_full));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->percent_full = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->percent_full = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_AuditLogInfo_get_maximum_log_size(PyObject *obj, void *closure)
{
	struct lsa_AuditLogInfo *object = (struct lsa_AuditLogInfo *)pytalloc_get_ptr(obj);
	PyObject *py_maximum_log_size;
	py_maximum_log_size = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->maximum_log_size);
	return py_maximum_log_size;
}

static int py_lsa_AuditLogInfo_set_maximum_log_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AuditLogInfo *object = (struct lsa_AuditLogInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->maximum_log_size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->maximum_log_size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->maximum_log_size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->maximum_log_size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_AuditLogInfo_get_retention_time(PyObject *obj, void *closure)
{
	struct lsa_AuditLogInfo *object = (struct lsa_AuditLogInfo *)pytalloc_get_ptr(obj);
	PyObject *py_retention_time;
	py_retention_time = ndr_PyLong_FromUnsignedLongLong(object->retention_time);
	return py_retention_time;
}

static int py_lsa_AuditLogInfo_set_retention_time(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AuditLogInfo *object = (struct lsa_AuditLogInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->retention_time");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->retention_time));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->retention_time = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->retention_time = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_AuditLogInfo_get_shutdown_in_progress(PyObject *obj, void *closure)
{
	struct lsa_AuditLogInfo *object = (struct lsa_AuditLogInfo *)pytalloc_get_ptr(obj);
	PyObject *py_shutdown_in_progress;
	py_shutdown_in_progress = PyInt_FromLong((uint16_t)object->shutdown_in_progress);
	return py_shutdown_in_progress;
}

static int py_lsa_AuditLogInfo_set_shutdown_in_progress(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AuditLogInfo *object = (struct lsa_AuditLogInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->shutdown_in_progress");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->shutdown_in_progress));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->shutdown_in_progress = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->shutdown_in_progress = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_AuditLogInfo_get_time_to_shutdown(PyObject *obj, void *closure)
{
	struct lsa_AuditLogInfo *object = (struct lsa_AuditLogInfo *)pytalloc_get_ptr(obj);
	PyObject *py_time_to_shutdown;
	py_time_to_shutdown = ndr_PyLong_FromUnsignedLongLong(object->time_to_shutdown);
	return py_time_to_shutdown;
}

static int py_lsa_AuditLogInfo_set_time_to_shutdown(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AuditLogInfo *object = (struct lsa_AuditLogInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->time_to_shutdown");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->time_to_shutdown));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->time_to_shutdown = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->time_to_shutdown = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_AuditLogInfo_get_next_audit_record(PyObject *obj, void *closure)
{
	struct lsa_AuditLogInfo *object = (struct lsa_AuditLogInfo *)pytalloc_get_ptr(obj);
	PyObject *py_next_audit_record;
	py_next_audit_record = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->next_audit_record);
	return py_next_audit_record;
}

static int py_lsa_AuditLogInfo_set_next_audit_record(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AuditLogInfo *object = (struct lsa_AuditLogInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->next_audit_record");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->next_audit_record));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->next_audit_record = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->next_audit_record = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_AuditLogInfo_getsetters[] = {
	{
		.name = discard_const_p(char, "percent_full"),
		.get = py_lsa_AuditLogInfo_get_percent_full,
		.set = py_lsa_AuditLogInfo_set_percent_full,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "maximum_log_size"),
		.get = py_lsa_AuditLogInfo_get_maximum_log_size,
		.set = py_lsa_AuditLogInfo_set_maximum_log_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "retention_time"),
		.get = py_lsa_AuditLogInfo_get_retention_time,
		.set = py_lsa_AuditLogInfo_set_retention_time,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{
		.name = discard_const_p(char, "shutdown_in_progress"),
		.get = py_lsa_AuditLogInfo_get_shutdown_in_progress,
		.set = py_lsa_AuditLogInfo_set_shutdown_in_progress,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{
		.name = discard_const_p(char, "time_to_shutdown"),
		.get = py_lsa_AuditLogInfo_get_time_to_shutdown,
		.set = py_lsa_AuditLogInfo_set_time_to_shutdown,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{
		.name = discard_const_p(char, "next_audit_record"),
		.get = py_lsa_AuditLogInfo_get_next_audit_record,
		.set = py_lsa_AuditLogInfo_set_next_audit_record,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_AuditLogInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_AuditLogInfo, type);
}


static PyTypeObject lsa_AuditLogInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.AuditLogInfo",
	.tp_getset = py_lsa_AuditLogInfo_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_AuditLogInfo_new,
};


static PyObject *py_lsa_AuditEventsInfo_get_auditing_mode(PyObject *obj, void *closure)
{
	struct lsa_AuditEventsInfo *object = (struct lsa_AuditEventsInfo *)pytalloc_get_ptr(obj);
	PyObject *py_auditing_mode;
	py_auditing_mode = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->auditing_mode);
	return py_auditing_mode;
}

static int py_lsa_AuditEventsInfo_set_auditing_mode(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AuditEventsInfo *object = (struct lsa_AuditEventsInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->auditing_mode");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->auditing_mode));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->auditing_mode = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->auditing_mode = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_AuditEventsInfo_get_settings(PyObject *obj, void *closure)
{
	struct lsa_AuditEventsInfo *object = (struct lsa_AuditEventsInfo *)pytalloc_get_ptr(obj);
	PyObject *py_settings;
	if (object->settings == NULL) {
		py_settings = Py_None;
		Py_INCREF(py_settings);
	} else {
		py_settings = PyList_New(object->count);
		if (py_settings == NULL) {
			return NULL;
		}
		{
			int settings_cntr_1;
			for (settings_cntr_1 = 0; settings_cntr_1 < (object->count); settings_cntr_1++) {
				PyObject *py_settings_1;
				py_settings_1 = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->settings[settings_cntr_1]);
				PyList_SetItem(py_settings, settings_cntr_1, py_settings_1);
			}
		}
	}
	return py_settings;
}

static int py_lsa_AuditEventsInfo_set_settings(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AuditEventsInfo *object = (struct lsa_AuditEventsInfo *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->settings));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->settings");
		return -1;
	}
	if (value == Py_None) {
		object->settings = NULL;
	} else {
		object->settings = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int settings_cntr_1;
			object->settings = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->settings, PyList_GET_SIZE(value));
			if (!object->settings) { return -1;; }
			talloc_set_name_const(object->settings, "ARRAY: object->settings");
			for (settings_cntr_1 = 0; settings_cntr_1 < PyList_GET_SIZE(value); settings_cntr_1++) {
				if (PyList_GET_ITEM(value, settings_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->settings[settings_cntr_1]");
					return -1;
				}
				{
					const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->settings[settings_cntr_1]));
					if (PyLong_Check(PyList_GET_ITEM(value, settings_cntr_1))) {
						unsigned long long test_var;
						test_var = PyLong_AsUnsignedLongLong(PyList_GET_ITEM(value, settings_cntr_1));
						if (PyErr_Occurred() != NULL) {
							return -1;
						}
						if (test_var > uint_max) {
							PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
							  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
							return -1;
						}
						object->settings[settings_cntr_1] = test_var;
					} else if (PyInt_Check(PyList_GET_ITEM(value, settings_cntr_1))) {
						long test_var;
						test_var = PyInt_AsLong(PyList_GET_ITEM(value, settings_cntr_1));
						if (test_var < 0 || test_var > uint_max) {
							PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
							  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
							return -1;
						}
						object->settings[settings_cntr_1] = test_var;
					} else {
						PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
						  PyInt_Type.tp_name, PyLong_Type.tp_name);
						return -1;
					}
				}
			}
		}
	}
	return 0;
}

static PyObject *py_lsa_AuditEventsInfo_get_count(PyObject *obj, void *closure)
{
	struct lsa_AuditEventsInfo *object = (struct lsa_AuditEventsInfo *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->count);
	return py_count;
}

static int py_lsa_AuditEventsInfo_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AuditEventsInfo *object = (struct lsa_AuditEventsInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_AuditEventsInfo_getsetters[] = {
	{
		.name = discard_const_p(char, "auditing_mode"),
		.get = py_lsa_AuditEventsInfo_get_auditing_mode,
		.set = py_lsa_AuditEventsInfo_set_auditing_mode,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "settings"),
		.get = py_lsa_AuditEventsInfo_get_settings,
		.set = py_lsa_AuditEventsInfo_set_settings,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_PolicyAuditPolicy")
	},
	{
		.name = discard_const_p(char, "count"),
		.get = py_lsa_AuditEventsInfo_get_count,
		.set = py_lsa_AuditEventsInfo_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_AuditEventsInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_AuditEventsInfo, type);
}


static PyTypeObject lsa_AuditEventsInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.AuditEventsInfo",
	.tp_getset = py_lsa_AuditEventsInfo_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_AuditEventsInfo_new,
};


static PyObject *py_lsa_DomainInfo_get_name(PyObject *obj, void *closure)
{
	struct lsa_DomainInfo *object = (struct lsa_DomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_name;
	py_name = pytalloc_reference_ex(&lsa_StringLarge_Type, pytalloc_get_mem_ctx(obj), &object->name);
	return py_name;
}

static int py_lsa_DomainInfo_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DomainInfo *object = (struct lsa_DomainInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->name");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_StringLarge_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->name = *(struct lsa_StringLarge *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_DomainInfo_get_sid(PyObject *obj, void *closure)
{
	struct lsa_DomainInfo *object = (struct lsa_DomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_sid;
	if (object->sid == NULL) {
		py_sid = Py_None;
		Py_INCREF(py_sid);
	} else {
		py_sid = pytalloc_reference_ex(dom_sid_Type, object->sid, object->sid);
	}
	return py_sid;
}

static int py_lsa_DomainInfo_set_sid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DomainInfo *object = (struct lsa_DomainInfo *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->sid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sid");
		return -1;
	}
	if (value == Py_None) {
		object->sid = NULL;
	} else {
		object->sid = NULL;
		PY_CHECK_TYPE(dom_sid_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->sid = (struct dom_sid *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyGetSetDef py_lsa_DomainInfo_getsetters[] = {
	{
		.name = discard_const_p(char, "name"),
		.get = py_lsa_DomainInfo_get_name,
		.set = py_lsa_DomainInfo_set_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_StringLarge")
	},
	{
		.name = discard_const_p(char, "sid"),
		.get = py_lsa_DomainInfo_get_sid,
		.set = py_lsa_DomainInfo_set_sid,
		.doc = discard_const_p(char, "PIDL-generated element of base type dom_sid2")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_DomainInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_DomainInfo, type);
}


static PyTypeObject lsa_DomainInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.DomainInfo",
	.tp_getset = py_lsa_DomainInfo_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_DomainInfo_new,
};


static PyObject *py_lsa_PDAccountInfo_get_name(PyObject *obj, void *closure)
{
	struct lsa_PDAccountInfo *object = (struct lsa_PDAccountInfo *)pytalloc_get_ptr(obj);
	PyObject *py_name;
	py_name = pytalloc_reference_ex(&lsa_String_Type, pytalloc_get_mem_ctx(obj), &object->name);
	return py_name;
}

static int py_lsa_PDAccountInfo_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_PDAccountInfo *object = (struct lsa_PDAccountInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->name");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->name = *(struct lsa_String *)pytalloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_lsa_PDAccountInfo_getsetters[] = {
	{
		.name = discard_const_p(char, "name"),
		.get = py_lsa_PDAccountInfo_get_name,
		.set = py_lsa_PDAccountInfo_set_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_PDAccountInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_PDAccountInfo, type);
}


static PyTypeObject lsa_PDAccountInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.PDAccountInfo",
	.tp_getset = py_lsa_PDAccountInfo_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_PDAccountInfo_new,
};


static PyObject *py_lsa_ServerRole_get_role(PyObject *obj, void *closure)
{
	struct lsa_ServerRole *object = (struct lsa_ServerRole *)pytalloc_get_ptr(obj);
	PyObject *py_role;
	py_role = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->role);
	return py_role;
}

static int py_lsa_ServerRole_set_role(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ServerRole *object = (struct lsa_ServerRole *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->role");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->role));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->role = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->role = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_ServerRole_getsetters[] = {
	{
		.name = discard_const_p(char, "role"),
		.get = py_lsa_ServerRole_get_role,
		.set = py_lsa_ServerRole_set_role,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_Role")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_ServerRole_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_ServerRole, type);
}


static PyTypeObject lsa_ServerRole_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.ServerRole",
	.tp_getset = py_lsa_ServerRole_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_ServerRole_new,
};


static PyObject *py_lsa_ReplicaSourceInfo_get_source(PyObject *obj, void *closure)
{
	struct lsa_ReplicaSourceInfo *object = (struct lsa_ReplicaSourceInfo *)pytalloc_get_ptr(obj);
	PyObject *py_source;
	py_source = pytalloc_reference_ex(&lsa_String_Type, pytalloc_get_mem_ctx(obj), &object->source);
	return py_source;
}

static int py_lsa_ReplicaSourceInfo_set_source(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ReplicaSourceInfo *object = (struct lsa_ReplicaSourceInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->source");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->source = *(struct lsa_String *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_ReplicaSourceInfo_get_account(PyObject *obj, void *closure)
{
	struct lsa_ReplicaSourceInfo *object = (struct lsa_ReplicaSourceInfo *)pytalloc_get_ptr(obj);
	PyObject *py_account;
	py_account = pytalloc_reference_ex(&lsa_String_Type, pytalloc_get_mem_ctx(obj), &object->account);
	return py_account;
}

static int py_lsa_ReplicaSourceInfo_set_account(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ReplicaSourceInfo *object = (struct lsa_ReplicaSourceInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->account");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->account = *(struct lsa_String *)pytalloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_lsa_ReplicaSourceInfo_getsetters[] = {
	{
		.name = discard_const_p(char, "source"),
		.get = py_lsa_ReplicaSourceInfo_get_source,
		.set = py_lsa_ReplicaSourceInfo_set_source,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "account"),
		.get = py_lsa_ReplicaSourceInfo_get_account,
		.set = py_lsa_ReplicaSourceInfo_set_account,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_ReplicaSourceInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_ReplicaSourceInfo, type);
}


static PyTypeObject lsa_ReplicaSourceInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.ReplicaSourceInfo",
	.tp_getset = py_lsa_ReplicaSourceInfo_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_ReplicaSourceInfo_new,
};


static PyObject *py_lsa_DefaultQuotaInfo_get_paged_pool(PyObject *obj, void *closure)
{
	struct lsa_DefaultQuotaInfo *object = (struct lsa_DefaultQuotaInfo *)pytalloc_get_ptr(obj);
	PyObject *py_paged_pool;
	py_paged_pool = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->paged_pool);
	return py_paged_pool;
}

static int py_lsa_DefaultQuotaInfo_set_paged_pool(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DefaultQuotaInfo *object = (struct lsa_DefaultQuotaInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->paged_pool");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->paged_pool));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->paged_pool = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->paged_pool = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_DefaultQuotaInfo_get_non_paged_pool(PyObject *obj, void *closure)
{
	struct lsa_DefaultQuotaInfo *object = (struct lsa_DefaultQuotaInfo *)pytalloc_get_ptr(obj);
	PyObject *py_non_paged_pool;
	py_non_paged_pool = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->non_paged_pool);
	return py_non_paged_pool;
}

static int py_lsa_DefaultQuotaInfo_set_non_paged_pool(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DefaultQuotaInfo *object = (struct lsa_DefaultQuotaInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->non_paged_pool");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->non_paged_pool));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->non_paged_pool = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->non_paged_pool = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_DefaultQuotaInfo_get_min_wss(PyObject *obj, void *closure)
{
	struct lsa_DefaultQuotaInfo *object = (struct lsa_DefaultQuotaInfo *)pytalloc_get_ptr(obj);
	PyObject *py_min_wss;
	py_min_wss = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->min_wss);
	return py_min_wss;
}

static int py_lsa_DefaultQuotaInfo_set_min_wss(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DefaultQuotaInfo *object = (struct lsa_DefaultQuotaInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->min_wss");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->min_wss));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->min_wss = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->min_wss = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_DefaultQuotaInfo_get_max_wss(PyObject *obj, void *closure)
{
	struct lsa_DefaultQuotaInfo *object = (struct lsa_DefaultQuotaInfo *)pytalloc_get_ptr(obj);
	PyObject *py_max_wss;
	py_max_wss = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->max_wss);
	return py_max_wss;
}

static int py_lsa_DefaultQuotaInfo_set_max_wss(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DefaultQuotaInfo *object = (struct lsa_DefaultQuotaInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->max_wss");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->max_wss));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->max_wss = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->max_wss = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_DefaultQuotaInfo_get_pagefile(PyObject *obj, void *closure)
{
	struct lsa_DefaultQuotaInfo *object = (struct lsa_DefaultQuotaInfo *)pytalloc_get_ptr(obj);
	PyObject *py_pagefile;
	py_pagefile = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->pagefile);
	return py_pagefile;
}

static int py_lsa_DefaultQuotaInfo_set_pagefile(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DefaultQuotaInfo *object = (struct lsa_DefaultQuotaInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->pagefile");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->pagefile));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->pagefile = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->pagefile = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_DefaultQuotaInfo_get_unknown(PyObject *obj, void *closure)
{
	struct lsa_DefaultQuotaInfo *object = (struct lsa_DefaultQuotaInfo *)pytalloc_get_ptr(obj);
	PyObject *py_unknown;
	py_unknown = ndr_PyLong_FromUnsignedLongLong(object->unknown);
	return py_unknown;
}

static int py_lsa_DefaultQuotaInfo_set_unknown(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DefaultQuotaInfo *object = (struct lsa_DefaultQuotaInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->unknown");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->unknown));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->unknown = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->unknown = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_DefaultQuotaInfo_getsetters[] = {
	{
		.name = discard_const_p(char, "paged_pool"),
		.get = py_lsa_DefaultQuotaInfo_get_paged_pool,
		.set = py_lsa_DefaultQuotaInfo_set_paged_pool,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "non_paged_pool"),
		.get = py_lsa_DefaultQuotaInfo_get_non_paged_pool,
		.set = py_lsa_DefaultQuotaInfo_set_non_paged_pool,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "min_wss"),
		.get = py_lsa_DefaultQuotaInfo_get_min_wss,
		.set = py_lsa_DefaultQuotaInfo_set_min_wss,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "max_wss"),
		.get = py_lsa_DefaultQuotaInfo_get_max_wss,
		.set = py_lsa_DefaultQuotaInfo_set_max_wss,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "pagefile"),
		.get = py_lsa_DefaultQuotaInfo_get_pagefile,
		.set = py_lsa_DefaultQuotaInfo_set_pagefile,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "unknown"),
		.get = py_lsa_DefaultQuotaInfo_get_unknown,
		.set = py_lsa_DefaultQuotaInfo_set_unknown,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_DefaultQuotaInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_DefaultQuotaInfo, type);
}


static PyTypeObject lsa_DefaultQuotaInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.DefaultQuotaInfo",
	.tp_getset = py_lsa_DefaultQuotaInfo_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_DefaultQuotaInfo_new,
};


static PyObject *py_lsa_ModificationInfo_get_modified_id(PyObject *obj, void *closure)
{
	struct lsa_ModificationInfo *object = (struct lsa_ModificationInfo *)pytalloc_get_ptr(obj);
	PyObject *py_modified_id;
	py_modified_id = ndr_PyLong_FromUnsignedLongLong(object->modified_id);
	return py_modified_id;
}

static int py_lsa_ModificationInfo_set_modified_id(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ModificationInfo *object = (struct lsa_ModificationInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->modified_id");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->modified_id));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->modified_id = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->modified_id = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_ModificationInfo_get_db_create_time(PyObject *obj, void *closure)
{
	struct lsa_ModificationInfo *object = (struct lsa_ModificationInfo *)pytalloc_get_ptr(obj);
	PyObject *py_db_create_time;
	py_db_create_time = ndr_PyLong_FromUnsignedLongLong(object->db_create_time);
	return py_db_create_time;
}

static int py_lsa_ModificationInfo_set_db_create_time(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ModificationInfo *object = (struct lsa_ModificationInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->db_create_time");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->db_create_time));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->db_create_time = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->db_create_time = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_ModificationInfo_getsetters[] = {
	{
		.name = discard_const_p(char, "modified_id"),
		.get = py_lsa_ModificationInfo_get_modified_id,
		.set = py_lsa_ModificationInfo_set_modified_id,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{
		.name = discard_const_p(char, "db_create_time"),
		.get = py_lsa_ModificationInfo_get_db_create_time,
		.set = py_lsa_ModificationInfo_set_db_create_time,
		.doc = discard_const_p(char, "PIDL-generated element of base type NTTIME_hyper")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_ModificationInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_ModificationInfo, type);
}


static PyTypeObject lsa_ModificationInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.ModificationInfo",
	.tp_getset = py_lsa_ModificationInfo_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_ModificationInfo_new,
};


static PyObject *py_lsa_AuditFullSetInfo_get_shutdown_on_full(PyObject *obj, void *closure)
{
	struct lsa_AuditFullSetInfo *object = (struct lsa_AuditFullSetInfo *)pytalloc_get_ptr(obj);
	PyObject *py_shutdown_on_full;
	py_shutdown_on_full = PyInt_FromLong((uint16_t)object->shutdown_on_full);
	return py_shutdown_on_full;
}

static int py_lsa_AuditFullSetInfo_set_shutdown_on_full(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AuditFullSetInfo *object = (struct lsa_AuditFullSetInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->shutdown_on_full");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->shutdown_on_full));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->shutdown_on_full = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->shutdown_on_full = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_AuditFullSetInfo_getsetters[] = {
	{
		.name = discard_const_p(char, "shutdown_on_full"),
		.get = py_lsa_AuditFullSetInfo_get_shutdown_on_full,
		.set = py_lsa_AuditFullSetInfo_set_shutdown_on_full,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_AuditFullSetInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_AuditFullSetInfo, type);
}


static PyTypeObject lsa_AuditFullSetInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.AuditFullSetInfo",
	.tp_getset = py_lsa_AuditFullSetInfo_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_AuditFullSetInfo_new,
};


static PyObject *py_lsa_AuditFullQueryInfo_get_shutdown_on_full(PyObject *obj, void *closure)
{
	struct lsa_AuditFullQueryInfo *object = (struct lsa_AuditFullQueryInfo *)pytalloc_get_ptr(obj);
	PyObject *py_shutdown_on_full;
	py_shutdown_on_full = PyInt_FromLong((uint16_t)object->shutdown_on_full);
	return py_shutdown_on_full;
}

static int py_lsa_AuditFullQueryInfo_set_shutdown_on_full(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AuditFullQueryInfo *object = (struct lsa_AuditFullQueryInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->shutdown_on_full");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->shutdown_on_full));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->shutdown_on_full = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->shutdown_on_full = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_AuditFullQueryInfo_get_log_is_full(PyObject *obj, void *closure)
{
	struct lsa_AuditFullQueryInfo *object = (struct lsa_AuditFullQueryInfo *)pytalloc_get_ptr(obj);
	PyObject *py_log_is_full;
	py_log_is_full = PyInt_FromLong((uint16_t)object->log_is_full);
	return py_log_is_full;
}

static int py_lsa_AuditFullQueryInfo_set_log_is_full(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AuditFullQueryInfo *object = (struct lsa_AuditFullQueryInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->log_is_full");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->log_is_full));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->log_is_full = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->log_is_full = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_AuditFullQueryInfo_getsetters[] = {
	{
		.name = discard_const_p(char, "shutdown_on_full"),
		.get = py_lsa_AuditFullQueryInfo_get_shutdown_on_full,
		.set = py_lsa_AuditFullQueryInfo_set_shutdown_on_full,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{
		.name = discard_const_p(char, "log_is_full"),
		.get = py_lsa_AuditFullQueryInfo_get_log_is_full,
		.set = py_lsa_AuditFullQueryInfo_set_log_is_full,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_AuditFullQueryInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_AuditFullQueryInfo, type);
}


static PyTypeObject lsa_AuditFullQueryInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.AuditFullQueryInfo",
	.tp_getset = py_lsa_AuditFullQueryInfo_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_AuditFullQueryInfo_new,
};


static PyObject *py_lsa_DnsDomainInfo_get_name(PyObject *obj, void *closure)
{
	struct lsa_DnsDomainInfo *object = (struct lsa_DnsDomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_name;
	py_name = pytalloc_reference_ex(&lsa_StringLarge_Type, pytalloc_get_mem_ctx(obj), &object->name);
	return py_name;
}

static int py_lsa_DnsDomainInfo_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DnsDomainInfo *object = (struct lsa_DnsDomainInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->name");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_StringLarge_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->name = *(struct lsa_StringLarge *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_DnsDomainInfo_get_dns_domain(PyObject *obj, void *closure)
{
	struct lsa_DnsDomainInfo *object = (struct lsa_DnsDomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_dns_domain;
	py_dns_domain = pytalloc_reference_ex(&lsa_StringLarge_Type, pytalloc_get_mem_ctx(obj), &object->dns_domain);
	return py_dns_domain;
}

static int py_lsa_DnsDomainInfo_set_dns_domain(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DnsDomainInfo *object = (struct lsa_DnsDomainInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->dns_domain");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_StringLarge_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->dns_domain = *(struct lsa_StringLarge *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_DnsDomainInfo_get_dns_forest(PyObject *obj, void *closure)
{
	struct lsa_DnsDomainInfo *object = (struct lsa_DnsDomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_dns_forest;
	py_dns_forest = pytalloc_reference_ex(&lsa_StringLarge_Type, pytalloc_get_mem_ctx(obj), &object->dns_forest);
	return py_dns_forest;
}

static int py_lsa_DnsDomainInfo_set_dns_forest(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DnsDomainInfo *object = (struct lsa_DnsDomainInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->dns_forest");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_StringLarge_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->dns_forest = *(struct lsa_StringLarge *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_DnsDomainInfo_get_domain_guid(PyObject *obj, void *closure)
{
	struct lsa_DnsDomainInfo *object = (struct lsa_DnsDomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_domain_guid;
	py_domain_guid = pytalloc_reference_ex(GUID_Type, pytalloc_get_mem_ctx(obj), &object->domain_guid);
	return py_domain_guid;
}

static int py_lsa_DnsDomainInfo_set_domain_guid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DnsDomainInfo *object = (struct lsa_DnsDomainInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->domain_guid");
		return -1;
	}
	PY_CHECK_TYPE(GUID_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->domain_guid = *(struct GUID *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_DnsDomainInfo_get_sid(PyObject *obj, void *closure)
{
	struct lsa_DnsDomainInfo *object = (struct lsa_DnsDomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_sid;
	if (object->sid == NULL) {
		py_sid = Py_None;
		Py_INCREF(py_sid);
	} else {
		py_sid = pytalloc_reference_ex(dom_sid_Type, object->sid, object->sid);
	}
	return py_sid;
}

static int py_lsa_DnsDomainInfo_set_sid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DnsDomainInfo *object = (struct lsa_DnsDomainInfo *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->sid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sid");
		return -1;
	}
	if (value == Py_None) {
		object->sid = NULL;
	} else {
		object->sid = NULL;
		PY_CHECK_TYPE(dom_sid_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->sid = (struct dom_sid *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyGetSetDef py_lsa_DnsDomainInfo_getsetters[] = {
	{
		.name = discard_const_p(char, "name"),
		.get = py_lsa_DnsDomainInfo_get_name,
		.set = py_lsa_DnsDomainInfo_set_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_StringLarge")
	},
	{
		.name = discard_const_p(char, "dns_domain"),
		.get = py_lsa_DnsDomainInfo_get_dns_domain,
		.set = py_lsa_DnsDomainInfo_set_dns_domain,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_StringLarge")
	},
	{
		.name = discard_const_p(char, "dns_forest"),
		.get = py_lsa_DnsDomainInfo_get_dns_forest,
		.set = py_lsa_DnsDomainInfo_set_dns_forest,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_StringLarge")
	},
	{
		.name = discard_const_p(char, "domain_guid"),
		.get = py_lsa_DnsDomainInfo_get_domain_guid,
		.set = py_lsa_DnsDomainInfo_set_domain_guid,
		.doc = discard_const_p(char, "PIDL-generated element of base type GUID")
	},
	{
		.name = discard_const_p(char, "sid"),
		.get = py_lsa_DnsDomainInfo_get_sid,
		.set = py_lsa_DnsDomainInfo_set_sid,
		.doc = discard_const_p(char, "PIDL-generated element of base type dom_sid2")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_DnsDomainInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_DnsDomainInfo, type);
}

static PyObject *py_lsa_DnsDomainInfo_ndr_pack(PyObject *py_obj)
{
	struct lsa_DnsDomainInfo *object = (struct lsa_DnsDomainInfo *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_lsa_DnsDomainInfo);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_lsa_DnsDomainInfo_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct lsa_DnsDomainInfo *object = (struct lsa_DnsDomainInfo *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_DnsDomainInfo);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_DnsDomainInfo);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_lsa_DnsDomainInfo_ndr_print(PyObject *py_obj)
{
	struct lsa_DnsDomainInfo *object = (struct lsa_DnsDomainInfo *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_lsa_DnsDomainInfo, "lsa_DnsDomainInfo", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_lsa_DnsDomainInfo_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_lsa_DnsDomainInfo_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_lsa_DnsDomainInfo_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_lsa_DnsDomainInfo_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_DnsDomainInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.DnsDomainInfo",
	.tp_getset = py_lsa_DnsDomainInfo_getsetters,
	.tp_methods = py_lsa_DnsDomainInfo_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_DnsDomainInfo_new,
};

static PyObject *py_import_lsa_PolicyInformation(TALLOC_CTX *mem_ctx, int level, union lsa_PolicyInformation *in)
{
	PyObject *ret;

	switch (level) {
		case LSA_POLICY_INFO_AUDIT_LOG:
			ret = pytalloc_reference_ex(&lsa_AuditLogInfo_Type, mem_ctx, &in->audit_log);
			return ret;

		case LSA_POLICY_INFO_AUDIT_EVENTS:
			ret = pytalloc_reference_ex(&lsa_AuditEventsInfo_Type, mem_ctx, &in->audit_events);
			return ret;

		case LSA_POLICY_INFO_DOMAIN:
			ret = pytalloc_reference_ex(&lsa_DomainInfo_Type, mem_ctx, &in->domain);
			return ret;

		case LSA_POLICY_INFO_PD:
			ret = pytalloc_reference_ex(&lsa_PDAccountInfo_Type, mem_ctx, &in->pd);
			return ret;

		case LSA_POLICY_INFO_ACCOUNT_DOMAIN:
			ret = pytalloc_reference_ex(&lsa_DomainInfo_Type, mem_ctx, &in->account_domain);
			return ret;

		case LSA_POLICY_INFO_ROLE:
			ret = pytalloc_reference_ex(&lsa_ServerRole_Type, mem_ctx, &in->role);
			return ret;

		case LSA_POLICY_INFO_REPLICA:
			ret = pytalloc_reference_ex(&lsa_ReplicaSourceInfo_Type, mem_ctx, &in->replica);
			return ret;

		case LSA_POLICY_INFO_QUOTA:
			ret = pytalloc_reference_ex(&lsa_DefaultQuotaInfo_Type, mem_ctx, &in->quota);
			return ret;

		case LSA_POLICY_INFO_MOD:
			ret = pytalloc_reference_ex(&lsa_ModificationInfo_Type, mem_ctx, &in->mod);
			return ret;

		case LSA_POLICY_INFO_AUDIT_FULL_SET:
			ret = pytalloc_reference_ex(&lsa_AuditFullSetInfo_Type, mem_ctx, &in->auditfullset);
			return ret;

		case LSA_POLICY_INFO_AUDIT_FULL_QUERY:
			ret = pytalloc_reference_ex(&lsa_AuditFullQueryInfo_Type, mem_ctx, &in->auditfullquery);
			return ret;

		case LSA_POLICY_INFO_DNS:
			ret = pytalloc_reference_ex(&lsa_DnsDomainInfo_Type, mem_ctx, &in->dns);
			return ret;

		case LSA_POLICY_INFO_DNS_INT:
			ret = pytalloc_reference_ex(&lsa_DnsDomainInfo_Type, mem_ctx, &in->dns);
			return ret;

		case LSA_POLICY_INFO_L_ACCOUNT_DOMAIN:
			ret = pytalloc_reference_ex(&lsa_DomainInfo_Type, mem_ctx, &in->l_account_domain);
			return ret;

	}
	PyErr_SetString(PyExc_TypeError, "unknown union level");
	return NULL;
}

static union lsa_PolicyInformation *py_export_lsa_PolicyInformation(TALLOC_CTX *mem_ctx, int level, PyObject *in)
{
	union lsa_PolicyInformation *ret = talloc_zero(mem_ctx, union lsa_PolicyInformation);
	switch (level) {
		case LSA_POLICY_INFO_AUDIT_LOG:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->audit_log");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_AuditLogInfo_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->audit_log = *(struct lsa_AuditLogInfo *)pytalloc_get_ptr(in);
			break;

		case LSA_POLICY_INFO_AUDIT_EVENTS:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->audit_events");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_AuditEventsInfo_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->audit_events = *(struct lsa_AuditEventsInfo *)pytalloc_get_ptr(in);
			break;

		case LSA_POLICY_INFO_DOMAIN:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->domain");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_DomainInfo_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->domain = *(struct lsa_DomainInfo *)pytalloc_get_ptr(in);
			break;

		case LSA_POLICY_INFO_PD:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->pd");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_PDAccountInfo_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->pd = *(struct lsa_PDAccountInfo *)pytalloc_get_ptr(in);
			break;

		case LSA_POLICY_INFO_ACCOUNT_DOMAIN:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->account_domain");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_DomainInfo_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->account_domain = *(struct lsa_DomainInfo *)pytalloc_get_ptr(in);
			break;

		case LSA_POLICY_INFO_ROLE:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->role");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_ServerRole_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->role = *(struct lsa_ServerRole *)pytalloc_get_ptr(in);
			break;

		case LSA_POLICY_INFO_REPLICA:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->replica");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_ReplicaSourceInfo_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->replica = *(struct lsa_ReplicaSourceInfo *)pytalloc_get_ptr(in);
			break;

		case LSA_POLICY_INFO_QUOTA:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->quota");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_DefaultQuotaInfo_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->quota = *(struct lsa_DefaultQuotaInfo *)pytalloc_get_ptr(in);
			break;

		case LSA_POLICY_INFO_MOD:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->mod");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_ModificationInfo_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->mod = *(struct lsa_ModificationInfo *)pytalloc_get_ptr(in);
			break;

		case LSA_POLICY_INFO_AUDIT_FULL_SET:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->auditfullset");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_AuditFullSetInfo_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->auditfullset = *(struct lsa_AuditFullSetInfo *)pytalloc_get_ptr(in);
			break;

		case LSA_POLICY_INFO_AUDIT_FULL_QUERY:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->auditfullquery");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_AuditFullQueryInfo_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->auditfullquery = *(struct lsa_AuditFullQueryInfo *)pytalloc_get_ptr(in);
			break;

		case LSA_POLICY_INFO_DNS:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->dns");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_DnsDomainInfo_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->dns = *(struct lsa_DnsDomainInfo *)pytalloc_get_ptr(in);
			break;

		case LSA_POLICY_INFO_DNS_INT:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->dns");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_DnsDomainInfo_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->dns = *(struct lsa_DnsDomainInfo *)pytalloc_get_ptr(in);
			break;

		case LSA_POLICY_INFO_L_ACCOUNT_DOMAIN:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->l_account_domain");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_DomainInfo_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->l_account_domain = *(struct lsa_DomainInfo *)pytalloc_get_ptr(in);
			break;

		default:
			PyErr_SetString(PyExc_TypeError, "invalid union level value");
			talloc_free(ret);
			ret = NULL;
	}

	return ret;
}

static PyObject *py_lsa_PolicyInformation_import(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "mem_ctx", "level", "in", NULL };
	PyObject *mem_ctx_obj = NULL;
	TALLOC_CTX *mem_ctx = NULL;
	int level = 0;
	PyObject *in_obj = NULL;
	union lsa_PolicyInformation *in = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiO:import",
		discard_const_p(char *, kwnames),
		&mem_ctx_obj,
		&level,
		&in_obj)) {
		return NULL;
	}
	mem_ctx = pytalloc_get_ptr(mem_ctx_obj);
	if (mem_ctx == NULL) {
		PyErr_SetString(PyExc_TypeError, "mem_ctx is NULL)!");
		return NULL;
	}
	in = (union lsa_PolicyInformation *)pytalloc_get_ptr(in_obj);
	if (in == NULL) {
		PyErr_Format(PyExc_TypeError, "in needs to be a pointer to union lsa_PolicyInformation!");
		return NULL;
	}

	return py_import_lsa_PolicyInformation(mem_ctx, level, in);
}

static PyObject *py_lsa_PolicyInformation_export(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "mem_ctx", "level", "in", NULL };
	PyObject *mem_ctx_obj = NULL;
	TALLOC_CTX *mem_ctx = NULL;
	int level = 0;
	PyObject *in = NULL;
	union lsa_PolicyInformation *out = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiO:import",
		discard_const_p(char *, kwnames),
		&mem_ctx_obj,
		&level,
		&in)) {
		return NULL;
	}
	mem_ctx = pytalloc_get_ptr(mem_ctx_obj);
	if (mem_ctx == NULL) {
		PyErr_SetString(PyExc_TypeError, "mem_ctx is NULL)!");
		return NULL;
	}

	out = py_export_lsa_PolicyInformation(mem_ctx, level, in);
	if (out == NULL) {
		return NULL;
	}

	return pytalloc_GenericObject_reference(out);
}

static PyMethodDef py_lsa_PolicyInformation_methods[] = {
	{ "__import__", (PyCFunction)py_lsa_PolicyInformation_import,
		METH_VARARGS|METH_KEYWORDS|METH_CLASS,
		"T.__import__(mem_ctx, level, in) => ret." },
	{ "__export__", (PyCFunction)py_lsa_PolicyInformation_export,
		METH_VARARGS|METH_KEYWORDS|METH_CLASS,
		"T.__export__(mem_ctx, level, in) => ret." },
	{ NULL, NULL, 0, NULL }
};

static PyObject *py_lsa_PolicyInformation_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	PyErr_Format(PyExc_TypeError, "New %s Objects are not supported", type->tp_name);
	return NULL;
}


static PyTypeObject lsa_PolicyInformation_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.PolicyInformation",
	.tp_getset = NULL,
	.tp_methods = py_lsa_PolicyInformation_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_PolicyInformation_new,
};


static PyObject *py_lsa_SidPtr_get_sid(PyObject *obj, void *closure)
{
	struct lsa_SidPtr *object = (struct lsa_SidPtr *)pytalloc_get_ptr(obj);
	PyObject *py_sid;
	if (object->sid == NULL) {
		py_sid = Py_None;
		Py_INCREF(py_sid);
	} else {
		py_sid = pytalloc_reference_ex(dom_sid_Type, object->sid, object->sid);
	}
	return py_sid;
}

static int py_lsa_SidPtr_set_sid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SidPtr *object = (struct lsa_SidPtr *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->sid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sid");
		return -1;
	}
	if (value == Py_None) {
		object->sid = NULL;
	} else {
		object->sid = NULL;
		PY_CHECK_TYPE(dom_sid_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->sid = (struct dom_sid *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyGetSetDef py_lsa_SidPtr_getsetters[] = {
	{
		.name = discard_const_p(char, "sid"),
		.get = py_lsa_SidPtr_get_sid,
		.set = py_lsa_SidPtr_set_sid,
		.doc = discard_const_p(char, "PIDL-generated element of base type dom_sid2")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_SidPtr_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_SidPtr, type);
}


static PyTypeObject lsa_SidPtr_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.SidPtr",
	.tp_getset = py_lsa_SidPtr_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_SidPtr_new,
};


static PyObject *py_lsa_SidArray_get_num_sids(PyObject *obj, void *closure)
{
	struct lsa_SidArray *object = (struct lsa_SidArray *)pytalloc_get_ptr(obj);
	PyObject *py_num_sids;
	py_num_sids = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->num_sids);
	return py_num_sids;
}

static int py_lsa_SidArray_set_num_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SidArray *object = (struct lsa_SidArray *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->num_sids");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->num_sids));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->num_sids = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->num_sids = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_SidArray_get_sids(PyObject *obj, void *closure)
{
	struct lsa_SidArray *object = (struct lsa_SidArray *)pytalloc_get_ptr(obj);
	PyObject *py_sids;
	if (object->sids == NULL) {
		py_sids = Py_None;
		Py_INCREF(py_sids);
	} else {
		py_sids = PyList_New(object->num_sids);
		if (py_sids == NULL) {
			return NULL;
		}
		{
			int sids_cntr_1;
			for (sids_cntr_1 = 0; sids_cntr_1 < (object->num_sids); sids_cntr_1++) {
				PyObject *py_sids_1;
				py_sids_1 = pytalloc_reference_ex(&lsa_SidPtr_Type, object->sids, &object->sids[sids_cntr_1]);
				PyList_SetItem(py_sids, sids_cntr_1, py_sids_1);
			}
		}
	}
	return py_sids;
}

static int py_lsa_SidArray_set_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SidArray *object = (struct lsa_SidArray *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->sids));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sids");
		return -1;
	}
	if (value == Py_None) {
		object->sids = NULL;
	} else {
		object->sids = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int sids_cntr_1;
			object->sids = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->sids, PyList_GET_SIZE(value));
			if (!object->sids) { return -1;; }
			talloc_set_name_const(object->sids, "ARRAY: object->sids");
			for (sids_cntr_1 = 0; sids_cntr_1 < PyList_GET_SIZE(value); sids_cntr_1++) {
				if (PyList_GET_ITEM(value, sids_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sids[sids_cntr_1]");
					return -1;
				}
				PY_CHECK_TYPE(&lsa_SidPtr_Type, PyList_GET_ITEM(value, sids_cntr_1), return -1;);
				if (talloc_reference(object->sids, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, sids_cntr_1))) == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				object->sids[sids_cntr_1] = *(struct lsa_SidPtr *)pytalloc_get_ptr(PyList_GET_ITEM(value, sids_cntr_1));
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_SidArray_getsetters[] = {
	{
		.name = discard_const_p(char, "num_sids"),
		.get = py_lsa_SidArray_get_num_sids,
		.set = py_lsa_SidArray_set_num_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "sids"),
		.get = py_lsa_SidArray_get_sids,
		.set = py_lsa_SidArray_set_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_SidPtr")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_SidArray_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_SidArray, type);
}

static PyObject *py_lsa_SidArray_ndr_pack(PyObject *py_obj)
{
	struct lsa_SidArray *object = (struct lsa_SidArray *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_lsa_SidArray);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_lsa_SidArray_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct lsa_SidArray *object = (struct lsa_SidArray *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_SidArray);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_SidArray);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_lsa_SidArray_ndr_print(PyObject *py_obj)
{
	struct lsa_SidArray *object = (struct lsa_SidArray *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_lsa_SidArray, "lsa_SidArray", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_lsa_SidArray_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_lsa_SidArray_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_lsa_SidArray_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_lsa_SidArray_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_SidArray_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.SidArray",
	.tp_getset = py_lsa_SidArray_getsetters,
	.tp_methods = py_lsa_SidArray_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_SidArray_new,
};


static PyObject *py_lsa_DomainList_get_count(PyObject *obj, void *closure)
{
	struct lsa_DomainList *object = (struct lsa_DomainList *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->count);
	return py_count;
}

static int py_lsa_DomainList_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DomainList *object = (struct lsa_DomainList *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_DomainList_get_domains(PyObject *obj, void *closure)
{
	struct lsa_DomainList *object = (struct lsa_DomainList *)pytalloc_get_ptr(obj);
	PyObject *py_domains;
	if (object->domains == NULL) {
		py_domains = Py_None;
		Py_INCREF(py_domains);
	} else {
		py_domains = PyList_New(object->count);
		if (py_domains == NULL) {
			return NULL;
		}
		{
			int domains_cntr_1;
			for (domains_cntr_1 = 0; domains_cntr_1 < (object->count); domains_cntr_1++) {
				PyObject *py_domains_1;
				py_domains_1 = pytalloc_reference_ex(&lsa_DomainInfo_Type, object->domains, &object->domains[domains_cntr_1]);
				PyList_SetItem(py_domains, domains_cntr_1, py_domains_1);
			}
		}
	}
	return py_domains;
}

static int py_lsa_DomainList_set_domains(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DomainList *object = (struct lsa_DomainList *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->domains));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->domains");
		return -1;
	}
	if (value == Py_None) {
		object->domains = NULL;
	} else {
		object->domains = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int domains_cntr_1;
			object->domains = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->domains, PyList_GET_SIZE(value));
			if (!object->domains) { return -1;; }
			talloc_set_name_const(object->domains, "ARRAY: object->domains");
			for (domains_cntr_1 = 0; domains_cntr_1 < PyList_GET_SIZE(value); domains_cntr_1++) {
				if (PyList_GET_ITEM(value, domains_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->domains[domains_cntr_1]");
					return -1;
				}
				PY_CHECK_TYPE(&lsa_DomainInfo_Type, PyList_GET_ITEM(value, domains_cntr_1), return -1;);
				if (talloc_reference(object->domains, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, domains_cntr_1))) == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				object->domains[domains_cntr_1] = *(struct lsa_DomainInfo *)pytalloc_get_ptr(PyList_GET_ITEM(value, domains_cntr_1));
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_DomainList_getsetters[] = {
	{
		.name = discard_const_p(char, "count"),
		.get = py_lsa_DomainList_get_count,
		.set = py_lsa_DomainList_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "domains"),
		.get = py_lsa_DomainList_get_domains,
		.set = py_lsa_DomainList_set_domains,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DomainInfo")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_DomainList_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_DomainList, type);
}


static PyTypeObject lsa_DomainList_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.DomainList",
	.tp_getset = py_lsa_DomainList_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_DomainList_new,
};


static PyObject *py_lsa_TranslatedSid_get_sid_type(PyObject *obj, void *closure)
{
	struct lsa_TranslatedSid *object = (struct lsa_TranslatedSid *)pytalloc_get_ptr(obj);
	PyObject *py_sid_type;
	py_sid_type = PyInt_FromLong((uint16_t)object->sid_type);
	return py_sid_type;
}

static int py_lsa_TranslatedSid_set_sid_type(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedSid *object = (struct lsa_TranslatedSid *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sid_type");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->sid_type));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_type = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_type = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TranslatedSid_get_rid(PyObject *obj, void *closure)
{
	struct lsa_TranslatedSid *object = (struct lsa_TranslatedSid *)pytalloc_get_ptr(obj);
	PyObject *py_rid;
	py_rid = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->rid);
	return py_rid;
}

static int py_lsa_TranslatedSid_set_rid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedSid *object = (struct lsa_TranslatedSid *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->rid");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->rid));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->rid = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->rid = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TranslatedSid_get_sid_index(PyObject *obj, void *closure)
{
	struct lsa_TranslatedSid *object = (struct lsa_TranslatedSid *)pytalloc_get_ptr(obj);
	PyObject *py_sid_index;
	py_sid_index = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->sid_index);
	return py_sid_index;
}

static int py_lsa_TranslatedSid_set_sid_index(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedSid *object = (struct lsa_TranslatedSid *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sid_index");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->sid_index));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_index = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_index = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_TranslatedSid_getsetters[] = {
	{
		.name = discard_const_p(char, "sid_type"),
		.get = py_lsa_TranslatedSid_get_sid_type,
		.set = py_lsa_TranslatedSid_set_sid_type,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_SidType")
	},
	{
		.name = discard_const_p(char, "rid"),
		.get = py_lsa_TranslatedSid_get_rid,
		.set = py_lsa_TranslatedSid_set_rid,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "sid_index"),
		.get = py_lsa_TranslatedSid_get_sid_index,
		.set = py_lsa_TranslatedSid_set_sid_index,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TranslatedSid_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TranslatedSid, type);
}


static PyTypeObject lsa_TranslatedSid_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TranslatedSid",
	.tp_getset = py_lsa_TranslatedSid_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TranslatedSid_new,
};


static PyObject *py_lsa_TransSidArray_get_count(PyObject *obj, void *closure)
{
	struct lsa_TransSidArray *object = (struct lsa_TransSidArray *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->count);
	return py_count;
}

static int py_lsa_TransSidArray_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TransSidArray *object = (struct lsa_TransSidArray *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TransSidArray_get_sids(PyObject *obj, void *closure)
{
	struct lsa_TransSidArray *object = (struct lsa_TransSidArray *)pytalloc_get_ptr(obj);
	PyObject *py_sids;
	if (object->sids == NULL) {
		py_sids = Py_None;
		Py_INCREF(py_sids);
	} else {
		py_sids = PyList_New(object->count);
		if (py_sids == NULL) {
			return NULL;
		}
		{
			int sids_cntr_1;
			for (sids_cntr_1 = 0; sids_cntr_1 < (object->count); sids_cntr_1++) {
				PyObject *py_sids_1;
				py_sids_1 = pytalloc_reference_ex(&lsa_TranslatedSid_Type, object->sids, &object->sids[sids_cntr_1]);
				PyList_SetItem(py_sids, sids_cntr_1, py_sids_1);
			}
		}
	}
	return py_sids;
}

static int py_lsa_TransSidArray_set_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TransSidArray *object = (struct lsa_TransSidArray *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->sids));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sids");
		return -1;
	}
	if (value == Py_None) {
		object->sids = NULL;
	} else {
		object->sids = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int sids_cntr_1;
			object->sids = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->sids, PyList_GET_SIZE(value));
			if (!object->sids) { return -1;; }
			talloc_set_name_const(object->sids, "ARRAY: object->sids");
			for (sids_cntr_1 = 0; sids_cntr_1 < PyList_GET_SIZE(value); sids_cntr_1++) {
				if (PyList_GET_ITEM(value, sids_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sids[sids_cntr_1]");
					return -1;
				}
				PY_CHECK_TYPE(&lsa_TranslatedSid_Type, PyList_GET_ITEM(value, sids_cntr_1), return -1;);
				if (talloc_reference(object->sids, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, sids_cntr_1))) == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				object->sids[sids_cntr_1] = *(struct lsa_TranslatedSid *)pytalloc_get_ptr(PyList_GET_ITEM(value, sids_cntr_1));
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_TransSidArray_getsetters[] = {
	{
		.name = discard_const_p(char, "count"),
		.get = py_lsa_TransSidArray_get_count,
		.set = py_lsa_TransSidArray_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "sids"),
		.get = py_lsa_TransSidArray_get_sids,
		.set = py_lsa_TransSidArray_set_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TranslatedSid")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TransSidArray_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TransSidArray, type);
}


static PyTypeObject lsa_TransSidArray_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TransSidArray",
	.tp_getset = py_lsa_TransSidArray_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TransSidArray_new,
};


static PyObject *py_lsa_RefDomainList_get_count(PyObject *obj, void *closure)
{
	struct lsa_RefDomainList *object = (struct lsa_RefDomainList *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->count);
	return py_count;
}

static int py_lsa_RefDomainList_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RefDomainList *object = (struct lsa_RefDomainList *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_RefDomainList_get_domains(PyObject *obj, void *closure)
{
	struct lsa_RefDomainList *object = (struct lsa_RefDomainList *)pytalloc_get_ptr(obj);
	PyObject *py_domains;
	if (object->domains == NULL) {
		py_domains = Py_None;
		Py_INCREF(py_domains);
	} else {
		py_domains = PyList_New(object->count);
		if (py_domains == NULL) {
			return NULL;
		}
		{
			int domains_cntr_1;
			for (domains_cntr_1 = 0; domains_cntr_1 < (object->count); domains_cntr_1++) {
				PyObject *py_domains_1;
				py_domains_1 = pytalloc_reference_ex(&lsa_DomainInfo_Type, object->domains, &object->domains[domains_cntr_1]);
				PyList_SetItem(py_domains, domains_cntr_1, py_domains_1);
			}
		}
	}
	return py_domains;
}

static int py_lsa_RefDomainList_set_domains(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RefDomainList *object = (struct lsa_RefDomainList *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->domains));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->domains");
		return -1;
	}
	if (value == Py_None) {
		object->domains = NULL;
	} else {
		object->domains = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int domains_cntr_1;
			object->domains = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->domains, PyList_GET_SIZE(value));
			if (!object->domains) { return -1;; }
			talloc_set_name_const(object->domains, "ARRAY: object->domains");
			for (domains_cntr_1 = 0; domains_cntr_1 < PyList_GET_SIZE(value); domains_cntr_1++) {
				if (PyList_GET_ITEM(value, domains_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->domains[domains_cntr_1]");
					return -1;
				}
				PY_CHECK_TYPE(&lsa_DomainInfo_Type, PyList_GET_ITEM(value, domains_cntr_1), return -1;);
				if (talloc_reference(object->domains, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, domains_cntr_1))) == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				object->domains[domains_cntr_1] = *(struct lsa_DomainInfo *)pytalloc_get_ptr(PyList_GET_ITEM(value, domains_cntr_1));
			}
		}
	}
	return 0;
}

static PyObject *py_lsa_RefDomainList_get_max_size(PyObject *obj, void *closure)
{
	struct lsa_RefDomainList *object = (struct lsa_RefDomainList *)pytalloc_get_ptr(obj);
	PyObject *py_max_size;
	py_max_size = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->max_size);
	return py_max_size;
}

static int py_lsa_RefDomainList_set_max_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RefDomainList *object = (struct lsa_RefDomainList *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->max_size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->max_size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->max_size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->max_size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_RefDomainList_getsetters[] = {
	{
		.name = discard_const_p(char, "count"),
		.get = py_lsa_RefDomainList_get_count,
		.set = py_lsa_RefDomainList_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "domains"),
		.get = py_lsa_RefDomainList_get_domains,
		.set = py_lsa_RefDomainList_set_domains,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DomainInfo")
	},
	{
		.name = discard_const_p(char, "max_size"),
		.get = py_lsa_RefDomainList_get_max_size,
		.set = py_lsa_RefDomainList_set_max_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_RefDomainList_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_RefDomainList, type);
}

static PyObject *py_lsa_RefDomainList_ndr_pack(PyObject *py_obj)
{
	struct lsa_RefDomainList *object = (struct lsa_RefDomainList *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_lsa_RefDomainList);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_lsa_RefDomainList_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct lsa_RefDomainList *object = (struct lsa_RefDomainList *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_RefDomainList);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_RefDomainList);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_lsa_RefDomainList_ndr_print(PyObject *py_obj)
{
	struct lsa_RefDomainList *object = (struct lsa_RefDomainList *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_lsa_RefDomainList, "lsa_RefDomainList", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_lsa_RefDomainList_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_lsa_RefDomainList_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_lsa_RefDomainList_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_lsa_RefDomainList_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_RefDomainList_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.RefDomainList",
	.tp_getset = py_lsa_RefDomainList_getsetters,
	.tp_methods = py_lsa_RefDomainList_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_RefDomainList_new,
};


static PyObject *py_lsa_TranslatedName_get_sid_type(PyObject *obj, void *closure)
{
	struct lsa_TranslatedName *object = (struct lsa_TranslatedName *)pytalloc_get_ptr(obj);
	PyObject *py_sid_type;
	py_sid_type = PyInt_FromLong((uint16_t)object->sid_type);
	return py_sid_type;
}

static int py_lsa_TranslatedName_set_sid_type(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedName *object = (struct lsa_TranslatedName *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sid_type");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->sid_type));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_type = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_type = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TranslatedName_get_name(PyObject *obj, void *closure)
{
	struct lsa_TranslatedName *object = (struct lsa_TranslatedName *)pytalloc_get_ptr(obj);
	PyObject *py_name;
	py_name = pytalloc_reference_ex(&lsa_String_Type, pytalloc_get_mem_ctx(obj), &object->name);
	return py_name;
}

static int py_lsa_TranslatedName_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedName *object = (struct lsa_TranslatedName *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->name");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->name = *(struct lsa_String *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_TranslatedName_get_sid_index(PyObject *obj, void *closure)
{
	struct lsa_TranslatedName *object = (struct lsa_TranslatedName *)pytalloc_get_ptr(obj);
	PyObject *py_sid_index;
	py_sid_index = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->sid_index);
	return py_sid_index;
}

static int py_lsa_TranslatedName_set_sid_index(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedName *object = (struct lsa_TranslatedName *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sid_index");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->sid_index));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_index = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_index = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_TranslatedName_getsetters[] = {
	{
		.name = discard_const_p(char, "sid_type"),
		.get = py_lsa_TranslatedName_get_sid_type,
		.set = py_lsa_TranslatedName_set_sid_type,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_SidType")
	},
	{
		.name = discard_const_p(char, "name"),
		.get = py_lsa_TranslatedName_get_name,
		.set = py_lsa_TranslatedName_set_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "sid_index"),
		.get = py_lsa_TranslatedName_get_sid_index,
		.set = py_lsa_TranslatedName_set_sid_index,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TranslatedName_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TranslatedName, type);
}


static PyTypeObject lsa_TranslatedName_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TranslatedName",
	.tp_getset = py_lsa_TranslatedName_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TranslatedName_new,
};


static PyObject *py_lsa_TransNameArray_get_count(PyObject *obj, void *closure)
{
	struct lsa_TransNameArray *object = (struct lsa_TransNameArray *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->count);
	return py_count;
}

static int py_lsa_TransNameArray_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TransNameArray *object = (struct lsa_TransNameArray *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TransNameArray_get_names(PyObject *obj, void *closure)
{
	struct lsa_TransNameArray *object = (struct lsa_TransNameArray *)pytalloc_get_ptr(obj);
	PyObject *py_names;
	if (object->names == NULL) {
		py_names = Py_None;
		Py_INCREF(py_names);
	} else {
		py_names = PyList_New(object->count);
		if (py_names == NULL) {
			return NULL;
		}
		{
			int names_cntr_1;
			for (names_cntr_1 = 0; names_cntr_1 < (object->count); names_cntr_1++) {
				PyObject *py_names_1;
				py_names_1 = pytalloc_reference_ex(&lsa_TranslatedName_Type, object->names, &object->names[names_cntr_1]);
				PyList_SetItem(py_names, names_cntr_1, py_names_1);
			}
		}
	}
	return py_names;
}

static int py_lsa_TransNameArray_set_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TransNameArray *object = (struct lsa_TransNameArray *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->names));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->names");
		return -1;
	}
	if (value == Py_None) {
		object->names = NULL;
	} else {
		object->names = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int names_cntr_1;
			object->names = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->names, PyList_GET_SIZE(value));
			if (!object->names) { return -1;; }
			talloc_set_name_const(object->names, "ARRAY: object->names");
			for (names_cntr_1 = 0; names_cntr_1 < PyList_GET_SIZE(value); names_cntr_1++) {
				if (PyList_GET_ITEM(value, names_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->names[names_cntr_1]");
					return -1;
				}
				PY_CHECK_TYPE(&lsa_TranslatedName_Type, PyList_GET_ITEM(value, names_cntr_1), return -1;);
				if (talloc_reference(object->names, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, names_cntr_1))) == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				object->names[names_cntr_1] = *(struct lsa_TranslatedName *)pytalloc_get_ptr(PyList_GET_ITEM(value, names_cntr_1));
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_TransNameArray_getsetters[] = {
	{
		.name = discard_const_p(char, "count"),
		.get = py_lsa_TransNameArray_get_count,
		.set = py_lsa_TransNameArray_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "names"),
		.get = py_lsa_TransNameArray_get_names,
		.set = py_lsa_TransNameArray_set_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TranslatedName")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TransNameArray_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TransNameArray, type);
}

static PyObject *py_lsa_TransNameArray_ndr_pack(PyObject *py_obj)
{
	struct lsa_TransNameArray *object = (struct lsa_TransNameArray *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_lsa_TransNameArray);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_lsa_TransNameArray_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct lsa_TransNameArray *object = (struct lsa_TransNameArray *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_TransNameArray);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_TransNameArray);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_lsa_TransNameArray_ndr_print(PyObject *py_obj)
{
	struct lsa_TransNameArray *object = (struct lsa_TransNameArray *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_lsa_TransNameArray, "lsa_TransNameArray", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_lsa_TransNameArray_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_lsa_TransNameArray_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_lsa_TransNameArray_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_lsa_TransNameArray_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_TransNameArray_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TransNameArray",
	.tp_getset = py_lsa_TransNameArray_getsetters,
	.tp_methods = py_lsa_TransNameArray_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TransNameArray_new,
};


static PyObject *py_lsa_LUIDAttribute_get_luid(PyObject *obj, void *closure)
{
	struct lsa_LUIDAttribute *object = (struct lsa_LUIDAttribute *)pytalloc_get_ptr(obj);
	PyObject *py_luid;
	py_luid = pytalloc_reference_ex(&lsa_LUID_Type, pytalloc_get_mem_ctx(obj), &object->luid);
	return py_luid;
}

static int py_lsa_LUIDAttribute_set_luid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LUIDAttribute *object = (struct lsa_LUIDAttribute *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->luid");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_LUID_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->luid = *(struct lsa_LUID *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LUIDAttribute_get_attribute(PyObject *obj, void *closure)
{
	struct lsa_LUIDAttribute *object = (struct lsa_LUIDAttribute *)pytalloc_get_ptr(obj);
	PyObject *py_attribute;
	py_attribute = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->attribute);
	return py_attribute;
}

static int py_lsa_LUIDAttribute_set_attribute(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LUIDAttribute *object = (struct lsa_LUIDAttribute *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->attribute");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->attribute));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->attribute = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->attribute = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_LUIDAttribute_getsetters[] = {
	{
		.name = discard_const_p(char, "luid"),
		.get = py_lsa_LUIDAttribute_get_luid,
		.set = py_lsa_LUIDAttribute_set_luid,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_LUID")
	},
	{
		.name = discard_const_p(char, "attribute"),
		.get = py_lsa_LUIDAttribute_get_attribute,
		.set = py_lsa_LUIDAttribute_set_attribute,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_LUIDAttribute_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_LUIDAttribute, type);
}


static PyTypeObject lsa_LUIDAttribute_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.LUIDAttribute",
	.tp_getset = py_lsa_LUIDAttribute_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_LUIDAttribute_new,
};


static PyObject *py_lsa_PrivilegeSet_get_count(PyObject *obj, void *closure)
{
	struct lsa_PrivilegeSet *object = (struct lsa_PrivilegeSet *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->count);
	return py_count;
}

static int py_lsa_PrivilegeSet_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_PrivilegeSet *object = (struct lsa_PrivilegeSet *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_PrivilegeSet_get_unknown(PyObject *obj, void *closure)
{
	struct lsa_PrivilegeSet *object = (struct lsa_PrivilegeSet *)pytalloc_get_ptr(obj);
	PyObject *py_unknown;
	py_unknown = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->unknown);
	return py_unknown;
}

static int py_lsa_PrivilegeSet_set_unknown(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_PrivilegeSet *object = (struct lsa_PrivilegeSet *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->unknown");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->unknown));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->unknown = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->unknown = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_PrivilegeSet_get_set(PyObject *obj, void *closure)
{
	struct lsa_PrivilegeSet *object = (struct lsa_PrivilegeSet *)pytalloc_get_ptr(obj);
	PyObject *py_set;
	py_set = PyList_New(object->count);
	if (py_set == NULL) {
		return NULL;
	}
	{
		int set_cntr_0;
		for (set_cntr_0 = 0; set_cntr_0 < (object->count); set_cntr_0++) {
			PyObject *py_set_0;
			py_set_0 = pytalloc_reference_ex(&lsa_LUIDAttribute_Type, object->set, &object->set[set_cntr_0]);
			PyList_SetItem(py_set, set_cntr_0, py_set_0);
		}
	}
	return py_set;
}

static int py_lsa_PrivilegeSet_set_set(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_PrivilegeSet *object = (struct lsa_PrivilegeSet *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->set");
		return -1;
	}
	PY_CHECK_TYPE(&PyList_Type, value, return -1;);
	{
		int set_cntr_0;
		object->set = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->set, PyList_GET_SIZE(value));
		if (!object->set) { return -1;; }
		talloc_set_name_const(object->set, "ARRAY: object->set");
		for (set_cntr_0 = 0; set_cntr_0 < PyList_GET_SIZE(value); set_cntr_0++) {
			if (PyList_GET_ITEM(value, set_cntr_0) == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->set[set_cntr_0]");
				return -1;
			}
			PY_CHECK_TYPE(&lsa_LUIDAttribute_Type, PyList_GET_ITEM(value, set_cntr_0), return -1;);
			if (talloc_reference(object->set, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, set_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->set[set_cntr_0] = *(struct lsa_LUIDAttribute *)pytalloc_get_ptr(PyList_GET_ITEM(value, set_cntr_0));
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_PrivilegeSet_getsetters[] = {
	{
		.name = discard_const_p(char, "count"),
		.get = py_lsa_PrivilegeSet_get_count,
		.set = py_lsa_PrivilegeSet_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "unknown"),
		.get = py_lsa_PrivilegeSet_get_unknown,
		.set = py_lsa_PrivilegeSet_set_unknown,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "set"),
		.get = py_lsa_PrivilegeSet_get_set,
		.set = py_lsa_PrivilegeSet_set_set,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_LUIDAttribute")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_PrivilegeSet_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_PrivilegeSet, type);
}


static PyTypeObject lsa_PrivilegeSet_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.PrivilegeSet",
	.tp_getset = py_lsa_PrivilegeSet_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_PrivilegeSet_new,
};


static PyObject *py_lsa_DATA_BUF_get_length(PyObject *obj, void *closure)
{
	struct lsa_DATA_BUF *object = (struct lsa_DATA_BUF *)pytalloc_get_ptr(obj);
	PyObject *py_length;
	py_length = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->length);
	return py_length;
}

static int py_lsa_DATA_BUF_set_length(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DATA_BUF *object = (struct lsa_DATA_BUF *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->length");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->length));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->length = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->length = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_DATA_BUF_get_size(PyObject *obj, void *closure)
{
	struct lsa_DATA_BUF *object = (struct lsa_DATA_BUF *)pytalloc_get_ptr(obj);
	PyObject *py_size;
	py_size = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->size);
	return py_size;
}

static int py_lsa_DATA_BUF_set_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DATA_BUF *object = (struct lsa_DATA_BUF *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_DATA_BUF_get_data(PyObject *obj, void *closure)
{
	struct lsa_DATA_BUF *object = (struct lsa_DATA_BUF *)pytalloc_get_ptr(obj);
	PyObject *py_data;
	if (object->data == NULL) {
		py_data = Py_None;
		Py_INCREF(py_data);
	} else {
		py_data = PyList_New(object->length);
		if (py_data == NULL) {
			return NULL;
		}
		{
			int data_cntr_1;
			for (data_cntr_1 = 0; data_cntr_1 < (object->length); data_cntr_1++) {
				PyObject *py_data_1;
				py_data_1 = PyInt_FromLong((uint16_t)object->data[data_cntr_1]);
				PyList_SetItem(py_data, data_cntr_1, py_data_1);
			}
		}
	}
	return py_data;
}

static int py_lsa_DATA_BUF_set_data(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DATA_BUF *object = (struct lsa_DATA_BUF *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->data));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->data");
		return -1;
	}
	if (value == Py_None) {
		object->data = NULL;
	} else {
		object->data = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int data_cntr_1;
			object->data = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->data, PyList_GET_SIZE(value));
			if (!object->data) { return -1;; }
			talloc_set_name_const(object->data, "ARRAY: object->data");
			for (data_cntr_1 = 0; data_cntr_1 < PyList_GET_SIZE(value); data_cntr_1++) {
				if (PyList_GET_ITEM(value, data_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->data[data_cntr_1]");
					return -1;
				}
				{
					const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->data[data_cntr_1]));
					if (PyLong_Check(PyList_GET_ITEM(value, data_cntr_1))) {
						unsigned long long test_var;
						test_var = PyLong_AsUnsignedLongLong(PyList_GET_ITEM(value, data_cntr_1));
						if (PyErr_Occurred() != NULL) {
							return -1;
						}
						if (test_var > uint_max) {
							PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
							  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
							return -1;
						}
						object->data[data_cntr_1] = test_var;
					} else if (PyInt_Check(PyList_GET_ITEM(value, data_cntr_1))) {
						long test_var;
						test_var = PyInt_AsLong(PyList_GET_ITEM(value, data_cntr_1));
						if (test_var < 0 || test_var > uint_max) {
							PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
							  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
							return -1;
						}
						object->data[data_cntr_1] = test_var;
					} else {
						PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
						  PyInt_Type.tp_name, PyLong_Type.tp_name);
						return -1;
					}
				}
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_DATA_BUF_getsetters[] = {
	{
		.name = discard_const_p(char, "length"),
		.get = py_lsa_DATA_BUF_get_length,
		.set = py_lsa_DATA_BUF_set_length,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint3264")
	},
	{
		.name = discard_const_p(char, "size"),
		.get = py_lsa_DATA_BUF_get_size,
		.set = py_lsa_DATA_BUF_set_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint3264")
	},
	{
		.name = discard_const_p(char, "data"),
		.get = py_lsa_DATA_BUF_get_data,
		.set = py_lsa_DATA_BUF_set_data,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_DATA_BUF_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_DATA_BUF, type);
}


static PyTypeObject lsa_DATA_BUF_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.DATA_BUF",
	.tp_getset = py_lsa_DATA_BUF_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_DATA_BUF_new,
};


static PyObject *py_lsa_DATA_BUF2_get_size(PyObject *obj, void *closure)
{
	struct lsa_DATA_BUF2 *object = (struct lsa_DATA_BUF2 *)pytalloc_get_ptr(obj);
	PyObject *py_size;
	py_size = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->size);
	return py_size;
}

static int py_lsa_DATA_BUF2_set_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DATA_BUF2 *object = (struct lsa_DATA_BUF2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_DATA_BUF2_get_data(PyObject *obj, void *closure)
{
	struct lsa_DATA_BUF2 *object = (struct lsa_DATA_BUF2 *)pytalloc_get_ptr(obj);
	PyObject *py_data;
	if (object->data == NULL) {
		py_data = Py_None;
		Py_INCREF(py_data);
	} else {
		py_data = PyList_New(object->size);
		if (py_data == NULL) {
			return NULL;
		}
		{
			int data_cntr_1;
			for (data_cntr_1 = 0; data_cntr_1 < (object->size); data_cntr_1++) {
				PyObject *py_data_1;
				py_data_1 = PyInt_FromLong((uint16_t)object->data[data_cntr_1]);
				PyList_SetItem(py_data, data_cntr_1, py_data_1);
			}
		}
	}
	return py_data;
}

static int py_lsa_DATA_BUF2_set_data(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DATA_BUF2 *object = (struct lsa_DATA_BUF2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->data));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->data");
		return -1;
	}
	if (value == Py_None) {
		object->data = NULL;
	} else {
		object->data = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int data_cntr_1;
			object->data = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->data, PyList_GET_SIZE(value));
			if (!object->data) { return -1;; }
			talloc_set_name_const(object->data, "ARRAY: object->data");
			for (data_cntr_1 = 0; data_cntr_1 < PyList_GET_SIZE(value); data_cntr_1++) {
				if (PyList_GET_ITEM(value, data_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->data[data_cntr_1]");
					return -1;
				}
				{
					const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->data[data_cntr_1]));
					if (PyLong_Check(PyList_GET_ITEM(value, data_cntr_1))) {
						unsigned long long test_var;
						test_var = PyLong_AsUnsignedLongLong(PyList_GET_ITEM(value, data_cntr_1));
						if (PyErr_Occurred() != NULL) {
							return -1;
						}
						if (test_var > uint_max) {
							PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
							  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
							return -1;
						}
						object->data[data_cntr_1] = test_var;
					} else if (PyInt_Check(PyList_GET_ITEM(value, data_cntr_1))) {
						long test_var;
						test_var = PyInt_AsLong(PyList_GET_ITEM(value, data_cntr_1));
						if (test_var < 0 || test_var > uint_max) {
							PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
							  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
							return -1;
						}
						object->data[data_cntr_1] = test_var;
					} else {
						PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
						  PyInt_Type.tp_name, PyLong_Type.tp_name);
						return -1;
					}
				}
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_DATA_BUF2_getsetters[] = {
	{
		.name = discard_const_p(char, "size"),
		.get = py_lsa_DATA_BUF2_get_size,
		.set = py_lsa_DATA_BUF2_set_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "data"),
		.get = py_lsa_DATA_BUF2_get_data,
		.set = py_lsa_DATA_BUF2_set_data,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_DATA_BUF2_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_DATA_BUF2, type);
}


static PyTypeObject lsa_DATA_BUF2_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.DATA_BUF2",
	.tp_getset = py_lsa_DATA_BUF2_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_DATA_BUF2_new,
};


static PyObject *py_lsa_TrustDomainInfoName_get_netbios_name(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoName *object = (struct lsa_TrustDomainInfoName *)pytalloc_get_ptr(obj);
	PyObject *py_netbios_name;
	py_netbios_name = pytalloc_reference_ex(&lsa_StringLarge_Type, pytalloc_get_mem_ctx(obj), &object->netbios_name);
	return py_netbios_name;
}

static int py_lsa_TrustDomainInfoName_set_netbios_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoName *object = (struct lsa_TrustDomainInfoName *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->netbios_name");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_StringLarge_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->netbios_name = *(struct lsa_StringLarge *)pytalloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_lsa_TrustDomainInfoName_getsetters[] = {
	{
		.name = discard_const_p(char, "netbios_name"),
		.get = py_lsa_TrustDomainInfoName_get_netbios_name,
		.set = py_lsa_TrustDomainInfoName_set_netbios_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_StringLarge")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TrustDomainInfoName_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TrustDomainInfoName, type);
}


static PyTypeObject lsa_TrustDomainInfoName_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TrustDomainInfoName",
	.tp_getset = py_lsa_TrustDomainInfoName_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TrustDomainInfoName_new,
};


static PyObject *py_lsa_TrustDomainInfoControllers_get_entries(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoControllers *object = (struct lsa_TrustDomainInfoControllers *)pytalloc_get_ptr(obj);
	PyObject *py_entries;
	py_entries = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->entries);
	return py_entries;
}

static int py_lsa_TrustDomainInfoControllers_set_entries(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoControllers *object = (struct lsa_TrustDomainInfoControllers *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->entries");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->entries));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->entries = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->entries = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoControllers_get_netbios_names(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoControllers *object = (struct lsa_TrustDomainInfoControllers *)pytalloc_get_ptr(obj);
	PyObject *py_netbios_names;
	if (object->netbios_names == NULL) {
		py_netbios_names = Py_None;
		Py_INCREF(py_netbios_names);
	} else {
		py_netbios_names = PyList_New(object->entries);
		if (py_netbios_names == NULL) {
			return NULL;
		}
		{
			int netbios_names_cntr_1;
			for (netbios_names_cntr_1 = 0; netbios_names_cntr_1 < (object->entries); netbios_names_cntr_1++) {
				PyObject *py_netbios_names_1;
				py_netbios_names_1 = pytalloc_reference_ex(&lsa_StringLarge_Type, object->netbios_names, &object->netbios_names[netbios_names_cntr_1]);
				PyList_SetItem(py_netbios_names, netbios_names_cntr_1, py_netbios_names_1);
			}
		}
	}
	return py_netbios_names;
}

static int py_lsa_TrustDomainInfoControllers_set_netbios_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoControllers *object = (struct lsa_TrustDomainInfoControllers *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->netbios_names));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->netbios_names");
		return -1;
	}
	if (value == Py_None) {
		object->netbios_names = NULL;
	} else {
		object->netbios_names = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int netbios_names_cntr_1;
			object->netbios_names = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->netbios_names, PyList_GET_SIZE(value));
			if (!object->netbios_names) { return -1;; }
			talloc_set_name_const(object->netbios_names, "ARRAY: object->netbios_names");
			for (netbios_names_cntr_1 = 0; netbios_names_cntr_1 < PyList_GET_SIZE(value); netbios_names_cntr_1++) {
				if (PyList_GET_ITEM(value, netbios_names_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->netbios_names[netbios_names_cntr_1]");
					return -1;
				}
				PY_CHECK_TYPE(&lsa_StringLarge_Type, PyList_GET_ITEM(value, netbios_names_cntr_1), return -1;);
				if (talloc_reference(object->netbios_names, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, netbios_names_cntr_1))) == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				object->netbios_names[netbios_names_cntr_1] = *(struct lsa_StringLarge *)pytalloc_get_ptr(PyList_GET_ITEM(value, netbios_names_cntr_1));
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_TrustDomainInfoControllers_getsetters[] = {
	{
		.name = discard_const_p(char, "entries"),
		.get = py_lsa_TrustDomainInfoControllers_get_entries,
		.set = py_lsa_TrustDomainInfoControllers_set_entries,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "netbios_names"),
		.get = py_lsa_TrustDomainInfoControllers_get_netbios_names,
		.set = py_lsa_TrustDomainInfoControllers_set_netbios_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_StringLarge")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TrustDomainInfoControllers_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TrustDomainInfoControllers, type);
}


static PyTypeObject lsa_TrustDomainInfoControllers_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TrustDomainInfoControllers",
	.tp_getset = py_lsa_TrustDomainInfoControllers_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TrustDomainInfoControllers_new,
};


static PyObject *py_lsa_TrustDomainInfoPosixOffset_get_posix_offset(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoPosixOffset *object = (struct lsa_TrustDomainInfoPosixOffset *)pytalloc_get_ptr(obj);
	PyObject *py_posix_offset;
	py_posix_offset = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->posix_offset);
	return py_posix_offset;
}

static int py_lsa_TrustDomainInfoPosixOffset_set_posix_offset(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoPosixOffset *object = (struct lsa_TrustDomainInfoPosixOffset *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->posix_offset");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->posix_offset));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->posix_offset = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->posix_offset = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_TrustDomainInfoPosixOffset_getsetters[] = {
	{
		.name = discard_const_p(char, "posix_offset"),
		.get = py_lsa_TrustDomainInfoPosixOffset_get_posix_offset,
		.set = py_lsa_TrustDomainInfoPosixOffset_set_posix_offset,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TrustDomainInfoPosixOffset_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TrustDomainInfoPosixOffset, type);
}


static PyTypeObject lsa_TrustDomainInfoPosixOffset_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TrustDomainInfoPosixOffset",
	.tp_getset = py_lsa_TrustDomainInfoPosixOffset_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TrustDomainInfoPosixOffset_new,
};


static PyObject *py_lsa_TrustDomainInfoPassword_get_password(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoPassword *object = (struct lsa_TrustDomainInfoPassword *)pytalloc_get_ptr(obj);
	PyObject *py_password;
	if (object->password == NULL) {
		py_password = Py_None;
		Py_INCREF(py_password);
	} else {
		py_password = pytalloc_reference_ex(&lsa_DATA_BUF_Type, object->password, object->password);
	}
	return py_password;
}

static int py_lsa_TrustDomainInfoPassword_set_password(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoPassword *object = (struct lsa_TrustDomainInfoPassword *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->password));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->password");
		return -1;
	}
	if (value == Py_None) {
		object->password = NULL;
	} else {
		object->password = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->password = (struct lsa_DATA_BUF *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoPassword_get_old_password(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoPassword *object = (struct lsa_TrustDomainInfoPassword *)pytalloc_get_ptr(obj);
	PyObject *py_old_password;
	if (object->old_password == NULL) {
		py_old_password = Py_None;
		Py_INCREF(py_old_password);
	} else {
		py_old_password = pytalloc_reference_ex(&lsa_DATA_BUF_Type, object->old_password, object->old_password);
	}
	return py_old_password;
}

static int py_lsa_TrustDomainInfoPassword_set_old_password(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoPassword *object = (struct lsa_TrustDomainInfoPassword *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->old_password));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->old_password");
		return -1;
	}
	if (value == Py_None) {
		object->old_password = NULL;
	} else {
		object->old_password = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->old_password = (struct lsa_DATA_BUF *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyGetSetDef py_lsa_TrustDomainInfoPassword_getsetters[] = {
	{
		.name = discard_const_p(char, "password"),
		.get = py_lsa_TrustDomainInfoPassword_get_password,
		.set = py_lsa_TrustDomainInfoPassword_set_password,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DATA_BUF")
	},
	{
		.name = discard_const_p(char, "old_password"),
		.get = py_lsa_TrustDomainInfoPassword_get_old_password,
		.set = py_lsa_TrustDomainInfoPassword_set_old_password,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DATA_BUF")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TrustDomainInfoPassword_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TrustDomainInfoPassword, type);
}


static PyTypeObject lsa_TrustDomainInfoPassword_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TrustDomainInfoPassword",
	.tp_getset = py_lsa_TrustDomainInfoPassword_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TrustDomainInfoPassword_new,
};


static PyObject *py_lsa_TrustDomainInfoBasic_get_netbios_name(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoBasic *object = (struct lsa_TrustDomainInfoBasic *)pytalloc_get_ptr(obj);
	PyObject *py_netbios_name;
	py_netbios_name = pytalloc_reference_ex(&lsa_String_Type, pytalloc_get_mem_ctx(obj), &object->netbios_name);
	return py_netbios_name;
}

static int py_lsa_TrustDomainInfoBasic_set_netbios_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoBasic *object = (struct lsa_TrustDomainInfoBasic *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->netbios_name");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->netbios_name = *(struct lsa_String *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoBasic_get_sid(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoBasic *object = (struct lsa_TrustDomainInfoBasic *)pytalloc_get_ptr(obj);
	PyObject *py_sid;
	if (object->sid == NULL) {
		py_sid = Py_None;
		Py_INCREF(py_sid);
	} else {
		py_sid = pytalloc_reference_ex(dom_sid_Type, object->sid, object->sid);
	}
	return py_sid;
}

static int py_lsa_TrustDomainInfoBasic_set_sid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoBasic *object = (struct lsa_TrustDomainInfoBasic *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->sid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sid");
		return -1;
	}
	if (value == Py_None) {
		object->sid = NULL;
	} else {
		object->sid = NULL;
		PY_CHECK_TYPE(dom_sid_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->sid = (struct dom_sid *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyGetSetDef py_lsa_TrustDomainInfoBasic_getsetters[] = {
	{
		.name = discard_const_p(char, "netbios_name"),
		.get = py_lsa_TrustDomainInfoBasic_get_netbios_name,
		.set = py_lsa_TrustDomainInfoBasic_set_netbios_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "sid"),
		.get = py_lsa_TrustDomainInfoBasic_get_sid,
		.set = py_lsa_TrustDomainInfoBasic_set_sid,
		.doc = discard_const_p(char, "PIDL-generated element of base type dom_sid2")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TrustDomainInfoBasic_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TrustDomainInfoBasic, type);
}


static PyTypeObject lsa_TrustDomainInfoBasic_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TrustDomainInfoBasic",
	.tp_getset = py_lsa_TrustDomainInfoBasic_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TrustDomainInfoBasic_new,
};


static PyObject *py_lsa_TrustDomainInfoInfoEx_get_domain_name(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx *object = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(obj);
	PyObject *py_domain_name;
	py_domain_name = pytalloc_reference_ex(&lsa_StringLarge_Type, pytalloc_get_mem_ctx(obj), &object->domain_name);
	return py_domain_name;
}

static int py_lsa_TrustDomainInfoInfoEx_set_domain_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx *object = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->domain_name");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_StringLarge_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->domain_name = *(struct lsa_StringLarge *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoInfoEx_get_netbios_name(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx *object = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(obj);
	PyObject *py_netbios_name;
	py_netbios_name = pytalloc_reference_ex(&lsa_StringLarge_Type, pytalloc_get_mem_ctx(obj), &object->netbios_name);
	return py_netbios_name;
}

static int py_lsa_TrustDomainInfoInfoEx_set_netbios_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx *object = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->netbios_name");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_StringLarge_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->netbios_name = *(struct lsa_StringLarge *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoInfoEx_get_sid(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx *object = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(obj);
	PyObject *py_sid;
	if (object->sid == NULL) {
		py_sid = Py_None;
		Py_INCREF(py_sid);
	} else {
		py_sid = pytalloc_reference_ex(dom_sid_Type, object->sid, object->sid);
	}
	return py_sid;
}

static int py_lsa_TrustDomainInfoInfoEx_set_sid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx *object = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->sid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sid");
		return -1;
	}
	if (value == Py_None) {
		object->sid = NULL;
	} else {
		object->sid = NULL;
		PY_CHECK_TYPE(dom_sid_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->sid = (struct dom_sid *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoInfoEx_get_trust_direction(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx *object = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(obj);
	PyObject *py_trust_direction;
	py_trust_direction = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->trust_direction);
	return py_trust_direction;
}

static int py_lsa_TrustDomainInfoInfoEx_set_trust_direction(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx *object = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->trust_direction");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->trust_direction));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->trust_direction = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->trust_direction = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoInfoEx_get_trust_type(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx *object = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(obj);
	PyObject *py_trust_type;
	py_trust_type = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->trust_type);
	return py_trust_type;
}

static int py_lsa_TrustDomainInfoInfoEx_set_trust_type(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx *object = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->trust_type");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->trust_type));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->trust_type = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->trust_type = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoInfoEx_get_trust_attributes(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx *object = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(obj);
	PyObject *py_trust_attributes;
	py_trust_attributes = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->trust_attributes);
	return py_trust_attributes;
}

static int py_lsa_TrustDomainInfoInfoEx_set_trust_attributes(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx *object = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->trust_attributes");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->trust_attributes));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->trust_attributes = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->trust_attributes = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_TrustDomainInfoInfoEx_getsetters[] = {
	{
		.name = discard_const_p(char, "domain_name"),
		.get = py_lsa_TrustDomainInfoInfoEx_get_domain_name,
		.set = py_lsa_TrustDomainInfoInfoEx_set_domain_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_StringLarge")
	},
	{
		.name = discard_const_p(char, "netbios_name"),
		.get = py_lsa_TrustDomainInfoInfoEx_get_netbios_name,
		.set = py_lsa_TrustDomainInfoInfoEx_set_netbios_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_StringLarge")
	},
	{
		.name = discard_const_p(char, "sid"),
		.get = py_lsa_TrustDomainInfoInfoEx_get_sid,
		.set = py_lsa_TrustDomainInfoInfoEx_set_sid,
		.doc = discard_const_p(char, "PIDL-generated element of base type dom_sid2")
	},
	{
		.name = discard_const_p(char, "trust_direction"),
		.get = py_lsa_TrustDomainInfoInfoEx_get_trust_direction,
		.set = py_lsa_TrustDomainInfoInfoEx_set_trust_direction,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDirection")
	},
	{
		.name = discard_const_p(char, "trust_type"),
		.get = py_lsa_TrustDomainInfoInfoEx_get_trust_type,
		.set = py_lsa_TrustDomainInfoInfoEx_set_trust_type,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustType")
	},
	{
		.name = discard_const_p(char, "trust_attributes"),
		.get = py_lsa_TrustDomainInfoInfoEx_get_trust_attributes,
		.set = py_lsa_TrustDomainInfoInfoEx_set_trust_attributes,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustAttributes")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TrustDomainInfoInfoEx_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TrustDomainInfoInfoEx, type);
}

static PyObject *py_lsa_TrustDomainInfoInfoEx_ndr_pack(PyObject *py_obj)
{
	struct lsa_TrustDomainInfoInfoEx *object = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_lsa_TrustDomainInfoInfoEx);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_lsa_TrustDomainInfoInfoEx_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct lsa_TrustDomainInfoInfoEx *object = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_TrustDomainInfoInfoEx);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_TrustDomainInfoInfoEx);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_lsa_TrustDomainInfoInfoEx_ndr_print(PyObject *py_obj)
{
	struct lsa_TrustDomainInfoInfoEx *object = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_lsa_TrustDomainInfoInfoEx, "lsa_TrustDomainInfoInfoEx", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_lsa_TrustDomainInfoInfoEx_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_lsa_TrustDomainInfoInfoEx_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_lsa_TrustDomainInfoInfoEx_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_lsa_TrustDomainInfoInfoEx_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_TrustDomainInfoInfoEx_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TrustDomainInfoInfoEx",
	.tp_getset = py_lsa_TrustDomainInfoInfoEx_getsetters,
	.tp_methods = py_lsa_TrustDomainInfoInfoEx_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TrustDomainInfoInfoEx_new,
};


static PyObject *py_lsa_TrustDomainInfoBuffer_get_last_update_time(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoBuffer *object = (struct lsa_TrustDomainInfoBuffer *)pytalloc_get_ptr(obj);
	PyObject *py_last_update_time;
	py_last_update_time = ndr_PyLong_FromUnsignedLongLong(object->last_update_time);
	return py_last_update_time;
}

static int py_lsa_TrustDomainInfoBuffer_set_last_update_time(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoBuffer *object = (struct lsa_TrustDomainInfoBuffer *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->last_update_time");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->last_update_time));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->last_update_time = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->last_update_time = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoBuffer_get_AuthType(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoBuffer *object = (struct lsa_TrustDomainInfoBuffer *)pytalloc_get_ptr(obj);
	PyObject *py_AuthType;
	py_AuthType = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->AuthType);
	return py_AuthType;
}

static int py_lsa_TrustDomainInfoBuffer_set_AuthType(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoBuffer *object = (struct lsa_TrustDomainInfoBuffer *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->AuthType");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->AuthType));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->AuthType = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->AuthType = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoBuffer_get_data(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoBuffer *object = (struct lsa_TrustDomainInfoBuffer *)pytalloc_get_ptr(obj);
	PyObject *py_data;
	py_data = pytalloc_reference_ex(&lsa_DATA_BUF2_Type, pytalloc_get_mem_ctx(obj), &object->data);
	return py_data;
}

static int py_lsa_TrustDomainInfoBuffer_set_data(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoBuffer *object = (struct lsa_TrustDomainInfoBuffer *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->data");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_DATA_BUF2_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->data = *(struct lsa_DATA_BUF2 *)pytalloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_lsa_TrustDomainInfoBuffer_getsetters[] = {
	{
		.name = discard_const_p(char, "last_update_time"),
		.get = py_lsa_TrustDomainInfoBuffer_get_last_update_time,
		.set = py_lsa_TrustDomainInfoBuffer_set_last_update_time,
		.doc = discard_const_p(char, "PIDL-generated element of base type NTTIME_hyper")
	},
	{
		.name = discard_const_p(char, "AuthType"),
		.get = py_lsa_TrustDomainInfoBuffer_get_AuthType,
		.set = py_lsa_TrustDomainInfoBuffer_set_AuthType,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustAuthType")
	},
	{
		.name = discard_const_p(char, "data"),
		.get = py_lsa_TrustDomainInfoBuffer_get_data,
		.set = py_lsa_TrustDomainInfoBuffer_set_data,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DATA_BUF2")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TrustDomainInfoBuffer_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TrustDomainInfoBuffer, type);
}


static PyTypeObject lsa_TrustDomainInfoBuffer_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TrustDomainInfoBuffer",
	.tp_getset = py_lsa_TrustDomainInfoBuffer_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TrustDomainInfoBuffer_new,
};


static PyObject *py_lsa_TrustDomainInfoAuthInfo_get_incoming_count(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoAuthInfo *object = (struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(obj);
	PyObject *py_incoming_count;
	py_incoming_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->incoming_count);
	return py_incoming_count;
}

static int py_lsa_TrustDomainInfoAuthInfo_set_incoming_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoAuthInfo *object = (struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->incoming_count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->incoming_count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->incoming_count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->incoming_count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoAuthInfo_get_incoming_current_auth_info(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoAuthInfo *object = (struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(obj);
	PyObject *py_incoming_current_auth_info;
	if (object->incoming_current_auth_info == NULL) {
		py_incoming_current_auth_info = Py_None;
		Py_INCREF(py_incoming_current_auth_info);
	} else {
		py_incoming_current_auth_info = pytalloc_reference_ex(&lsa_TrustDomainInfoBuffer_Type, object->incoming_current_auth_info, object->incoming_current_auth_info);
	}
	return py_incoming_current_auth_info;
}

static int py_lsa_TrustDomainInfoAuthInfo_set_incoming_current_auth_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoAuthInfo *object = (struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->incoming_current_auth_info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->incoming_current_auth_info");
		return -1;
	}
	if (value == Py_None) {
		object->incoming_current_auth_info = NULL;
	} else {
		object->incoming_current_auth_info = NULL;
		PY_CHECK_TYPE(&lsa_TrustDomainInfoBuffer_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->incoming_current_auth_info = (struct lsa_TrustDomainInfoBuffer *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoAuthInfo_get_incoming_previous_auth_info(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoAuthInfo *object = (struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(obj);
	PyObject *py_incoming_previous_auth_info;
	if (object->incoming_previous_auth_info == NULL) {
		py_incoming_previous_auth_info = Py_None;
		Py_INCREF(py_incoming_previous_auth_info);
	} else {
		py_incoming_previous_auth_info = pytalloc_reference_ex(&lsa_TrustDomainInfoBuffer_Type, object->incoming_previous_auth_info, object->incoming_previous_auth_info);
	}
	return py_incoming_previous_auth_info;
}

static int py_lsa_TrustDomainInfoAuthInfo_set_incoming_previous_auth_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoAuthInfo *object = (struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->incoming_previous_auth_info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->incoming_previous_auth_info");
		return -1;
	}
	if (value == Py_None) {
		object->incoming_previous_auth_info = NULL;
	} else {
		object->incoming_previous_auth_info = NULL;
		PY_CHECK_TYPE(&lsa_TrustDomainInfoBuffer_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->incoming_previous_auth_info = (struct lsa_TrustDomainInfoBuffer *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoAuthInfo_get_outgoing_count(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoAuthInfo *object = (struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(obj);
	PyObject *py_outgoing_count;
	py_outgoing_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->outgoing_count);
	return py_outgoing_count;
}

static int py_lsa_TrustDomainInfoAuthInfo_set_outgoing_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoAuthInfo *object = (struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->outgoing_count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->outgoing_count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->outgoing_count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->outgoing_count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoAuthInfo_get_outgoing_current_auth_info(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoAuthInfo *object = (struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(obj);
	PyObject *py_outgoing_current_auth_info;
	if (object->outgoing_current_auth_info == NULL) {
		py_outgoing_current_auth_info = Py_None;
		Py_INCREF(py_outgoing_current_auth_info);
	} else {
		py_outgoing_current_auth_info = pytalloc_reference_ex(&lsa_TrustDomainInfoBuffer_Type, object->outgoing_current_auth_info, object->outgoing_current_auth_info);
	}
	return py_outgoing_current_auth_info;
}

static int py_lsa_TrustDomainInfoAuthInfo_set_outgoing_current_auth_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoAuthInfo *object = (struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->outgoing_current_auth_info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->outgoing_current_auth_info");
		return -1;
	}
	if (value == Py_None) {
		object->outgoing_current_auth_info = NULL;
	} else {
		object->outgoing_current_auth_info = NULL;
		PY_CHECK_TYPE(&lsa_TrustDomainInfoBuffer_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->outgoing_current_auth_info = (struct lsa_TrustDomainInfoBuffer *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoAuthInfo_get_outgoing_previous_auth_info(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoAuthInfo *object = (struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(obj);
	PyObject *py_outgoing_previous_auth_info;
	if (object->outgoing_previous_auth_info == NULL) {
		py_outgoing_previous_auth_info = Py_None;
		Py_INCREF(py_outgoing_previous_auth_info);
	} else {
		py_outgoing_previous_auth_info = pytalloc_reference_ex(&lsa_TrustDomainInfoBuffer_Type, object->outgoing_previous_auth_info, object->outgoing_previous_auth_info);
	}
	return py_outgoing_previous_auth_info;
}

static int py_lsa_TrustDomainInfoAuthInfo_set_outgoing_previous_auth_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoAuthInfo *object = (struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->outgoing_previous_auth_info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->outgoing_previous_auth_info");
		return -1;
	}
	if (value == Py_None) {
		object->outgoing_previous_auth_info = NULL;
	} else {
		object->outgoing_previous_auth_info = NULL;
		PY_CHECK_TYPE(&lsa_TrustDomainInfoBuffer_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->outgoing_previous_auth_info = (struct lsa_TrustDomainInfoBuffer *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyGetSetDef py_lsa_TrustDomainInfoAuthInfo_getsetters[] = {
	{
		.name = discard_const_p(char, "incoming_count"),
		.get = py_lsa_TrustDomainInfoAuthInfo_get_incoming_count,
		.set = py_lsa_TrustDomainInfoAuthInfo_set_incoming_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "incoming_current_auth_info"),
		.get = py_lsa_TrustDomainInfoAuthInfo_get_incoming_current_auth_info,
		.set = py_lsa_TrustDomainInfoAuthInfo_set_incoming_current_auth_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoBuffer")
	},
	{
		.name = discard_const_p(char, "incoming_previous_auth_info"),
		.get = py_lsa_TrustDomainInfoAuthInfo_get_incoming_previous_auth_info,
		.set = py_lsa_TrustDomainInfoAuthInfo_set_incoming_previous_auth_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoBuffer")
	},
	{
		.name = discard_const_p(char, "outgoing_count"),
		.get = py_lsa_TrustDomainInfoAuthInfo_get_outgoing_count,
		.set = py_lsa_TrustDomainInfoAuthInfo_set_outgoing_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "outgoing_current_auth_info"),
		.get = py_lsa_TrustDomainInfoAuthInfo_get_outgoing_current_auth_info,
		.set = py_lsa_TrustDomainInfoAuthInfo_set_outgoing_current_auth_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoBuffer")
	},
	{
		.name = discard_const_p(char, "outgoing_previous_auth_info"),
		.get = py_lsa_TrustDomainInfoAuthInfo_get_outgoing_previous_auth_info,
		.set = py_lsa_TrustDomainInfoAuthInfo_set_outgoing_previous_auth_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoBuffer")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TrustDomainInfoAuthInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TrustDomainInfoAuthInfo, type);
}

static PyObject *py_lsa_TrustDomainInfoAuthInfo_ndr_pack(PyObject *py_obj)
{
	struct lsa_TrustDomainInfoAuthInfo *object = (struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_lsa_TrustDomainInfoAuthInfo);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_lsa_TrustDomainInfoAuthInfo_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct lsa_TrustDomainInfoAuthInfo *object = (struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_TrustDomainInfoAuthInfo);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_TrustDomainInfoAuthInfo);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_lsa_TrustDomainInfoAuthInfo_ndr_print(PyObject *py_obj)
{
	struct lsa_TrustDomainInfoAuthInfo *object = (struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_lsa_TrustDomainInfoAuthInfo, "lsa_TrustDomainInfoAuthInfo", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_lsa_TrustDomainInfoAuthInfo_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_lsa_TrustDomainInfoAuthInfo_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_lsa_TrustDomainInfoAuthInfo_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_lsa_TrustDomainInfoAuthInfo_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_TrustDomainInfoAuthInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TrustDomainInfoAuthInfo",
	.tp_getset = py_lsa_TrustDomainInfoAuthInfo_getsetters,
	.tp_methods = py_lsa_TrustDomainInfoAuthInfo_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TrustDomainInfoAuthInfo_new,
};


static PyObject *py_lsa_TrustDomainInfoFullInfo_get_info_ex(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoFullInfo *object = (struct lsa_TrustDomainInfoFullInfo *)pytalloc_get_ptr(obj);
	PyObject *py_info_ex;
	py_info_ex = pytalloc_reference_ex(&lsa_TrustDomainInfoInfoEx_Type, pytalloc_get_mem_ctx(obj), &object->info_ex);
	return py_info_ex;
}

static int py_lsa_TrustDomainInfoFullInfo_set_info_ex(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoFullInfo *object = (struct lsa_TrustDomainInfoFullInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->info_ex");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoInfoEx_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->info_ex = *(struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoFullInfo_get_posix_offset(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoFullInfo *object = (struct lsa_TrustDomainInfoFullInfo *)pytalloc_get_ptr(obj);
	PyObject *py_posix_offset;
	py_posix_offset = pytalloc_reference_ex(&lsa_TrustDomainInfoPosixOffset_Type, pytalloc_get_mem_ctx(obj), &object->posix_offset);
	return py_posix_offset;
}

static int py_lsa_TrustDomainInfoFullInfo_set_posix_offset(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoFullInfo *object = (struct lsa_TrustDomainInfoFullInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->posix_offset");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoPosixOffset_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->posix_offset = *(struct lsa_TrustDomainInfoPosixOffset *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoFullInfo_get_auth_info(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoFullInfo *object = (struct lsa_TrustDomainInfoFullInfo *)pytalloc_get_ptr(obj);
	PyObject *py_auth_info;
	py_auth_info = pytalloc_reference_ex(&lsa_TrustDomainInfoAuthInfo_Type, pytalloc_get_mem_ctx(obj), &object->auth_info);
	return py_auth_info;
}

static int py_lsa_TrustDomainInfoFullInfo_set_auth_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoFullInfo *object = (struct lsa_TrustDomainInfoFullInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->auth_info");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoAuthInfo_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->auth_info = *(struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_lsa_TrustDomainInfoFullInfo_getsetters[] = {
	{
		.name = discard_const_p(char, "info_ex"),
		.get = py_lsa_TrustDomainInfoFullInfo_get_info_ex,
		.set = py_lsa_TrustDomainInfoFullInfo_set_info_ex,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoInfoEx")
	},
	{
		.name = discard_const_p(char, "posix_offset"),
		.get = py_lsa_TrustDomainInfoFullInfo_get_posix_offset,
		.set = py_lsa_TrustDomainInfoFullInfo_set_posix_offset,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoPosixOffset")
	},
	{
		.name = discard_const_p(char, "auth_info"),
		.get = py_lsa_TrustDomainInfoFullInfo_get_auth_info,
		.set = py_lsa_TrustDomainInfoFullInfo_set_auth_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoAuthInfo")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TrustDomainInfoFullInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TrustDomainInfoFullInfo, type);
}


static PyTypeObject lsa_TrustDomainInfoFullInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TrustDomainInfoFullInfo",
	.tp_getset = py_lsa_TrustDomainInfoFullInfo_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TrustDomainInfoFullInfo_new,
};


static PyObject *py_lsa_TrustDomainInfoAuthInfoInternal_get_auth_blob(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoAuthInfoInternal *object = (struct lsa_TrustDomainInfoAuthInfoInternal *)pytalloc_get_ptr(obj);
	PyObject *py_auth_blob;
	py_auth_blob = pytalloc_reference_ex(&lsa_DATA_BUF2_Type, pytalloc_get_mem_ctx(obj), &object->auth_blob);
	return py_auth_blob;
}

static int py_lsa_TrustDomainInfoAuthInfoInternal_set_auth_blob(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoAuthInfoInternal *object = (struct lsa_TrustDomainInfoAuthInfoInternal *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->auth_blob");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_DATA_BUF2_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->auth_blob = *(struct lsa_DATA_BUF2 *)pytalloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_lsa_TrustDomainInfoAuthInfoInternal_getsetters[] = {
	{
		.name = discard_const_p(char, "auth_blob"),
		.get = py_lsa_TrustDomainInfoAuthInfoInternal_get_auth_blob,
		.set = py_lsa_TrustDomainInfoAuthInfoInternal_set_auth_blob,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DATA_BUF2")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TrustDomainInfoAuthInfoInternal_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TrustDomainInfoAuthInfoInternal, type);
}


static PyTypeObject lsa_TrustDomainInfoAuthInfoInternal_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TrustDomainInfoAuthInfoInternal",
	.tp_getset = py_lsa_TrustDomainInfoAuthInfoInternal_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TrustDomainInfoAuthInfoInternal_new,
};


static PyObject *py_lsa_TrustDomainInfoFullInfoInternal_get_info_ex(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoFullInfoInternal *object = (struct lsa_TrustDomainInfoFullInfoInternal *)pytalloc_get_ptr(obj);
	PyObject *py_info_ex;
	py_info_ex = pytalloc_reference_ex(&lsa_TrustDomainInfoInfoEx_Type, pytalloc_get_mem_ctx(obj), &object->info_ex);
	return py_info_ex;
}

static int py_lsa_TrustDomainInfoFullInfoInternal_set_info_ex(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoFullInfoInternal *object = (struct lsa_TrustDomainInfoFullInfoInternal *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->info_ex");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoInfoEx_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->info_ex = *(struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoFullInfoInternal_get_posix_offset(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoFullInfoInternal *object = (struct lsa_TrustDomainInfoFullInfoInternal *)pytalloc_get_ptr(obj);
	PyObject *py_posix_offset;
	py_posix_offset = pytalloc_reference_ex(&lsa_TrustDomainInfoPosixOffset_Type, pytalloc_get_mem_ctx(obj), &object->posix_offset);
	return py_posix_offset;
}

static int py_lsa_TrustDomainInfoFullInfoInternal_set_posix_offset(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoFullInfoInternal *object = (struct lsa_TrustDomainInfoFullInfoInternal *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->posix_offset");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoPosixOffset_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->posix_offset = *(struct lsa_TrustDomainInfoPosixOffset *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoFullInfoInternal_get_auth_info(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoFullInfoInternal *object = (struct lsa_TrustDomainInfoFullInfoInternal *)pytalloc_get_ptr(obj);
	PyObject *py_auth_info;
	py_auth_info = pytalloc_reference_ex(&lsa_TrustDomainInfoAuthInfoInternal_Type, pytalloc_get_mem_ctx(obj), &object->auth_info);
	return py_auth_info;
}

static int py_lsa_TrustDomainInfoFullInfoInternal_set_auth_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoFullInfoInternal *object = (struct lsa_TrustDomainInfoFullInfoInternal *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->auth_info");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoAuthInfoInternal_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->auth_info = *(struct lsa_TrustDomainInfoAuthInfoInternal *)pytalloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_lsa_TrustDomainInfoFullInfoInternal_getsetters[] = {
	{
		.name = discard_const_p(char, "info_ex"),
		.get = py_lsa_TrustDomainInfoFullInfoInternal_get_info_ex,
		.set = py_lsa_TrustDomainInfoFullInfoInternal_set_info_ex,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoInfoEx")
	},
	{
		.name = discard_const_p(char, "posix_offset"),
		.get = py_lsa_TrustDomainInfoFullInfoInternal_get_posix_offset,
		.set = py_lsa_TrustDomainInfoFullInfoInternal_set_posix_offset,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoPosixOffset")
	},
	{
		.name = discard_const_p(char, "auth_info"),
		.get = py_lsa_TrustDomainInfoFullInfoInternal_get_auth_info,
		.set = py_lsa_TrustDomainInfoFullInfoInternal_set_auth_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoAuthInfoInternal")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TrustDomainInfoFullInfoInternal_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TrustDomainInfoFullInfoInternal, type);
}


static PyTypeObject lsa_TrustDomainInfoFullInfoInternal_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TrustDomainInfoFullInfoInternal",
	.tp_getset = py_lsa_TrustDomainInfoFullInfoInternal_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TrustDomainInfoFullInfoInternal_new,
};


static PyObject *py_lsa_TrustDomainInfoInfoEx2Internal_get_info_ex(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx2Internal *object = (struct lsa_TrustDomainInfoInfoEx2Internal *)pytalloc_get_ptr(obj);
	PyObject *py_info_ex;
	py_info_ex = pytalloc_reference_ex(&lsa_TrustDomainInfoInfoEx_Type, pytalloc_get_mem_ctx(obj), &object->info_ex);
	return py_info_ex;
}

static int py_lsa_TrustDomainInfoInfoEx2Internal_set_info_ex(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx2Internal *object = (struct lsa_TrustDomainInfoInfoEx2Internal *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->info_ex");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoInfoEx_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->info_ex = *(struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoInfoEx2Internal_get_forest_trust_length(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx2Internal *object = (struct lsa_TrustDomainInfoInfoEx2Internal *)pytalloc_get_ptr(obj);
	PyObject *py_forest_trust_length;
	py_forest_trust_length = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->forest_trust_length);
	return py_forest_trust_length;
}

static int py_lsa_TrustDomainInfoInfoEx2Internal_set_forest_trust_length(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx2Internal *object = (struct lsa_TrustDomainInfoInfoEx2Internal *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->forest_trust_length");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->forest_trust_length));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->forest_trust_length = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->forest_trust_length = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoInfoEx2Internal_get_forest_trust_data(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx2Internal *object = (struct lsa_TrustDomainInfoInfoEx2Internal *)pytalloc_get_ptr(obj);
	PyObject *py_forest_trust_data;
	if (object->forest_trust_data == NULL) {
		py_forest_trust_data = Py_None;
		Py_INCREF(py_forest_trust_data);
	} else {
		py_forest_trust_data = PyList_New(object->forest_trust_length);
		if (py_forest_trust_data == NULL) {
			return NULL;
		}
		{
			int forest_trust_data_cntr_1;
			for (forest_trust_data_cntr_1 = 0; forest_trust_data_cntr_1 < (object->forest_trust_length); forest_trust_data_cntr_1++) {
				PyObject *py_forest_trust_data_1;
				py_forest_trust_data_1 = PyInt_FromLong((uint16_t)object->forest_trust_data[forest_trust_data_cntr_1]);
				PyList_SetItem(py_forest_trust_data, forest_trust_data_cntr_1, py_forest_trust_data_1);
			}
		}
	}
	return py_forest_trust_data;
}

static int py_lsa_TrustDomainInfoInfoEx2Internal_set_forest_trust_data(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoInfoEx2Internal *object = (struct lsa_TrustDomainInfoInfoEx2Internal *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->forest_trust_data));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->forest_trust_data");
		return -1;
	}
	if (value == Py_None) {
		object->forest_trust_data = NULL;
	} else {
		object->forest_trust_data = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int forest_trust_data_cntr_1;
			object->forest_trust_data = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->forest_trust_data, PyList_GET_SIZE(value));
			if (!object->forest_trust_data) { return -1;; }
			talloc_set_name_const(object->forest_trust_data, "ARRAY: object->forest_trust_data");
			for (forest_trust_data_cntr_1 = 0; forest_trust_data_cntr_1 < PyList_GET_SIZE(value); forest_trust_data_cntr_1++) {
				if (PyList_GET_ITEM(value, forest_trust_data_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->forest_trust_data[forest_trust_data_cntr_1]");
					return -1;
				}
				{
					const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->forest_trust_data[forest_trust_data_cntr_1]));
					if (PyLong_Check(PyList_GET_ITEM(value, forest_trust_data_cntr_1))) {
						unsigned long long test_var;
						test_var = PyLong_AsUnsignedLongLong(PyList_GET_ITEM(value, forest_trust_data_cntr_1));
						if (PyErr_Occurred() != NULL) {
							return -1;
						}
						if (test_var > uint_max) {
							PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
							  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
							return -1;
						}
						object->forest_trust_data[forest_trust_data_cntr_1] = test_var;
					} else if (PyInt_Check(PyList_GET_ITEM(value, forest_trust_data_cntr_1))) {
						long test_var;
						test_var = PyInt_AsLong(PyList_GET_ITEM(value, forest_trust_data_cntr_1));
						if (test_var < 0 || test_var > uint_max) {
							PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
							  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
							return -1;
						}
						object->forest_trust_data[forest_trust_data_cntr_1] = test_var;
					} else {
						PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
						  PyInt_Type.tp_name, PyLong_Type.tp_name);
						return -1;
					}
				}
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_TrustDomainInfoInfoEx2Internal_getsetters[] = {
	{
		.name = discard_const_p(char, "info_ex"),
		.get = py_lsa_TrustDomainInfoInfoEx2Internal_get_info_ex,
		.set = py_lsa_TrustDomainInfoInfoEx2Internal_set_info_ex,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoInfoEx")
	},
	{
		.name = discard_const_p(char, "forest_trust_length"),
		.get = py_lsa_TrustDomainInfoInfoEx2Internal_get_forest_trust_length,
		.set = py_lsa_TrustDomainInfoInfoEx2Internal_set_forest_trust_length,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "forest_trust_data"),
		.get = py_lsa_TrustDomainInfoInfoEx2Internal_get_forest_trust_data,
		.set = py_lsa_TrustDomainInfoInfoEx2Internal_set_forest_trust_data,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TrustDomainInfoInfoEx2Internal_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TrustDomainInfoInfoEx2Internal, type);
}


static PyTypeObject lsa_TrustDomainInfoInfoEx2Internal_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TrustDomainInfoInfoEx2Internal",
	.tp_getset = py_lsa_TrustDomainInfoInfoEx2Internal_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TrustDomainInfoInfoEx2Internal_new,
};


static PyObject *py_lsa_TrustDomainInfoFullInfo2Internal_get_info(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoFullInfo2Internal *object = (struct lsa_TrustDomainInfoFullInfo2Internal *)pytalloc_get_ptr(obj);
	PyObject *py_info;
	py_info = pytalloc_reference_ex(&lsa_TrustDomainInfoInfoEx2Internal_Type, pytalloc_get_mem_ctx(obj), &object->info);
	return py_info;
}

static int py_lsa_TrustDomainInfoFullInfo2Internal_set_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoFullInfo2Internal *object = (struct lsa_TrustDomainInfoFullInfo2Internal *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->info");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoInfoEx2Internal_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->info = *(struct lsa_TrustDomainInfoInfoEx2Internal *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoFullInfo2Internal_get_posix_offset(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoFullInfo2Internal *object = (struct lsa_TrustDomainInfoFullInfo2Internal *)pytalloc_get_ptr(obj);
	PyObject *py_posix_offset;
	py_posix_offset = pytalloc_reference_ex(&lsa_TrustDomainInfoPosixOffset_Type, pytalloc_get_mem_ctx(obj), &object->posix_offset);
	return py_posix_offset;
}

static int py_lsa_TrustDomainInfoFullInfo2Internal_set_posix_offset(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoFullInfo2Internal *object = (struct lsa_TrustDomainInfoFullInfo2Internal *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->posix_offset");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoPosixOffset_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->posix_offset = *(struct lsa_TrustDomainInfoPosixOffset *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_TrustDomainInfoFullInfo2Internal_get_auth_info(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoFullInfo2Internal *object = (struct lsa_TrustDomainInfoFullInfo2Internal *)pytalloc_get_ptr(obj);
	PyObject *py_auth_info;
	py_auth_info = pytalloc_reference_ex(&lsa_TrustDomainInfoAuthInfo_Type, pytalloc_get_mem_ctx(obj), &object->auth_info);
	return py_auth_info;
}

static int py_lsa_TrustDomainInfoFullInfo2Internal_set_auth_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoFullInfo2Internal *object = (struct lsa_TrustDomainInfoFullInfo2Internal *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->auth_info");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoAuthInfo_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->auth_info = *(struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_lsa_TrustDomainInfoFullInfo2Internal_getsetters[] = {
	{
		.name = discard_const_p(char, "info"),
		.get = py_lsa_TrustDomainInfoFullInfo2Internal_get_info,
		.set = py_lsa_TrustDomainInfoFullInfo2Internal_set_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoInfoEx2Internal")
	},
	{
		.name = discard_const_p(char, "posix_offset"),
		.get = py_lsa_TrustDomainInfoFullInfo2Internal_get_posix_offset,
		.set = py_lsa_TrustDomainInfoFullInfo2Internal_set_posix_offset,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoPosixOffset")
	},
	{
		.name = discard_const_p(char, "auth_info"),
		.get = py_lsa_TrustDomainInfoFullInfo2Internal_get_auth_info,
		.set = py_lsa_TrustDomainInfoFullInfo2Internal_set_auth_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoAuthInfo")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TrustDomainInfoFullInfo2Internal_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TrustDomainInfoFullInfo2Internal, type);
}


static PyTypeObject lsa_TrustDomainInfoFullInfo2Internal_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TrustDomainInfoFullInfo2Internal",
	.tp_getset = py_lsa_TrustDomainInfoFullInfo2Internal_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TrustDomainInfoFullInfo2Internal_new,
};


static PyObject *py_lsa_TrustDomainInfoSupportedEncTypes_get_enc_types(PyObject *obj, void *closure)
{
	struct lsa_TrustDomainInfoSupportedEncTypes *object = (struct lsa_TrustDomainInfoSupportedEncTypes *)pytalloc_get_ptr(obj);
	PyObject *py_enc_types;
	py_enc_types = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->enc_types);
	return py_enc_types;
}

static int py_lsa_TrustDomainInfoSupportedEncTypes_set_enc_types(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TrustDomainInfoSupportedEncTypes *object = (struct lsa_TrustDomainInfoSupportedEncTypes *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->enc_types");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->enc_types));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->enc_types = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->enc_types = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_TrustDomainInfoSupportedEncTypes_getsetters[] = {
	{
		.name = discard_const_p(char, "enc_types"),
		.get = py_lsa_TrustDomainInfoSupportedEncTypes_get_enc_types,
		.set = py_lsa_TrustDomainInfoSupportedEncTypes_set_enc_types,
		.doc = discard_const_p(char, "PIDL-generated element of base type kerb_EncTypes")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TrustDomainInfoSupportedEncTypes_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TrustDomainInfoSupportedEncTypes, type);
}


static PyTypeObject lsa_TrustDomainInfoSupportedEncTypes_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TrustDomainInfoSupportedEncTypes",
	.tp_getset = py_lsa_TrustDomainInfoSupportedEncTypes_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TrustDomainInfoSupportedEncTypes_new,
};

static PyObject *py_import_lsa_TrustedDomainInfo(TALLOC_CTX *mem_ctx, int level, union lsa_TrustedDomainInfo *in)
{
	PyObject *ret;

	switch (level) {
		case LSA_TRUSTED_DOMAIN_INFO_NAME:
			ret = pytalloc_reference_ex(&lsa_TrustDomainInfoName_Type, mem_ctx, &in->name);
			return ret;

		case LSA_TRUSTED_DOMAIN_INFO_CONTROLLERS:
			ret = pytalloc_reference_ex(&lsa_TrustDomainInfoControllers_Type, mem_ctx, &in->controllers);
			return ret;

		case LSA_TRUSTED_DOMAIN_INFO_POSIX_OFFSET:
			ret = pytalloc_reference_ex(&lsa_TrustDomainInfoPosixOffset_Type, mem_ctx, &in->posix_offset);
			return ret;

		case LSA_TRUSTED_DOMAIN_INFO_PASSWORD:
			ret = pytalloc_reference_ex(&lsa_TrustDomainInfoPassword_Type, mem_ctx, &in->password);
			return ret;

		case LSA_TRUSTED_DOMAIN_INFO_BASIC:
			ret = pytalloc_reference_ex(&lsa_TrustDomainInfoBasic_Type, mem_ctx, &in->info_basic);
			return ret;

		case LSA_TRUSTED_DOMAIN_INFO_INFO_EX:
			ret = pytalloc_reference_ex(&lsa_TrustDomainInfoInfoEx_Type, mem_ctx, &in->info_ex);
			return ret;

		case LSA_TRUSTED_DOMAIN_INFO_AUTH_INFO:
			ret = pytalloc_reference_ex(&lsa_TrustDomainInfoAuthInfo_Type, mem_ctx, &in->auth_info);
			return ret;

		case LSA_TRUSTED_DOMAIN_INFO_FULL_INFO:
			ret = pytalloc_reference_ex(&lsa_TrustDomainInfoFullInfo_Type, mem_ctx, &in->full_info);
			return ret;

		case LSA_TRUSTED_DOMAIN_INFO_AUTH_INFO_INTERNAL:
			ret = pytalloc_reference_ex(&lsa_TrustDomainInfoAuthInfoInternal_Type, mem_ctx, &in->auth_info_internal);
			return ret;

		case LSA_TRUSTED_DOMAIN_INFO_FULL_INFO_INTERNAL:
			ret = pytalloc_reference_ex(&lsa_TrustDomainInfoFullInfoInternal_Type, mem_ctx, &in->full_info_internal);
			return ret;

		case LSA_TRUSTED_DOMAIN_INFO_INFO_EX2_INTERNAL:
			ret = pytalloc_reference_ex(&lsa_TrustDomainInfoInfoEx2Internal_Type, mem_ctx, &in->info_ex2_internal);
			return ret;

		case LSA_TRUSTED_DOMAIN_INFO_FULL_INFO_2_INTERNAL:
			ret = pytalloc_reference_ex(&lsa_TrustDomainInfoFullInfo2Internal_Type, mem_ctx, &in->full_info2_internal);
			return ret;

		case LSA_TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES:
			ret = pytalloc_reference_ex(&lsa_TrustDomainInfoSupportedEncTypes_Type, mem_ctx, &in->enc_types);
			return ret;

	}
	PyErr_SetString(PyExc_TypeError, "unknown union level");
	return NULL;
}

static union lsa_TrustedDomainInfo *py_export_lsa_TrustedDomainInfo(TALLOC_CTX *mem_ctx, int level, PyObject *in)
{
	union lsa_TrustedDomainInfo *ret = talloc_zero(mem_ctx, union lsa_TrustedDomainInfo);
	switch (level) {
		case LSA_TRUSTED_DOMAIN_INFO_NAME:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->name");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_TrustDomainInfoName_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->name = *(struct lsa_TrustDomainInfoName *)pytalloc_get_ptr(in);
			break;

		case LSA_TRUSTED_DOMAIN_INFO_CONTROLLERS:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->controllers");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_TrustDomainInfoControllers_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->controllers = *(struct lsa_TrustDomainInfoControllers *)pytalloc_get_ptr(in);
			break;

		case LSA_TRUSTED_DOMAIN_INFO_POSIX_OFFSET:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->posix_offset");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_TrustDomainInfoPosixOffset_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->posix_offset = *(struct lsa_TrustDomainInfoPosixOffset *)pytalloc_get_ptr(in);
			break;

		case LSA_TRUSTED_DOMAIN_INFO_PASSWORD:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->password");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_TrustDomainInfoPassword_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->password = *(struct lsa_TrustDomainInfoPassword *)pytalloc_get_ptr(in);
			break;

		case LSA_TRUSTED_DOMAIN_INFO_BASIC:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->info_basic");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_TrustDomainInfoBasic_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->info_basic = *(struct lsa_TrustDomainInfoBasic *)pytalloc_get_ptr(in);
			break;

		case LSA_TRUSTED_DOMAIN_INFO_INFO_EX:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->info_ex");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_TrustDomainInfoInfoEx_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->info_ex = *(struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(in);
			break;

		case LSA_TRUSTED_DOMAIN_INFO_AUTH_INFO:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->auth_info");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_TrustDomainInfoAuthInfo_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->auth_info = *(struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(in);
			break;

		case LSA_TRUSTED_DOMAIN_INFO_FULL_INFO:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->full_info");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_TrustDomainInfoFullInfo_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->full_info = *(struct lsa_TrustDomainInfoFullInfo *)pytalloc_get_ptr(in);
			break;

		case LSA_TRUSTED_DOMAIN_INFO_AUTH_INFO_INTERNAL:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->auth_info_internal");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_TrustDomainInfoAuthInfoInternal_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->auth_info_internal = *(struct lsa_TrustDomainInfoAuthInfoInternal *)pytalloc_get_ptr(in);
			break;

		case LSA_TRUSTED_DOMAIN_INFO_FULL_INFO_INTERNAL:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->full_info_internal");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_TrustDomainInfoFullInfoInternal_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->full_info_internal = *(struct lsa_TrustDomainInfoFullInfoInternal *)pytalloc_get_ptr(in);
			break;

		case LSA_TRUSTED_DOMAIN_INFO_INFO_EX2_INTERNAL:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->info_ex2_internal");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_TrustDomainInfoInfoEx2Internal_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->info_ex2_internal = *(struct lsa_TrustDomainInfoInfoEx2Internal *)pytalloc_get_ptr(in);
			break;

		case LSA_TRUSTED_DOMAIN_INFO_FULL_INFO_2_INTERNAL:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->full_info2_internal");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_TrustDomainInfoFullInfo2Internal_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->full_info2_internal = *(struct lsa_TrustDomainInfoFullInfo2Internal *)pytalloc_get_ptr(in);
			break;

		case LSA_TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->enc_types");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_TrustDomainInfoSupportedEncTypes_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->enc_types = *(struct lsa_TrustDomainInfoSupportedEncTypes *)pytalloc_get_ptr(in);
			break;

		default:
			PyErr_SetString(PyExc_TypeError, "invalid union level value");
			talloc_free(ret);
			ret = NULL;
	}

	return ret;
}

static PyObject *py_lsa_TrustedDomainInfo_import(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "mem_ctx", "level", "in", NULL };
	PyObject *mem_ctx_obj = NULL;
	TALLOC_CTX *mem_ctx = NULL;
	int level = 0;
	PyObject *in_obj = NULL;
	union lsa_TrustedDomainInfo *in = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiO:import",
		discard_const_p(char *, kwnames),
		&mem_ctx_obj,
		&level,
		&in_obj)) {
		return NULL;
	}
	mem_ctx = pytalloc_get_ptr(mem_ctx_obj);
	if (mem_ctx == NULL) {
		PyErr_SetString(PyExc_TypeError, "mem_ctx is NULL)!");
		return NULL;
	}
	in = (union lsa_TrustedDomainInfo *)pytalloc_get_ptr(in_obj);
	if (in == NULL) {
		PyErr_Format(PyExc_TypeError, "in needs to be a pointer to union lsa_TrustedDomainInfo!");
		return NULL;
	}

	return py_import_lsa_TrustedDomainInfo(mem_ctx, level, in);
}

static PyObject *py_lsa_TrustedDomainInfo_export(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "mem_ctx", "level", "in", NULL };
	PyObject *mem_ctx_obj = NULL;
	TALLOC_CTX *mem_ctx = NULL;
	int level = 0;
	PyObject *in = NULL;
	union lsa_TrustedDomainInfo *out = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiO:import",
		discard_const_p(char *, kwnames),
		&mem_ctx_obj,
		&level,
		&in)) {
		return NULL;
	}
	mem_ctx = pytalloc_get_ptr(mem_ctx_obj);
	if (mem_ctx == NULL) {
		PyErr_SetString(PyExc_TypeError, "mem_ctx is NULL)!");
		return NULL;
	}

	out = py_export_lsa_TrustedDomainInfo(mem_ctx, level, in);
	if (out == NULL) {
		return NULL;
	}

	return pytalloc_GenericObject_reference(out);
}

static PyMethodDef py_lsa_TrustedDomainInfo_methods[] = {
	{ "__import__", (PyCFunction)py_lsa_TrustedDomainInfo_import,
		METH_VARARGS|METH_KEYWORDS|METH_CLASS,
		"T.__import__(mem_ctx, level, in) => ret." },
	{ "__export__", (PyCFunction)py_lsa_TrustedDomainInfo_export,
		METH_VARARGS|METH_KEYWORDS|METH_CLASS,
		"T.__export__(mem_ctx, level, in) => ret." },
	{ NULL, NULL, 0, NULL }
};

static PyObject *py_lsa_TrustedDomainInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	PyErr_Format(PyExc_TypeError, "New %s Objects are not supported", type->tp_name);
	return NULL;
}


static PyTypeObject lsa_TrustedDomainInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TrustedDomainInfo",
	.tp_getset = NULL,
	.tp_methods = py_lsa_TrustedDomainInfo_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TrustedDomainInfo_new,
};


static PyObject *py_lsa_DATA_BUF_PTR_get_buf(PyObject *obj, void *closure)
{
	struct lsa_DATA_BUF_PTR *object = (struct lsa_DATA_BUF_PTR *)pytalloc_get_ptr(obj);
	PyObject *py_buf;
	if (object->buf == NULL) {
		py_buf = Py_None;
		Py_INCREF(py_buf);
	} else {
		py_buf = pytalloc_reference_ex(&lsa_DATA_BUF_Type, object->buf, object->buf);
	}
	return py_buf;
}

static int py_lsa_DATA_BUF_PTR_set_buf(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DATA_BUF_PTR *object = (struct lsa_DATA_BUF_PTR *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->buf));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->buf");
		return -1;
	}
	if (value == Py_None) {
		object->buf = NULL;
	} else {
		object->buf = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->buf = (struct lsa_DATA_BUF *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyGetSetDef py_lsa_DATA_BUF_PTR_getsetters[] = {
	{
		.name = discard_const_p(char, "buf"),
		.get = py_lsa_DATA_BUF_PTR_get_buf,
		.set = py_lsa_DATA_BUF_PTR_set_buf,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DATA_BUF")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_DATA_BUF_PTR_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_DATA_BUF_PTR, type);
}


static PyTypeObject lsa_DATA_BUF_PTR_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.DATA_BUF_PTR",
	.tp_getset = py_lsa_DATA_BUF_PTR_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_DATA_BUF_PTR_new,
};


static PyObject *py_lsa_RightAttribute_get_name(PyObject *obj, void *closure)
{
	struct lsa_RightAttribute *object = (struct lsa_RightAttribute *)pytalloc_get_ptr(obj);
	PyObject *py_name;
	if (object->name == NULL) {
		py_name = Py_None;
		Py_INCREF(py_name);
	} else {
		if (object->name == NULL) {
			py_name = Py_None;
			Py_INCREF(py_name);
		} else {
			py_name = PyUnicode_Decode(object->name, strlen(object->name), "utf-8", "ignore");
		}
	}
	return py_name;
}

static int py_lsa_RightAttribute_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RightAttribute *object = (struct lsa_RightAttribute *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->name");
		return -1;
	}
	if (value == Py_None) {
		object->name = NULL;
	} else {
		object->name = NULL;
		{
			const char *test_str;
			const char *talloc_str;
			PyObject *unicode = NULL;
			if (PyUnicode_Check(value)) {
				unicode = PyUnicode_AsEncodedString(value, "utf-8", "ignore");
				if (unicode == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				test_str = PyBytes_AS_STRING(unicode);
			} else if (PyBytes_Check(value)) {
				test_str = PyBytes_AS_STRING(value);
			} else {
				PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
				return -1;
			}
			talloc_str = talloc_strdup(pytalloc_get_mem_ctx(py_obj), test_str);
			if (unicode != NULL) {
				Py_DECREF(unicode);
			}
			if (talloc_str == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->name = talloc_str;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_RightAttribute_getsetters[] = {
	{
		.name = discard_const_p(char, "name"),
		.get = py_lsa_RightAttribute_get_name,
		.set = py_lsa_RightAttribute_set_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_RightAttribute_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_RightAttribute, type);
}


static PyTypeObject lsa_RightAttribute_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.RightAttribute",
	.tp_getset = py_lsa_RightAttribute_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_RightAttribute_new,
};


static PyObject *py_lsa_RightSet_get_count(PyObject *obj, void *closure)
{
	struct lsa_RightSet *object = (struct lsa_RightSet *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->count);
	return py_count;
}

static int py_lsa_RightSet_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RightSet *object = (struct lsa_RightSet *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_RightSet_get_names(PyObject *obj, void *closure)
{
	struct lsa_RightSet *object = (struct lsa_RightSet *)pytalloc_get_ptr(obj);
	PyObject *py_names;
	if (object->names == NULL) {
		py_names = Py_None;
		Py_INCREF(py_names);
	} else {
		py_names = PyList_New(object->count);
		if (py_names == NULL) {
			return NULL;
		}
		{
			int names_cntr_1;
			for (names_cntr_1 = 0; names_cntr_1 < (object->count); names_cntr_1++) {
				PyObject *py_names_1;
				py_names_1 = pytalloc_reference_ex(&lsa_StringLarge_Type, object->names, &object->names[names_cntr_1]);
				PyList_SetItem(py_names, names_cntr_1, py_names_1);
			}
		}
	}
	return py_names;
}

static int py_lsa_RightSet_set_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RightSet *object = (struct lsa_RightSet *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->names));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->names");
		return -1;
	}
	if (value == Py_None) {
		object->names = NULL;
	} else {
		object->names = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int names_cntr_1;
			object->names = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->names, PyList_GET_SIZE(value));
			if (!object->names) { return -1;; }
			talloc_set_name_const(object->names, "ARRAY: object->names");
			for (names_cntr_1 = 0; names_cntr_1 < PyList_GET_SIZE(value); names_cntr_1++) {
				if (PyList_GET_ITEM(value, names_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->names[names_cntr_1]");
					return -1;
				}
				PY_CHECK_TYPE(&lsa_StringLarge_Type, PyList_GET_ITEM(value, names_cntr_1), return -1;);
				if (talloc_reference(object->names, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, names_cntr_1))) == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				object->names[names_cntr_1] = *(struct lsa_StringLarge *)pytalloc_get_ptr(PyList_GET_ITEM(value, names_cntr_1));
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_RightSet_getsetters[] = {
	{
		.name = discard_const_p(char, "count"),
		.get = py_lsa_RightSet_get_count,
		.set = py_lsa_RightSet_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "names"),
		.get = py_lsa_RightSet_get_names,
		.set = py_lsa_RightSet_set_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_StringLarge")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_RightSet_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_RightSet, type);
}


static PyTypeObject lsa_RightSet_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.RightSet",
	.tp_getset = py_lsa_RightSet_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_RightSet_new,
};


static PyObject *py_lsa_DomainListEx_get_count(PyObject *obj, void *closure)
{
	struct lsa_DomainListEx *object = (struct lsa_DomainListEx *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->count);
	return py_count;
}

static int py_lsa_DomainListEx_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DomainListEx *object = (struct lsa_DomainListEx *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_DomainListEx_get_domains(PyObject *obj, void *closure)
{
	struct lsa_DomainListEx *object = (struct lsa_DomainListEx *)pytalloc_get_ptr(obj);
	PyObject *py_domains;
	if (object->domains == NULL) {
		py_domains = Py_None;
		Py_INCREF(py_domains);
	} else {
		py_domains = PyList_New(object->count);
		if (py_domains == NULL) {
			return NULL;
		}
		{
			int domains_cntr_1;
			for (domains_cntr_1 = 0; domains_cntr_1 < (object->count); domains_cntr_1++) {
				PyObject *py_domains_1;
				py_domains_1 = pytalloc_reference_ex(&lsa_TrustDomainInfoInfoEx_Type, object->domains, &object->domains[domains_cntr_1]);
				PyList_SetItem(py_domains, domains_cntr_1, py_domains_1);
			}
		}
	}
	return py_domains;
}

static int py_lsa_DomainListEx_set_domains(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DomainListEx *object = (struct lsa_DomainListEx *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->domains));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->domains");
		return -1;
	}
	if (value == Py_None) {
		object->domains = NULL;
	} else {
		object->domains = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int domains_cntr_1;
			object->domains = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->domains, PyList_GET_SIZE(value));
			if (!object->domains) { return -1;; }
			talloc_set_name_const(object->domains, "ARRAY: object->domains");
			for (domains_cntr_1 = 0; domains_cntr_1 < PyList_GET_SIZE(value); domains_cntr_1++) {
				if (PyList_GET_ITEM(value, domains_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->domains[domains_cntr_1]");
					return -1;
				}
				PY_CHECK_TYPE(&lsa_TrustDomainInfoInfoEx_Type, PyList_GET_ITEM(value, domains_cntr_1), return -1;);
				if (talloc_reference(object->domains, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, domains_cntr_1))) == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				object->domains[domains_cntr_1] = *(struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(PyList_GET_ITEM(value, domains_cntr_1));
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_DomainListEx_getsetters[] = {
	{
		.name = discard_const_p(char, "count"),
		.get = py_lsa_DomainListEx_get_count,
		.set = py_lsa_DomainListEx_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "domains"),
		.get = py_lsa_DomainListEx_get_domains,
		.set = py_lsa_DomainListEx_set_domains,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoInfoEx")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_DomainListEx_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_DomainListEx, type);
}


static PyTypeObject lsa_DomainListEx_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.DomainListEx",
	.tp_getset = py_lsa_DomainListEx_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_DomainListEx_new,
};


static PyObject *py_lsa_DomainInfoKerberos_get_authentication_options(PyObject *obj, void *closure)
{
	struct lsa_DomainInfoKerberos *object = (struct lsa_DomainInfoKerberos *)pytalloc_get_ptr(obj);
	PyObject *py_authentication_options;
	py_authentication_options = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->authentication_options);
	return py_authentication_options;
}

static int py_lsa_DomainInfoKerberos_set_authentication_options(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DomainInfoKerberos *object = (struct lsa_DomainInfoKerberos *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->authentication_options");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->authentication_options));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->authentication_options = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->authentication_options = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_DomainInfoKerberos_get_service_tkt_lifetime(PyObject *obj, void *closure)
{
	struct lsa_DomainInfoKerberos *object = (struct lsa_DomainInfoKerberos *)pytalloc_get_ptr(obj);
	PyObject *py_service_tkt_lifetime;
	py_service_tkt_lifetime = ndr_PyLong_FromUnsignedLongLong(object->service_tkt_lifetime);
	return py_service_tkt_lifetime;
}

static int py_lsa_DomainInfoKerberos_set_service_tkt_lifetime(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DomainInfoKerberos *object = (struct lsa_DomainInfoKerberos *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->service_tkt_lifetime");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->service_tkt_lifetime));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->service_tkt_lifetime = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->service_tkt_lifetime = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_DomainInfoKerberos_get_user_tkt_lifetime(PyObject *obj, void *closure)
{
	struct lsa_DomainInfoKerberos *object = (struct lsa_DomainInfoKerberos *)pytalloc_get_ptr(obj);
	PyObject *py_user_tkt_lifetime;
	py_user_tkt_lifetime = ndr_PyLong_FromUnsignedLongLong(object->user_tkt_lifetime);
	return py_user_tkt_lifetime;
}

static int py_lsa_DomainInfoKerberos_set_user_tkt_lifetime(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DomainInfoKerberos *object = (struct lsa_DomainInfoKerberos *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->user_tkt_lifetime");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->user_tkt_lifetime));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->user_tkt_lifetime = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->user_tkt_lifetime = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_DomainInfoKerberos_get_user_tkt_renewaltime(PyObject *obj, void *closure)
{
	struct lsa_DomainInfoKerberos *object = (struct lsa_DomainInfoKerberos *)pytalloc_get_ptr(obj);
	PyObject *py_user_tkt_renewaltime;
	py_user_tkt_renewaltime = ndr_PyLong_FromUnsignedLongLong(object->user_tkt_renewaltime);
	return py_user_tkt_renewaltime;
}

static int py_lsa_DomainInfoKerberos_set_user_tkt_renewaltime(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DomainInfoKerberos *object = (struct lsa_DomainInfoKerberos *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->user_tkt_renewaltime");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->user_tkt_renewaltime));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->user_tkt_renewaltime = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->user_tkt_renewaltime = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_DomainInfoKerberos_get_clock_skew(PyObject *obj, void *closure)
{
	struct lsa_DomainInfoKerberos *object = (struct lsa_DomainInfoKerberos *)pytalloc_get_ptr(obj);
	PyObject *py_clock_skew;
	py_clock_skew = ndr_PyLong_FromUnsignedLongLong(object->clock_skew);
	return py_clock_skew;
}

static int py_lsa_DomainInfoKerberos_set_clock_skew(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DomainInfoKerberos *object = (struct lsa_DomainInfoKerberos *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->clock_skew");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->clock_skew));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->clock_skew = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->clock_skew = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_DomainInfoKerberos_get_reserved(PyObject *obj, void *closure)
{
	struct lsa_DomainInfoKerberos *object = (struct lsa_DomainInfoKerberos *)pytalloc_get_ptr(obj);
	PyObject *py_reserved;
	py_reserved = ndr_PyLong_FromUnsignedLongLong(object->reserved);
	return py_reserved;
}

static int py_lsa_DomainInfoKerberos_set_reserved(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DomainInfoKerberos *object = (struct lsa_DomainInfoKerberos *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->reserved");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->reserved));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->reserved = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->reserved = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_DomainInfoKerberos_getsetters[] = {
	{
		.name = discard_const_p(char, "authentication_options"),
		.get = py_lsa_DomainInfoKerberos_get_authentication_options,
		.set = py_lsa_DomainInfoKerberos_set_authentication_options,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_krbAuthenticationOptions")
	},
	{
		.name = discard_const_p(char, "service_tkt_lifetime"),
		.get = py_lsa_DomainInfoKerberos_get_service_tkt_lifetime,
		.set = py_lsa_DomainInfoKerberos_set_service_tkt_lifetime,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{
		.name = discard_const_p(char, "user_tkt_lifetime"),
		.get = py_lsa_DomainInfoKerberos_get_user_tkt_lifetime,
		.set = py_lsa_DomainInfoKerberos_set_user_tkt_lifetime,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{
		.name = discard_const_p(char, "user_tkt_renewaltime"),
		.get = py_lsa_DomainInfoKerberos_get_user_tkt_renewaltime,
		.set = py_lsa_DomainInfoKerberos_set_user_tkt_renewaltime,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{
		.name = discard_const_p(char, "clock_skew"),
		.get = py_lsa_DomainInfoKerberos_get_clock_skew,
		.set = py_lsa_DomainInfoKerberos_set_clock_skew,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{
		.name = discard_const_p(char, "reserved"),
		.get = py_lsa_DomainInfoKerberos_get_reserved,
		.set = py_lsa_DomainInfoKerberos_set_reserved,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_DomainInfoKerberos_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_DomainInfoKerberos, type);
}


static PyTypeObject lsa_DomainInfoKerberos_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.DomainInfoKerberos",
	.tp_getset = py_lsa_DomainInfoKerberos_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_DomainInfoKerberos_new,
};


static PyObject *py_lsa_DomainInfoEfs_get_blob_size(PyObject *obj, void *closure)
{
	struct lsa_DomainInfoEfs *object = (struct lsa_DomainInfoEfs *)pytalloc_get_ptr(obj);
	PyObject *py_blob_size;
	py_blob_size = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->blob_size);
	return py_blob_size;
}

static int py_lsa_DomainInfoEfs_set_blob_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DomainInfoEfs *object = (struct lsa_DomainInfoEfs *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->blob_size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->blob_size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->blob_size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->blob_size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_DomainInfoEfs_get_efs_blob(PyObject *obj, void *closure)
{
	struct lsa_DomainInfoEfs *object = (struct lsa_DomainInfoEfs *)pytalloc_get_ptr(obj);
	PyObject *py_efs_blob;
	if (object->efs_blob == NULL) {
		py_efs_blob = Py_None;
		Py_INCREF(py_efs_blob);
	} else {
		py_efs_blob = PyList_New(object->blob_size);
		if (py_efs_blob == NULL) {
			return NULL;
		}
		{
			int efs_blob_cntr_1;
			for (efs_blob_cntr_1 = 0; efs_blob_cntr_1 < (object->blob_size); efs_blob_cntr_1++) {
				PyObject *py_efs_blob_1;
				py_efs_blob_1 = PyInt_FromLong((uint16_t)object->efs_blob[efs_blob_cntr_1]);
				PyList_SetItem(py_efs_blob, efs_blob_cntr_1, py_efs_blob_1);
			}
		}
	}
	return py_efs_blob;
}

static int py_lsa_DomainInfoEfs_set_efs_blob(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DomainInfoEfs *object = (struct lsa_DomainInfoEfs *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->efs_blob));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->efs_blob");
		return -1;
	}
	if (value == Py_None) {
		object->efs_blob = NULL;
	} else {
		object->efs_blob = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int efs_blob_cntr_1;
			object->efs_blob = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->efs_blob, PyList_GET_SIZE(value));
			if (!object->efs_blob) { return -1;; }
			talloc_set_name_const(object->efs_blob, "ARRAY: object->efs_blob");
			for (efs_blob_cntr_1 = 0; efs_blob_cntr_1 < PyList_GET_SIZE(value); efs_blob_cntr_1++) {
				if (PyList_GET_ITEM(value, efs_blob_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->efs_blob[efs_blob_cntr_1]");
					return -1;
				}
				{
					const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->efs_blob[efs_blob_cntr_1]));
					if (PyLong_Check(PyList_GET_ITEM(value, efs_blob_cntr_1))) {
						unsigned long long test_var;
						test_var = PyLong_AsUnsignedLongLong(PyList_GET_ITEM(value, efs_blob_cntr_1));
						if (PyErr_Occurred() != NULL) {
							return -1;
						}
						if (test_var > uint_max) {
							PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
							  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
							return -1;
						}
						object->efs_blob[efs_blob_cntr_1] = test_var;
					} else if (PyInt_Check(PyList_GET_ITEM(value, efs_blob_cntr_1))) {
						long test_var;
						test_var = PyInt_AsLong(PyList_GET_ITEM(value, efs_blob_cntr_1));
						if (test_var < 0 || test_var > uint_max) {
							PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
							  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
							return -1;
						}
						object->efs_blob[efs_blob_cntr_1] = test_var;
					} else {
						PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
						  PyInt_Type.tp_name, PyLong_Type.tp_name);
						return -1;
					}
				}
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_DomainInfoEfs_getsetters[] = {
	{
		.name = discard_const_p(char, "blob_size"),
		.get = py_lsa_DomainInfoEfs_get_blob_size,
		.set = py_lsa_DomainInfoEfs_set_blob_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "efs_blob"),
		.get = py_lsa_DomainInfoEfs_get_efs_blob,
		.set = py_lsa_DomainInfoEfs_set_efs_blob,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_DomainInfoEfs_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_DomainInfoEfs, type);
}


static PyTypeObject lsa_DomainInfoEfs_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.DomainInfoEfs",
	.tp_getset = py_lsa_DomainInfoEfs_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_DomainInfoEfs_new,
};

static PyObject *py_import_lsa_DomainInformationPolicy(TALLOC_CTX *mem_ctx, int level, union lsa_DomainInformationPolicy *in)
{
	PyObject *ret;

	switch (level) {
		case LSA_DOMAIN_INFO_POLICY_EFS:
			ret = pytalloc_reference_ex(&lsa_DomainInfoEfs_Type, mem_ctx, &in->efs_info);
			return ret;

		case LSA_DOMAIN_INFO_POLICY_KERBEROS:
			ret = pytalloc_reference_ex(&lsa_DomainInfoKerberos_Type, mem_ctx, &in->kerberos_info);
			return ret;

	}
	PyErr_SetString(PyExc_TypeError, "unknown union level");
	return NULL;
}

static union lsa_DomainInformationPolicy *py_export_lsa_DomainInformationPolicy(TALLOC_CTX *mem_ctx, int level, PyObject *in)
{
	union lsa_DomainInformationPolicy *ret = talloc_zero(mem_ctx, union lsa_DomainInformationPolicy);
	switch (level) {
		case LSA_DOMAIN_INFO_POLICY_EFS:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->efs_info");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_DomainInfoEfs_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->efs_info = *(struct lsa_DomainInfoEfs *)pytalloc_get_ptr(in);
			break;

		case LSA_DOMAIN_INFO_POLICY_KERBEROS:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->kerberos_info");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_DomainInfoKerberos_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->kerberos_info = *(struct lsa_DomainInfoKerberos *)pytalloc_get_ptr(in);
			break;

		default:
			PyErr_SetString(PyExc_TypeError, "invalid union level value");
			talloc_free(ret);
			ret = NULL;
	}

	return ret;
}

static PyObject *py_lsa_DomainInformationPolicy_import(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "mem_ctx", "level", "in", NULL };
	PyObject *mem_ctx_obj = NULL;
	TALLOC_CTX *mem_ctx = NULL;
	int level = 0;
	PyObject *in_obj = NULL;
	union lsa_DomainInformationPolicy *in = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiO:import",
		discard_const_p(char *, kwnames),
		&mem_ctx_obj,
		&level,
		&in_obj)) {
		return NULL;
	}
	mem_ctx = pytalloc_get_ptr(mem_ctx_obj);
	if (mem_ctx == NULL) {
		PyErr_SetString(PyExc_TypeError, "mem_ctx is NULL)!");
		return NULL;
	}
	in = (union lsa_DomainInformationPolicy *)pytalloc_get_ptr(in_obj);
	if (in == NULL) {
		PyErr_Format(PyExc_TypeError, "in needs to be a pointer to union lsa_DomainInformationPolicy!");
		return NULL;
	}

	return py_import_lsa_DomainInformationPolicy(mem_ctx, level, in);
}

static PyObject *py_lsa_DomainInformationPolicy_export(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "mem_ctx", "level", "in", NULL };
	PyObject *mem_ctx_obj = NULL;
	TALLOC_CTX *mem_ctx = NULL;
	int level = 0;
	PyObject *in = NULL;
	union lsa_DomainInformationPolicy *out = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiO:import",
		discard_const_p(char *, kwnames),
		&mem_ctx_obj,
		&level,
		&in)) {
		return NULL;
	}
	mem_ctx = pytalloc_get_ptr(mem_ctx_obj);
	if (mem_ctx == NULL) {
		PyErr_SetString(PyExc_TypeError, "mem_ctx is NULL)!");
		return NULL;
	}

	out = py_export_lsa_DomainInformationPolicy(mem_ctx, level, in);
	if (out == NULL) {
		return NULL;
	}

	return pytalloc_GenericObject_reference(out);
}

static PyMethodDef py_lsa_DomainInformationPolicy_methods[] = {
	{ "__import__", (PyCFunction)py_lsa_DomainInformationPolicy_import,
		METH_VARARGS|METH_KEYWORDS|METH_CLASS,
		"T.__import__(mem_ctx, level, in) => ret." },
	{ "__export__", (PyCFunction)py_lsa_DomainInformationPolicy_export,
		METH_VARARGS|METH_KEYWORDS|METH_CLASS,
		"T.__export__(mem_ctx, level, in) => ret." },
	{ NULL, NULL, 0, NULL }
};

static PyObject *py_lsa_DomainInformationPolicy_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	PyErr_Format(PyExc_TypeError, "New %s Objects are not supported", type->tp_name);
	return NULL;
}


static PyTypeObject lsa_DomainInformationPolicy_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.DomainInformationPolicy",
	.tp_getset = NULL,
	.tp_methods = py_lsa_DomainInformationPolicy_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_DomainInformationPolicy_new,
};


static PyObject *py_lsa_TranslatedName2_get_sid_type(PyObject *obj, void *closure)
{
	struct lsa_TranslatedName2 *object = (struct lsa_TranslatedName2 *)pytalloc_get_ptr(obj);
	PyObject *py_sid_type;
	py_sid_type = PyInt_FromLong((uint16_t)object->sid_type);
	return py_sid_type;
}

static int py_lsa_TranslatedName2_set_sid_type(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedName2 *object = (struct lsa_TranslatedName2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sid_type");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->sid_type));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_type = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_type = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TranslatedName2_get_name(PyObject *obj, void *closure)
{
	struct lsa_TranslatedName2 *object = (struct lsa_TranslatedName2 *)pytalloc_get_ptr(obj);
	PyObject *py_name;
	py_name = pytalloc_reference_ex(&lsa_String_Type, pytalloc_get_mem_ctx(obj), &object->name);
	return py_name;
}

static int py_lsa_TranslatedName2_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedName2 *object = (struct lsa_TranslatedName2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->name");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->name = *(struct lsa_String *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_TranslatedName2_get_sid_index(PyObject *obj, void *closure)
{
	struct lsa_TranslatedName2 *object = (struct lsa_TranslatedName2 *)pytalloc_get_ptr(obj);
	PyObject *py_sid_index;
	py_sid_index = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->sid_index);
	return py_sid_index;
}

static int py_lsa_TranslatedName2_set_sid_index(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedName2 *object = (struct lsa_TranslatedName2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sid_index");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->sid_index));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_index = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_index = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TranslatedName2_get_unknown(PyObject *obj, void *closure)
{
	struct lsa_TranslatedName2 *object = (struct lsa_TranslatedName2 *)pytalloc_get_ptr(obj);
	PyObject *py_unknown;
	py_unknown = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->unknown);
	return py_unknown;
}

static int py_lsa_TranslatedName2_set_unknown(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedName2 *object = (struct lsa_TranslatedName2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->unknown");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->unknown));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->unknown = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->unknown = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_TranslatedName2_getsetters[] = {
	{
		.name = discard_const_p(char, "sid_type"),
		.get = py_lsa_TranslatedName2_get_sid_type,
		.set = py_lsa_TranslatedName2_set_sid_type,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_SidType")
	},
	{
		.name = discard_const_p(char, "name"),
		.get = py_lsa_TranslatedName2_get_name,
		.set = py_lsa_TranslatedName2_set_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "sid_index"),
		.get = py_lsa_TranslatedName2_get_sid_index,
		.set = py_lsa_TranslatedName2_set_sid_index,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "unknown"),
		.get = py_lsa_TranslatedName2_get_unknown,
		.set = py_lsa_TranslatedName2_set_unknown,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TranslatedName2_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TranslatedName2, type);
}


static PyTypeObject lsa_TranslatedName2_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TranslatedName2",
	.tp_getset = py_lsa_TranslatedName2_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TranslatedName2_new,
};


static PyObject *py_lsa_TransNameArray2_get_count(PyObject *obj, void *closure)
{
	struct lsa_TransNameArray2 *object = (struct lsa_TransNameArray2 *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->count);
	return py_count;
}

static int py_lsa_TransNameArray2_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TransNameArray2 *object = (struct lsa_TransNameArray2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TransNameArray2_get_names(PyObject *obj, void *closure)
{
	struct lsa_TransNameArray2 *object = (struct lsa_TransNameArray2 *)pytalloc_get_ptr(obj);
	PyObject *py_names;
	if (object->names == NULL) {
		py_names = Py_None;
		Py_INCREF(py_names);
	} else {
		py_names = PyList_New(object->count);
		if (py_names == NULL) {
			return NULL;
		}
		{
			int names_cntr_1;
			for (names_cntr_1 = 0; names_cntr_1 < (object->count); names_cntr_1++) {
				PyObject *py_names_1;
				py_names_1 = pytalloc_reference_ex(&lsa_TranslatedName2_Type, object->names, &object->names[names_cntr_1]);
				PyList_SetItem(py_names, names_cntr_1, py_names_1);
			}
		}
	}
	return py_names;
}

static int py_lsa_TransNameArray2_set_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TransNameArray2 *object = (struct lsa_TransNameArray2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->names));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->names");
		return -1;
	}
	if (value == Py_None) {
		object->names = NULL;
	} else {
		object->names = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int names_cntr_1;
			object->names = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->names, PyList_GET_SIZE(value));
			if (!object->names) { return -1;; }
			talloc_set_name_const(object->names, "ARRAY: object->names");
			for (names_cntr_1 = 0; names_cntr_1 < PyList_GET_SIZE(value); names_cntr_1++) {
				if (PyList_GET_ITEM(value, names_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->names[names_cntr_1]");
					return -1;
				}
				PY_CHECK_TYPE(&lsa_TranslatedName2_Type, PyList_GET_ITEM(value, names_cntr_1), return -1;);
				if (talloc_reference(object->names, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, names_cntr_1))) == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				object->names[names_cntr_1] = *(struct lsa_TranslatedName2 *)pytalloc_get_ptr(PyList_GET_ITEM(value, names_cntr_1));
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_TransNameArray2_getsetters[] = {
	{
		.name = discard_const_p(char, "count"),
		.get = py_lsa_TransNameArray2_get_count,
		.set = py_lsa_TransNameArray2_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "names"),
		.get = py_lsa_TransNameArray2_get_names,
		.set = py_lsa_TransNameArray2_set_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TranslatedName2")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TransNameArray2_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TransNameArray2, type);
}


static PyTypeObject lsa_TransNameArray2_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TransNameArray2",
	.tp_getset = py_lsa_TransNameArray2_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TransNameArray2_new,
};


static PyObject *py_lsa_TranslatedSid2_get_sid_type(PyObject *obj, void *closure)
{
	struct lsa_TranslatedSid2 *object = (struct lsa_TranslatedSid2 *)pytalloc_get_ptr(obj);
	PyObject *py_sid_type;
	py_sid_type = PyInt_FromLong((uint16_t)object->sid_type);
	return py_sid_type;
}

static int py_lsa_TranslatedSid2_set_sid_type(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedSid2 *object = (struct lsa_TranslatedSid2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sid_type");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->sid_type));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_type = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_type = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TranslatedSid2_get_rid(PyObject *obj, void *closure)
{
	struct lsa_TranslatedSid2 *object = (struct lsa_TranslatedSid2 *)pytalloc_get_ptr(obj);
	PyObject *py_rid;
	py_rid = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->rid);
	return py_rid;
}

static int py_lsa_TranslatedSid2_set_rid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedSid2 *object = (struct lsa_TranslatedSid2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->rid");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->rid));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->rid = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->rid = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TranslatedSid2_get_sid_index(PyObject *obj, void *closure)
{
	struct lsa_TranslatedSid2 *object = (struct lsa_TranslatedSid2 *)pytalloc_get_ptr(obj);
	PyObject *py_sid_index;
	py_sid_index = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->sid_index);
	return py_sid_index;
}

static int py_lsa_TranslatedSid2_set_sid_index(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedSid2 *object = (struct lsa_TranslatedSid2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sid_index");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->sid_index));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_index = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_index = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TranslatedSid2_get_unknown(PyObject *obj, void *closure)
{
	struct lsa_TranslatedSid2 *object = (struct lsa_TranslatedSid2 *)pytalloc_get_ptr(obj);
	PyObject *py_unknown;
	py_unknown = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->unknown);
	return py_unknown;
}

static int py_lsa_TranslatedSid2_set_unknown(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedSid2 *object = (struct lsa_TranslatedSid2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->unknown");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->unknown));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->unknown = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->unknown = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_TranslatedSid2_getsetters[] = {
	{
		.name = discard_const_p(char, "sid_type"),
		.get = py_lsa_TranslatedSid2_get_sid_type,
		.set = py_lsa_TranslatedSid2_set_sid_type,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_SidType")
	},
	{
		.name = discard_const_p(char, "rid"),
		.get = py_lsa_TranslatedSid2_get_rid,
		.set = py_lsa_TranslatedSid2_set_rid,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "sid_index"),
		.get = py_lsa_TranslatedSid2_get_sid_index,
		.set = py_lsa_TranslatedSid2_set_sid_index,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "unknown"),
		.get = py_lsa_TranslatedSid2_get_unknown,
		.set = py_lsa_TranslatedSid2_set_unknown,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TranslatedSid2_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TranslatedSid2, type);
}


static PyTypeObject lsa_TranslatedSid2_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TranslatedSid2",
	.tp_getset = py_lsa_TranslatedSid2_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TranslatedSid2_new,
};


static PyObject *py_lsa_TransSidArray2_get_count(PyObject *obj, void *closure)
{
	struct lsa_TransSidArray2 *object = (struct lsa_TransSidArray2 *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->count);
	return py_count;
}

static int py_lsa_TransSidArray2_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TransSidArray2 *object = (struct lsa_TransSidArray2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TransSidArray2_get_sids(PyObject *obj, void *closure)
{
	struct lsa_TransSidArray2 *object = (struct lsa_TransSidArray2 *)pytalloc_get_ptr(obj);
	PyObject *py_sids;
	if (object->sids == NULL) {
		py_sids = Py_None;
		Py_INCREF(py_sids);
	} else {
		py_sids = PyList_New(object->count);
		if (py_sids == NULL) {
			return NULL;
		}
		{
			int sids_cntr_1;
			for (sids_cntr_1 = 0; sids_cntr_1 < (object->count); sids_cntr_1++) {
				PyObject *py_sids_1;
				py_sids_1 = pytalloc_reference_ex(&lsa_TranslatedSid2_Type, object->sids, &object->sids[sids_cntr_1]);
				PyList_SetItem(py_sids, sids_cntr_1, py_sids_1);
			}
		}
	}
	return py_sids;
}

static int py_lsa_TransSidArray2_set_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TransSidArray2 *object = (struct lsa_TransSidArray2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->sids));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sids");
		return -1;
	}
	if (value == Py_None) {
		object->sids = NULL;
	} else {
		object->sids = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int sids_cntr_1;
			object->sids = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->sids, PyList_GET_SIZE(value));
			if (!object->sids) { return -1;; }
			talloc_set_name_const(object->sids, "ARRAY: object->sids");
			for (sids_cntr_1 = 0; sids_cntr_1 < PyList_GET_SIZE(value); sids_cntr_1++) {
				if (PyList_GET_ITEM(value, sids_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sids[sids_cntr_1]");
					return -1;
				}
				PY_CHECK_TYPE(&lsa_TranslatedSid2_Type, PyList_GET_ITEM(value, sids_cntr_1), return -1;);
				if (talloc_reference(object->sids, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, sids_cntr_1))) == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				object->sids[sids_cntr_1] = *(struct lsa_TranslatedSid2 *)pytalloc_get_ptr(PyList_GET_ITEM(value, sids_cntr_1));
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_TransSidArray2_getsetters[] = {
	{
		.name = discard_const_p(char, "count"),
		.get = py_lsa_TransSidArray2_get_count,
		.set = py_lsa_TransSidArray2_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "sids"),
		.get = py_lsa_TransSidArray2_get_sids,
		.set = py_lsa_TransSidArray2_set_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TranslatedSid2")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TransSidArray2_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TransSidArray2, type);
}


static PyTypeObject lsa_TransSidArray2_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TransSidArray2",
	.tp_getset = py_lsa_TransSidArray2_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TransSidArray2_new,
};


static PyObject *py_lsa_TranslatedSid3_get_sid_type(PyObject *obj, void *closure)
{
	struct lsa_TranslatedSid3 *object = (struct lsa_TranslatedSid3 *)pytalloc_get_ptr(obj);
	PyObject *py_sid_type;
	py_sid_type = PyInt_FromLong((uint16_t)object->sid_type);
	return py_sid_type;
}

static int py_lsa_TranslatedSid3_set_sid_type(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedSid3 *object = (struct lsa_TranslatedSid3 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sid_type");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->sid_type));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_type = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_type = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TranslatedSid3_get_sid(PyObject *obj, void *closure)
{
	struct lsa_TranslatedSid3 *object = (struct lsa_TranslatedSid3 *)pytalloc_get_ptr(obj);
	PyObject *py_sid;
	if (object->sid == NULL) {
		py_sid = Py_None;
		Py_INCREF(py_sid);
	} else {
		py_sid = pytalloc_reference_ex(dom_sid_Type, object->sid, object->sid);
	}
	return py_sid;
}

static int py_lsa_TranslatedSid3_set_sid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedSid3 *object = (struct lsa_TranslatedSid3 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->sid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sid");
		return -1;
	}
	if (value == Py_None) {
		object->sid = NULL;
	} else {
		object->sid = NULL;
		PY_CHECK_TYPE(dom_sid_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->sid = (struct dom_sid *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_TranslatedSid3_get_sid_index(PyObject *obj, void *closure)
{
	struct lsa_TranslatedSid3 *object = (struct lsa_TranslatedSid3 *)pytalloc_get_ptr(obj);
	PyObject *py_sid_index;
	py_sid_index = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->sid_index);
	return py_sid_index;
}

static int py_lsa_TranslatedSid3_set_sid_index(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedSid3 *object = (struct lsa_TranslatedSid3 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sid_index");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->sid_index));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_index = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->sid_index = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TranslatedSid3_get_flags(PyObject *obj, void *closure)
{
	struct lsa_TranslatedSid3 *object = (struct lsa_TranslatedSid3 *)pytalloc_get_ptr(obj);
	PyObject *py_flags;
	py_flags = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->flags);
	return py_flags;
}

static int py_lsa_TranslatedSid3_set_flags(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TranslatedSid3 *object = (struct lsa_TranslatedSid3 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->flags");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->flags));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->flags = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->flags = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_TranslatedSid3_getsetters[] = {
	{
		.name = discard_const_p(char, "sid_type"),
		.get = py_lsa_TranslatedSid3_get_sid_type,
		.set = py_lsa_TranslatedSid3_set_sid_type,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_SidType")
	},
	{
		.name = discard_const_p(char, "sid"),
		.get = py_lsa_TranslatedSid3_get_sid,
		.set = py_lsa_TranslatedSid3_set_sid,
		.doc = discard_const_p(char, "PIDL-generated element of base type dom_sid2")
	},
	{
		.name = discard_const_p(char, "sid_index"),
		.get = py_lsa_TranslatedSid3_get_sid_index,
		.set = py_lsa_TranslatedSid3_set_sid_index,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "flags"),
		.get = py_lsa_TranslatedSid3_get_flags,
		.set = py_lsa_TranslatedSid3_set_flags,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TranslatedSid3_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TranslatedSid3, type);
}


static PyTypeObject lsa_TranslatedSid3_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TranslatedSid3",
	.tp_getset = py_lsa_TranslatedSid3_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TranslatedSid3_new,
};


static PyObject *py_lsa_TransSidArray3_get_count(PyObject *obj, void *closure)
{
	struct lsa_TransSidArray3 *object = (struct lsa_TransSidArray3 *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->count);
	return py_count;
}

static int py_lsa_TransSidArray3_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TransSidArray3 *object = (struct lsa_TransSidArray3 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_TransSidArray3_get_sids(PyObject *obj, void *closure)
{
	struct lsa_TransSidArray3 *object = (struct lsa_TransSidArray3 *)pytalloc_get_ptr(obj);
	PyObject *py_sids;
	if (object->sids == NULL) {
		py_sids = Py_None;
		Py_INCREF(py_sids);
	} else {
		py_sids = PyList_New(object->count);
		if (py_sids == NULL) {
			return NULL;
		}
		{
			int sids_cntr_1;
			for (sids_cntr_1 = 0; sids_cntr_1 < (object->count); sids_cntr_1++) {
				PyObject *py_sids_1;
				py_sids_1 = pytalloc_reference_ex(&lsa_TranslatedSid3_Type, object->sids, &object->sids[sids_cntr_1]);
				PyList_SetItem(py_sids, sids_cntr_1, py_sids_1);
			}
		}
	}
	return py_sids;
}

static int py_lsa_TransSidArray3_set_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_TransSidArray3 *object = (struct lsa_TransSidArray3 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->sids));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sids");
		return -1;
	}
	if (value == Py_None) {
		object->sids = NULL;
	} else {
		object->sids = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int sids_cntr_1;
			object->sids = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->sids, PyList_GET_SIZE(value));
			if (!object->sids) { return -1;; }
			talloc_set_name_const(object->sids, "ARRAY: object->sids");
			for (sids_cntr_1 = 0; sids_cntr_1 < PyList_GET_SIZE(value); sids_cntr_1++) {
				if (PyList_GET_ITEM(value, sids_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->sids[sids_cntr_1]");
					return -1;
				}
				PY_CHECK_TYPE(&lsa_TranslatedSid3_Type, PyList_GET_ITEM(value, sids_cntr_1), return -1;);
				if (talloc_reference(object->sids, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, sids_cntr_1))) == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				object->sids[sids_cntr_1] = *(struct lsa_TranslatedSid3 *)pytalloc_get_ptr(PyList_GET_ITEM(value, sids_cntr_1));
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_TransSidArray3_getsetters[] = {
	{
		.name = discard_const_p(char, "count"),
		.get = py_lsa_TransSidArray3_get_count,
		.set = py_lsa_TransSidArray3_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "sids"),
		.get = py_lsa_TransSidArray3_get_sids,
		.set = py_lsa_TransSidArray3_set_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TranslatedSid3")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_TransSidArray3_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_TransSidArray3, type);
}


static PyTypeObject lsa_TransSidArray3_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.TransSidArray3",
	.tp_getset = py_lsa_TransSidArray3_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_TransSidArray3_new,
};


static PyObject *py_lsa_ForestTrustBinaryData_get_length(PyObject *obj, void *closure)
{
	struct lsa_ForestTrustBinaryData *object = (struct lsa_ForestTrustBinaryData *)pytalloc_get_ptr(obj);
	PyObject *py_length;
	py_length = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->length);
	return py_length;
}

static int py_lsa_ForestTrustBinaryData_set_length(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ForestTrustBinaryData *object = (struct lsa_ForestTrustBinaryData *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->length");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->length));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->length = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->length = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_ForestTrustBinaryData_get_data(PyObject *obj, void *closure)
{
	struct lsa_ForestTrustBinaryData *object = (struct lsa_ForestTrustBinaryData *)pytalloc_get_ptr(obj);
	PyObject *py_data;
	if (object->data == NULL) {
		py_data = Py_None;
		Py_INCREF(py_data);
	} else {
		py_data = PyList_New(object->length);
		if (py_data == NULL) {
			return NULL;
		}
		{
			int data_cntr_1;
			for (data_cntr_1 = 0; data_cntr_1 < (object->length); data_cntr_1++) {
				PyObject *py_data_1;
				py_data_1 = PyInt_FromLong((uint16_t)object->data[data_cntr_1]);
				PyList_SetItem(py_data, data_cntr_1, py_data_1);
			}
		}
	}
	return py_data;
}

static int py_lsa_ForestTrustBinaryData_set_data(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ForestTrustBinaryData *object = (struct lsa_ForestTrustBinaryData *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->data));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->data");
		return -1;
	}
	if (value == Py_None) {
		object->data = NULL;
	} else {
		object->data = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int data_cntr_1;
			object->data = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->data, PyList_GET_SIZE(value));
			if (!object->data) { return -1;; }
			talloc_set_name_const(object->data, "ARRAY: object->data");
			for (data_cntr_1 = 0; data_cntr_1 < PyList_GET_SIZE(value); data_cntr_1++) {
				if (PyList_GET_ITEM(value, data_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->data[data_cntr_1]");
					return -1;
				}
				{
					const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->data[data_cntr_1]));
					if (PyLong_Check(PyList_GET_ITEM(value, data_cntr_1))) {
						unsigned long long test_var;
						test_var = PyLong_AsUnsignedLongLong(PyList_GET_ITEM(value, data_cntr_1));
						if (PyErr_Occurred() != NULL) {
							return -1;
						}
						if (test_var > uint_max) {
							PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
							  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
							return -1;
						}
						object->data[data_cntr_1] = test_var;
					} else if (PyInt_Check(PyList_GET_ITEM(value, data_cntr_1))) {
						long test_var;
						test_var = PyInt_AsLong(PyList_GET_ITEM(value, data_cntr_1));
						if (test_var < 0 || test_var > uint_max) {
							PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
							  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
							return -1;
						}
						object->data[data_cntr_1] = test_var;
					} else {
						PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
						  PyInt_Type.tp_name, PyLong_Type.tp_name);
						return -1;
					}
				}
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_ForestTrustBinaryData_getsetters[] = {
	{
		.name = discard_const_p(char, "length"),
		.get = py_lsa_ForestTrustBinaryData_get_length,
		.set = py_lsa_ForestTrustBinaryData_set_length,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint3264")
	},
	{
		.name = discard_const_p(char, "data"),
		.get = py_lsa_ForestTrustBinaryData_get_data,
		.set = py_lsa_ForestTrustBinaryData_set_data,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_ForestTrustBinaryData_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_ForestTrustBinaryData, type);
}


static PyTypeObject lsa_ForestTrustBinaryData_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.ForestTrustBinaryData",
	.tp_getset = py_lsa_ForestTrustBinaryData_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_ForestTrustBinaryData_new,
};


static PyObject *py_lsa_ForestTrustDomainInfo_get_domain_sid(PyObject *obj, void *closure)
{
	struct lsa_ForestTrustDomainInfo *object = (struct lsa_ForestTrustDomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_domain_sid;
	if (object->domain_sid == NULL) {
		py_domain_sid = Py_None;
		Py_INCREF(py_domain_sid);
	} else {
		py_domain_sid = pytalloc_reference_ex(dom_sid_Type, object->domain_sid, object->domain_sid);
	}
	return py_domain_sid;
}

static int py_lsa_ForestTrustDomainInfo_set_domain_sid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ForestTrustDomainInfo *object = (struct lsa_ForestTrustDomainInfo *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->domain_sid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->domain_sid");
		return -1;
	}
	if (value == Py_None) {
		object->domain_sid = NULL;
	} else {
		object->domain_sid = NULL;
		PY_CHECK_TYPE(dom_sid_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->domain_sid = (struct dom_sid *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_ForestTrustDomainInfo_get_dns_domain_name(PyObject *obj, void *closure)
{
	struct lsa_ForestTrustDomainInfo *object = (struct lsa_ForestTrustDomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_dns_domain_name;
	py_dns_domain_name = pytalloc_reference_ex(&lsa_StringLarge_Type, pytalloc_get_mem_ctx(obj), &object->dns_domain_name);
	return py_dns_domain_name;
}

static int py_lsa_ForestTrustDomainInfo_set_dns_domain_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ForestTrustDomainInfo *object = (struct lsa_ForestTrustDomainInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->dns_domain_name");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_StringLarge_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->dns_domain_name = *(struct lsa_StringLarge *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_ForestTrustDomainInfo_get_netbios_domain_name(PyObject *obj, void *closure)
{
	struct lsa_ForestTrustDomainInfo *object = (struct lsa_ForestTrustDomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_netbios_domain_name;
	py_netbios_domain_name = pytalloc_reference_ex(&lsa_StringLarge_Type, pytalloc_get_mem_ctx(obj), &object->netbios_domain_name);
	return py_netbios_domain_name;
}

static int py_lsa_ForestTrustDomainInfo_set_netbios_domain_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ForestTrustDomainInfo *object = (struct lsa_ForestTrustDomainInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->netbios_domain_name");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_StringLarge_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->netbios_domain_name = *(struct lsa_StringLarge *)pytalloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_lsa_ForestTrustDomainInfo_getsetters[] = {
	{
		.name = discard_const_p(char, "domain_sid"),
		.get = py_lsa_ForestTrustDomainInfo_get_domain_sid,
		.set = py_lsa_ForestTrustDomainInfo_set_domain_sid,
		.doc = discard_const_p(char, "PIDL-generated element of base type dom_sid2")
	},
	{
		.name = discard_const_p(char, "dns_domain_name"),
		.get = py_lsa_ForestTrustDomainInfo_get_dns_domain_name,
		.set = py_lsa_ForestTrustDomainInfo_set_dns_domain_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_StringLarge")
	},
	{
		.name = discard_const_p(char, "netbios_domain_name"),
		.get = py_lsa_ForestTrustDomainInfo_get_netbios_domain_name,
		.set = py_lsa_ForestTrustDomainInfo_set_netbios_domain_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_StringLarge")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_ForestTrustDomainInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_ForestTrustDomainInfo, type);
}


static PyTypeObject lsa_ForestTrustDomainInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.ForestTrustDomainInfo",
	.tp_getset = py_lsa_ForestTrustDomainInfo_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_ForestTrustDomainInfo_new,
};

static PyObject *py_import_lsa_ForestTrustData(TALLOC_CTX *mem_ctx, int level, union lsa_ForestTrustData *in)
{
	PyObject *ret;

	switch (level) {
		case LSA_FOREST_TRUST_TOP_LEVEL_NAME:
			ret = pytalloc_reference_ex(&lsa_StringLarge_Type, mem_ctx, &in->top_level_name);
			return ret;

		case LSA_FOREST_TRUST_TOP_LEVEL_NAME_EX:
			ret = pytalloc_reference_ex(&lsa_StringLarge_Type, mem_ctx, &in->top_level_name_ex);
			return ret;

		case LSA_FOREST_TRUST_DOMAIN_INFO:
			ret = pytalloc_reference_ex(&lsa_ForestTrustDomainInfo_Type, mem_ctx, &in->domain_info);
			return ret;

		default:
			ret = pytalloc_reference_ex(&lsa_ForestTrustBinaryData_Type, mem_ctx, &in->data);
			return ret;

	}
	PyErr_SetString(PyExc_TypeError, "unknown union level");
	return NULL;
}

static union lsa_ForestTrustData *py_export_lsa_ForestTrustData(TALLOC_CTX *mem_ctx, int level, PyObject *in)
{
	union lsa_ForestTrustData *ret = talloc_zero(mem_ctx, union lsa_ForestTrustData);
	switch (level) {
		case LSA_FOREST_TRUST_TOP_LEVEL_NAME:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->top_level_name");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_StringLarge_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->top_level_name = *(struct lsa_StringLarge *)pytalloc_get_ptr(in);
			break;

		case LSA_FOREST_TRUST_TOP_LEVEL_NAME_EX:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->top_level_name_ex");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_StringLarge_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->top_level_name_ex = *(struct lsa_StringLarge *)pytalloc_get_ptr(in);
			break;

		case LSA_FOREST_TRUST_DOMAIN_INFO:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->domain_info");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_ForestTrustDomainInfo_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->domain_info = *(struct lsa_ForestTrustDomainInfo *)pytalloc_get_ptr(in);
			break;

		default:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->data");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&lsa_ForestTrustBinaryData_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->data = *(struct lsa_ForestTrustBinaryData *)pytalloc_get_ptr(in);
			break;

	}

	return ret;
}

static PyObject *py_lsa_ForestTrustData_import(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "mem_ctx", "level", "in", NULL };
	PyObject *mem_ctx_obj = NULL;
	TALLOC_CTX *mem_ctx = NULL;
	int level = 0;
	PyObject *in_obj = NULL;
	union lsa_ForestTrustData *in = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiO:import",
		discard_const_p(char *, kwnames),
		&mem_ctx_obj,
		&level,
		&in_obj)) {
		return NULL;
	}
	mem_ctx = pytalloc_get_ptr(mem_ctx_obj);
	if (mem_ctx == NULL) {
		PyErr_SetString(PyExc_TypeError, "mem_ctx is NULL)!");
		return NULL;
	}
	in = (union lsa_ForestTrustData *)pytalloc_get_ptr(in_obj);
	if (in == NULL) {
		PyErr_Format(PyExc_TypeError, "in needs to be a pointer to union lsa_ForestTrustData!");
		return NULL;
	}

	return py_import_lsa_ForestTrustData(mem_ctx, level, in);
}

static PyObject *py_lsa_ForestTrustData_export(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "mem_ctx", "level", "in", NULL };
	PyObject *mem_ctx_obj = NULL;
	TALLOC_CTX *mem_ctx = NULL;
	int level = 0;
	PyObject *in = NULL;
	union lsa_ForestTrustData *out = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiO:import",
		discard_const_p(char *, kwnames),
		&mem_ctx_obj,
		&level,
		&in)) {
		return NULL;
	}
	mem_ctx = pytalloc_get_ptr(mem_ctx_obj);
	if (mem_ctx == NULL) {
		PyErr_SetString(PyExc_TypeError, "mem_ctx is NULL)!");
		return NULL;
	}

	out = py_export_lsa_ForestTrustData(mem_ctx, level, in);
	if (out == NULL) {
		return NULL;
	}

	return pytalloc_GenericObject_reference(out);
}

static PyMethodDef py_lsa_ForestTrustData_methods[] = {
	{ "__import__", (PyCFunction)py_lsa_ForestTrustData_import,
		METH_VARARGS|METH_KEYWORDS|METH_CLASS,
		"T.__import__(mem_ctx, level, in) => ret." },
	{ "__export__", (PyCFunction)py_lsa_ForestTrustData_export,
		METH_VARARGS|METH_KEYWORDS|METH_CLASS,
		"T.__export__(mem_ctx, level, in) => ret." },
	{ NULL, NULL, 0, NULL }
};

static PyObject *py_lsa_ForestTrustData_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	PyErr_Format(PyExc_TypeError, "New %s Objects are not supported", type->tp_name);
	return NULL;
}


static PyTypeObject lsa_ForestTrustData_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.ForestTrustData",
	.tp_getset = NULL,
	.tp_methods = py_lsa_ForestTrustData_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_ForestTrustData_new,
};


static PyObject *py_lsa_ForestTrustRecord_get_flags(PyObject *obj, void *closure)
{
	struct lsa_ForestTrustRecord *object = (struct lsa_ForestTrustRecord *)pytalloc_get_ptr(obj);
	PyObject *py_flags;
	py_flags = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->flags);
	return py_flags;
}

static int py_lsa_ForestTrustRecord_set_flags(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ForestTrustRecord *object = (struct lsa_ForestTrustRecord *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->flags");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->flags));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->flags = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->flags = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_ForestTrustRecord_get_type(PyObject *obj, void *closure)
{
	struct lsa_ForestTrustRecord *object = (struct lsa_ForestTrustRecord *)pytalloc_get_ptr(obj);
	PyObject *py_type;
	py_type = PyInt_FromLong((uint16_t)object->type);
	return py_type;
}

static int py_lsa_ForestTrustRecord_set_type(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ForestTrustRecord *object = (struct lsa_ForestTrustRecord *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->type");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->type));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->type = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->type = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_ForestTrustRecord_get_time(PyObject *obj, void *closure)
{
	struct lsa_ForestTrustRecord *object = (struct lsa_ForestTrustRecord *)pytalloc_get_ptr(obj);
	PyObject *py_time;
	py_time = ndr_PyLong_FromUnsignedLongLong(object->time);
	return py_time;
}

static int py_lsa_ForestTrustRecord_set_time(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ForestTrustRecord *object = (struct lsa_ForestTrustRecord *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->time");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->time));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->time = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->time = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_ForestTrustRecord_get_forest_trust_data(PyObject *obj, void *closure)
{
	struct lsa_ForestTrustRecord *object = (struct lsa_ForestTrustRecord *)pytalloc_get_ptr(obj);
	PyObject *py_forest_trust_data;
	py_forest_trust_data = pyrpc_import_union(&lsa_ForestTrustData_Type, pytalloc_get_mem_ctx(obj), object->type, &object->forest_trust_data, "union lsa_ForestTrustData");
	if (py_forest_trust_data == NULL) {
		return NULL;
	}
	return py_forest_trust_data;
}

static int py_lsa_ForestTrustRecord_set_forest_trust_data(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ForestTrustRecord *object = (struct lsa_ForestTrustRecord *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->forest_trust_data");
		return -1;
	}
	{
		union lsa_ForestTrustData *forest_trust_data_switch_0;
		forest_trust_data_switch_0 = (union lsa_ForestTrustData *)pyrpc_export_union(&lsa_ForestTrustData_Type, pytalloc_get_mem_ctx(py_obj), object->type, value, "union lsa_ForestTrustData");
		if (forest_trust_data_switch_0 == NULL) {
			return -1;
		}
		object->forest_trust_data = *forest_trust_data_switch_0;
	}
	return 0;
}

static PyGetSetDef py_lsa_ForestTrustRecord_getsetters[] = {
	{
		.name = discard_const_p(char, "flags"),
		.get = py_lsa_ForestTrustRecord_get_flags,
		.set = py_lsa_ForestTrustRecord_set_flags,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ForestTrustRecordFlags")
	},
	{
		.name = discard_const_p(char, "type"),
		.get = py_lsa_ForestTrustRecord_get_type,
		.set = py_lsa_ForestTrustRecord_set_type,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ForestTrustRecordType")
	},
	{
		.name = discard_const_p(char, "time"),
		.get = py_lsa_ForestTrustRecord_get_time,
		.set = py_lsa_ForestTrustRecord_set_time,
		.doc = discard_const_p(char, "PIDL-generated element of base type NTTIME_hyper")
	},
	{
		.name = discard_const_p(char, "forest_trust_data"),
		.get = py_lsa_ForestTrustRecord_get_forest_trust_data,
		.set = py_lsa_ForestTrustRecord_set_forest_trust_data,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ForestTrustData")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_ForestTrustRecord_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_ForestTrustRecord, type);
}


static PyTypeObject lsa_ForestTrustRecord_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.ForestTrustRecord",
	.tp_getset = py_lsa_ForestTrustRecord_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_ForestTrustRecord_new,
};


static PyObject *py_lsa_ForestTrustInformation_get_count(PyObject *obj, void *closure)
{
	struct lsa_ForestTrustInformation *object = (struct lsa_ForestTrustInformation *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->count);
	return py_count;
}

static int py_lsa_ForestTrustInformation_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ForestTrustInformation *object = (struct lsa_ForestTrustInformation *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_ForestTrustInformation_get_entries(PyObject *obj, void *closure)
{
	struct lsa_ForestTrustInformation *object = (struct lsa_ForestTrustInformation *)pytalloc_get_ptr(obj);
	PyObject *py_entries;
	if (object->entries == NULL) {
		py_entries = Py_None;
		Py_INCREF(py_entries);
	} else {
		py_entries = PyList_New(object->count);
		if (py_entries == NULL) {
			return NULL;
		}
		{
			int entries_cntr_1;
			for (entries_cntr_1 = 0; entries_cntr_1 < (object->count); entries_cntr_1++) {
				PyObject *py_entries_1;
				if (object->entries[entries_cntr_1] == NULL) {
					py_entries_1 = Py_None;
					Py_INCREF(py_entries_1);
				} else {
					py_entries_1 = pytalloc_reference_ex(&lsa_ForestTrustRecord_Type, object->entries[entries_cntr_1], object->entries[entries_cntr_1]);
				}
				PyList_SetItem(py_entries, entries_cntr_1, py_entries_1);
			}
		}
	}
	return py_entries;
}

static int py_lsa_ForestTrustInformation_set_entries(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ForestTrustInformation *object = (struct lsa_ForestTrustInformation *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->entries));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->entries");
		return -1;
	}
	if (value == Py_None) {
		object->entries = NULL;
	} else {
		object->entries = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int entries_cntr_1;
			object->entries = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->entries, PyList_GET_SIZE(value));
			if (!object->entries) { return -1;; }
			talloc_set_name_const(object->entries, "ARRAY: object->entries");
			for (entries_cntr_1 = 0; entries_cntr_1 < PyList_GET_SIZE(value); entries_cntr_1++) {
				if (PyList_GET_ITEM(value, entries_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->entries[entries_cntr_1]");
					return -1;
				}
				if (PyList_GET_ITEM(value, entries_cntr_1) == Py_None) {
					object->entries[entries_cntr_1] = NULL;
				} else {
					object->entries[entries_cntr_1] = NULL;
					PY_CHECK_TYPE(&lsa_ForestTrustRecord_Type, PyList_GET_ITEM(value, entries_cntr_1), return -1;);
					if (talloc_reference(object->entries, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, entries_cntr_1))) == NULL) {
						PyErr_NoMemory();
						return -1;
					}
					object->entries[entries_cntr_1] = (struct lsa_ForestTrustRecord *)pytalloc_get_ptr(PyList_GET_ITEM(value, entries_cntr_1));
				}
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_ForestTrustInformation_getsetters[] = {
	{
		.name = discard_const_p(char, "count"),
		.get = py_lsa_ForestTrustInformation_get_count,
		.set = py_lsa_ForestTrustInformation_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "entries"),
		.get = py_lsa_ForestTrustInformation_get_entries,
		.set = py_lsa_ForestTrustInformation_set_entries,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ForestTrustRecord")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_ForestTrustInformation_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_ForestTrustInformation, type);
}

static PyObject *py_lsa_ForestTrustInformation_ndr_pack(PyObject *py_obj)
{
	struct lsa_ForestTrustInformation *object = (struct lsa_ForestTrustInformation *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_lsa_ForestTrustInformation);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_lsa_ForestTrustInformation_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct lsa_ForestTrustInformation *object = (struct lsa_ForestTrustInformation *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_ForestTrustInformation);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_ForestTrustInformation);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_lsa_ForestTrustInformation_ndr_print(PyObject *py_obj)
{
	struct lsa_ForestTrustInformation *object = (struct lsa_ForestTrustInformation *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_lsa_ForestTrustInformation, "lsa_ForestTrustInformation", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_lsa_ForestTrustInformation_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_lsa_ForestTrustInformation_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_lsa_ForestTrustInformation_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_lsa_ForestTrustInformation_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_ForestTrustInformation_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.ForestTrustInformation",
	.tp_getset = py_lsa_ForestTrustInformation_getsetters,
	.tp_methods = py_lsa_ForestTrustInformation_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_ForestTrustInformation_new,
};


static PyObject *py_lsa_ForestTrustCollisionRecord_get_index(PyObject *obj, void *closure)
{
	struct lsa_ForestTrustCollisionRecord *object = (struct lsa_ForestTrustCollisionRecord *)pytalloc_get_ptr(obj);
	PyObject *py_index;
	py_index = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->index);
	return py_index;
}

static int py_lsa_ForestTrustCollisionRecord_set_index(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ForestTrustCollisionRecord *object = (struct lsa_ForestTrustCollisionRecord *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->index");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->index));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->index = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->index = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_ForestTrustCollisionRecord_get_type(PyObject *obj, void *closure)
{
	struct lsa_ForestTrustCollisionRecord *object = (struct lsa_ForestTrustCollisionRecord *)pytalloc_get_ptr(obj);
	PyObject *py_type;
	py_type = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->type);
	return py_type;
}

static int py_lsa_ForestTrustCollisionRecord_set_type(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ForestTrustCollisionRecord *object = (struct lsa_ForestTrustCollisionRecord *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->type");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->type));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->type = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->type = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_ForestTrustCollisionRecord_get_flags(PyObject *obj, void *closure)
{
	struct lsa_ForestTrustCollisionRecord *object = (struct lsa_ForestTrustCollisionRecord *)pytalloc_get_ptr(obj);
	PyObject *py_flags;
	py_flags = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->flags);
	return py_flags;
}

static int py_lsa_ForestTrustCollisionRecord_set_flags(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ForestTrustCollisionRecord *object = (struct lsa_ForestTrustCollisionRecord *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->flags");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->flags));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->flags = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->flags = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_ForestTrustCollisionRecord_get_name(PyObject *obj, void *closure)
{
	struct lsa_ForestTrustCollisionRecord *object = (struct lsa_ForestTrustCollisionRecord *)pytalloc_get_ptr(obj);
	PyObject *py_name;
	py_name = pytalloc_reference_ex(&lsa_String_Type, pytalloc_get_mem_ctx(obj), &object->name);
	return py_name;
}

static int py_lsa_ForestTrustCollisionRecord_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ForestTrustCollisionRecord *object = (struct lsa_ForestTrustCollisionRecord *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->name");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->name = *(struct lsa_String *)pytalloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_lsa_ForestTrustCollisionRecord_getsetters[] = {
	{
		.name = discard_const_p(char, "index"),
		.get = py_lsa_ForestTrustCollisionRecord_get_index,
		.set = py_lsa_ForestTrustCollisionRecord_set_index,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "type"),
		.get = py_lsa_ForestTrustCollisionRecord_get_type,
		.set = py_lsa_ForestTrustCollisionRecord_set_type,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ForestTrustCollisionRecordType")
	},
	{
		.name = discard_const_p(char, "flags"),
		.get = py_lsa_ForestTrustCollisionRecord_get_flags,
		.set = py_lsa_ForestTrustCollisionRecord_set_flags,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ForestTrustRecordFlags")
	},
	{
		.name = discard_const_p(char, "name"),
		.get = py_lsa_ForestTrustCollisionRecord_get_name,
		.set = py_lsa_ForestTrustCollisionRecord_set_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_ForestTrustCollisionRecord_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_ForestTrustCollisionRecord, type);
}

static PyObject *py_lsa_ForestTrustCollisionRecord_ndr_pack(PyObject *py_obj)
{
	struct lsa_ForestTrustCollisionRecord *object = (struct lsa_ForestTrustCollisionRecord *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_lsa_ForestTrustCollisionRecord);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_lsa_ForestTrustCollisionRecord_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct lsa_ForestTrustCollisionRecord *object = (struct lsa_ForestTrustCollisionRecord *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_ForestTrustCollisionRecord);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_ForestTrustCollisionRecord);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_lsa_ForestTrustCollisionRecord_ndr_print(PyObject *py_obj)
{
	struct lsa_ForestTrustCollisionRecord *object = (struct lsa_ForestTrustCollisionRecord *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_lsa_ForestTrustCollisionRecord, "lsa_ForestTrustCollisionRecord", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_lsa_ForestTrustCollisionRecord_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_lsa_ForestTrustCollisionRecord_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_lsa_ForestTrustCollisionRecord_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_lsa_ForestTrustCollisionRecord_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_ForestTrustCollisionRecord_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.ForestTrustCollisionRecord",
	.tp_getset = py_lsa_ForestTrustCollisionRecord_getsetters,
	.tp_methods = py_lsa_ForestTrustCollisionRecord_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_ForestTrustCollisionRecord_new,
};


static PyObject *py_lsa_ForestTrustCollisionInfo_get_count(PyObject *obj, void *closure)
{
	struct lsa_ForestTrustCollisionInfo *object = (struct lsa_ForestTrustCollisionInfo *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->count);
	return py_count;
}

static int py_lsa_ForestTrustCollisionInfo_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ForestTrustCollisionInfo *object = (struct lsa_ForestTrustCollisionInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_ForestTrustCollisionInfo_get_entries(PyObject *obj, void *closure)
{
	struct lsa_ForestTrustCollisionInfo *object = (struct lsa_ForestTrustCollisionInfo *)pytalloc_get_ptr(obj);
	PyObject *py_entries;
	if (object->entries == NULL) {
		py_entries = Py_None;
		Py_INCREF(py_entries);
	} else {
		py_entries = PyList_New(object->count);
		if (py_entries == NULL) {
			return NULL;
		}
		{
			int entries_cntr_1;
			for (entries_cntr_1 = 0; entries_cntr_1 < (object->count); entries_cntr_1++) {
				PyObject *py_entries_1;
				if (object->entries[entries_cntr_1] == NULL) {
					py_entries_1 = Py_None;
					Py_INCREF(py_entries_1);
				} else {
					py_entries_1 = pytalloc_reference_ex(&lsa_ForestTrustCollisionRecord_Type, object->entries[entries_cntr_1], object->entries[entries_cntr_1]);
				}
				PyList_SetItem(py_entries, entries_cntr_1, py_entries_1);
			}
		}
	}
	return py_entries;
}

static int py_lsa_ForestTrustCollisionInfo_set_entries(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_ForestTrustCollisionInfo *object = (struct lsa_ForestTrustCollisionInfo *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->entries));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->entries");
		return -1;
	}
	if (value == Py_None) {
		object->entries = NULL;
	} else {
		object->entries = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int entries_cntr_1;
			object->entries = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->entries, PyList_GET_SIZE(value));
			if (!object->entries) { return -1;; }
			talloc_set_name_const(object->entries, "ARRAY: object->entries");
			for (entries_cntr_1 = 0; entries_cntr_1 < PyList_GET_SIZE(value); entries_cntr_1++) {
				if (PyList_GET_ITEM(value, entries_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->entries[entries_cntr_1]");
					return -1;
				}
				if (PyList_GET_ITEM(value, entries_cntr_1) == Py_None) {
					object->entries[entries_cntr_1] = NULL;
				} else {
					object->entries[entries_cntr_1] = NULL;
					PY_CHECK_TYPE(&lsa_ForestTrustCollisionRecord_Type, PyList_GET_ITEM(value, entries_cntr_1), return -1;);
					if (talloc_reference(object->entries, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, entries_cntr_1))) == NULL) {
						PyErr_NoMemory();
						return -1;
					}
					object->entries[entries_cntr_1] = (struct lsa_ForestTrustCollisionRecord *)pytalloc_get_ptr(PyList_GET_ITEM(value, entries_cntr_1));
				}
			}
		}
	}
	return 0;
}

static PyGetSetDef py_lsa_ForestTrustCollisionInfo_getsetters[] = {
	{
		.name = discard_const_p(char, "count"),
		.get = py_lsa_ForestTrustCollisionInfo_get_count,
		.set = py_lsa_ForestTrustCollisionInfo_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "entries"),
		.get = py_lsa_ForestTrustCollisionInfo_get_entries,
		.set = py_lsa_ForestTrustCollisionInfo_set_entries,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ForestTrustCollisionRecord")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_ForestTrustCollisionInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_ForestTrustCollisionInfo, type);
}

static PyObject *py_lsa_ForestTrustCollisionInfo_ndr_pack(PyObject *py_obj)
{
	struct lsa_ForestTrustCollisionInfo *object = (struct lsa_ForestTrustCollisionInfo *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_lsa_ForestTrustCollisionInfo);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_lsa_ForestTrustCollisionInfo_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct lsa_ForestTrustCollisionInfo *object = (struct lsa_ForestTrustCollisionInfo *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_ForestTrustCollisionInfo);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_lsa_ForestTrustCollisionInfo);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_lsa_ForestTrustCollisionInfo_ndr_print(PyObject *py_obj)
{
	struct lsa_ForestTrustCollisionInfo *object = (struct lsa_ForestTrustCollisionInfo *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_lsa_ForestTrustCollisionInfo, "lsa_ForestTrustCollisionInfo", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_lsa_ForestTrustCollisionInfo_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_lsa_ForestTrustCollisionInfo_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_lsa_ForestTrustCollisionInfo_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_lsa_ForestTrustCollisionInfo_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_ForestTrustCollisionInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.ForestTrustCollisionInfo",
	.tp_getset = py_lsa_ForestTrustCollisionInfo_getsetters,
	.tp_methods = py_lsa_ForestTrustCollisionInfo_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_ForestTrustCollisionInfo_new,
};



static PyObject *py_lsa_Close_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_Close *object = (struct lsa_Close *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_Close_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_Close *object = (struct lsa_Close *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_Close_out_get_handle(PyObject *obj, void *closure)
{
	struct lsa_Close *object = (struct lsa_Close *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->out.handle, object->out.handle);
	return py_handle;
}

static int py_lsa_Close_out_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_Close *object = (struct lsa_Close *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.handle");
		return -1;
	}
	object->out.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.handle);
	if (object->out.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_Close_get_result(PyObject *obj, void *closure)
{
	struct lsa_Close *object = (struct lsa_Close *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_Close_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_Close *object = (struct lsa_Close *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_Close_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_Close_in_get_handle,
		.set = py_lsa_Close_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "out_handle"),
		.get = py_lsa_Close_out_get_handle,
		.set = py_lsa_Close_out_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_Close_get_result,
		.set = py_lsa_Close_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_Close_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_Close, type);
}

static PyObject *py_lsa_Close_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(0);
}

static PyObject *py_lsa_Close_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_Close *object = (struct lsa_Close *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 1) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_Close_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[0];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_Close_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_Close_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_Close_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_Close_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_Close_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_Close *object = (struct lsa_Close *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 1) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_Close_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[0];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_Close_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_Close_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_Close_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_Close_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_Close_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_Close *object = (struct lsa_Close *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 1) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_Close_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[0];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_Close_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_Close_ndr_print(py_obj, "lsa_Close_in", NDR_IN);
}

static PyObject *py_lsa_Close_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_Close_ndr_print(py_obj, "lsa_Close_out", NDR_OUT);
}

static PyMethodDef py_lsa_Close_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_Close_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.Close.opnum() -> 0 (0x00) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_Close_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_Close_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_Close_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_Close_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_Close_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_Close_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_Close_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.Close",
	.tp_getset = py_lsa_Close_getsetters,
	.tp_methods = py_lsa_Close_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_Close_new,
};

static bool pack_py_lsa_Close_args_in(PyObject *args, PyObject *kwargs, struct lsa_Close *r)
{
	PyObject *py_handle;
	const char *kwnames[] = {
		"handle", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:lsa_Close", discard_const_p(char *, kwnames), &py_handle)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	return true;
}

static PyObject *unpack_py_lsa_Close_args_out(struct lsa_Close *r)
{
	PyObject *result;
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, r->out.handle, r->out.handle);
	result = py_handle;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_Delete_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_Delete *object = (struct lsa_Delete *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_Delete_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_Delete *object = (struct lsa_Delete *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_Delete_get_result(PyObject *obj, void *closure)
{
	struct lsa_Delete *object = (struct lsa_Delete *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_Delete_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_Delete *object = (struct lsa_Delete *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_Delete_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_Delete_in_get_handle,
		.set = py_lsa_Delete_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_Delete_get_result,
		.set = py_lsa_Delete_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_Delete_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_Delete, type);
}

static PyObject *py_lsa_Delete_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(1);
}

static PyObject *py_lsa_Delete_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_Delete *object = (struct lsa_Delete *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 2) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_Delete_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[1];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_Delete_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_Delete_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_Delete_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_Delete_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_Delete_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_Delete *object = (struct lsa_Delete *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 2) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_Delete_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[1];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_Delete_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_Delete_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_Delete_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_Delete_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_Delete_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_Delete *object = (struct lsa_Delete *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 2) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_Delete_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[1];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_Delete_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_Delete_ndr_print(py_obj, "lsa_Delete_in", NDR_IN);
}

static PyObject *py_lsa_Delete_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_Delete_ndr_print(py_obj, "lsa_Delete_out", NDR_OUT);
}

static PyMethodDef py_lsa_Delete_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_Delete_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.Delete.opnum() -> 1 (0x01) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_Delete_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_Delete_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_Delete_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_Delete_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_Delete_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_Delete_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_Delete_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.Delete",
	.tp_getset = py_lsa_Delete_getsetters,
	.tp_methods = py_lsa_Delete_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_Delete_new,
};

static bool pack_py_lsa_Delete_args_in(PyObject *args, PyObject *kwargs, struct lsa_Delete *r)
{
	PyObject *py_handle;
	const char *kwnames[] = {
		"handle", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:lsa_Delete", discard_const_p(char *, kwnames), &py_handle)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	return true;
}

static PyObject *unpack_py_lsa_Delete_args_out(struct lsa_Delete *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_EnumPrivs_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_EnumPrivs *object = (struct lsa_EnumPrivs *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_EnumPrivs_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumPrivs *object = (struct lsa_EnumPrivs *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_EnumPrivs_in_get_resume_handle(PyObject *obj, void *closure)
{
	struct lsa_EnumPrivs *object = (struct lsa_EnumPrivs *)pytalloc_get_ptr(obj);
	PyObject *py_resume_handle;
	py_resume_handle = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->in.resume_handle);
	return py_resume_handle;
}

static int py_lsa_EnumPrivs_in_set_resume_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumPrivs *object = (struct lsa_EnumPrivs *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.resume_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.resume_handle");
		return -1;
	}
	object->in.resume_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.resume_handle);
	if (object->in.resume_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->in.resume_handle));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.resume_handle = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.resume_handle = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_EnumPrivs_out_get_resume_handle(PyObject *obj, void *closure)
{
	struct lsa_EnumPrivs *object = (struct lsa_EnumPrivs *)pytalloc_get_ptr(obj);
	PyObject *py_resume_handle;
	py_resume_handle = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->out.resume_handle);
	return py_resume_handle;
}

static int py_lsa_EnumPrivs_out_set_resume_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumPrivs *object = (struct lsa_EnumPrivs *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.resume_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.resume_handle");
		return -1;
	}
	object->out.resume_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.resume_handle);
	if (object->out.resume_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->out.resume_handle));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.resume_handle = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.resume_handle = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_EnumPrivs_out_get_privs(PyObject *obj, void *closure)
{
	struct lsa_EnumPrivs *object = (struct lsa_EnumPrivs *)pytalloc_get_ptr(obj);
	PyObject *py_privs;
	py_privs = pytalloc_reference_ex(&lsa_PrivArray_Type, object->out.privs, object->out.privs);
	return py_privs;
}

static int py_lsa_EnumPrivs_out_set_privs(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumPrivs *object = (struct lsa_EnumPrivs *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.privs));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.privs");
		return -1;
	}
	object->out.privs = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.privs);
	if (object->out.privs == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_PrivArray_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.privs = (struct lsa_PrivArray *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_EnumPrivs_in_get_max_count(PyObject *obj, void *closure)
{
	struct lsa_EnumPrivs *object = (struct lsa_EnumPrivs *)pytalloc_get_ptr(obj);
	PyObject *py_max_count;
	py_max_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.max_count);
	return py_max_count;
}

static int py_lsa_EnumPrivs_in_set_max_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumPrivs *object = (struct lsa_EnumPrivs *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.max_count");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.max_count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.max_count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.max_count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_EnumPrivs_get_result(PyObject *obj, void *closure)
{
	struct lsa_EnumPrivs *object = (struct lsa_EnumPrivs *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_EnumPrivs_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumPrivs *object = (struct lsa_EnumPrivs *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_EnumPrivs_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_EnumPrivs_in_get_handle,
		.set = py_lsa_EnumPrivs_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_resume_handle"),
		.get = py_lsa_EnumPrivs_in_get_resume_handle,
		.set = py_lsa_EnumPrivs_in_set_resume_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "out_resume_handle"),
		.get = py_lsa_EnumPrivs_out_get_resume_handle,
		.set = py_lsa_EnumPrivs_out_set_resume_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "out_privs"),
		.get = py_lsa_EnumPrivs_out_get_privs,
		.set = py_lsa_EnumPrivs_out_set_privs,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_PrivArray")
	},
	{
		.name = discard_const_p(char, "in_max_count"),
		.get = py_lsa_EnumPrivs_in_get_max_count,
		.set = py_lsa_EnumPrivs_in_set_max_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_EnumPrivs_get_result,
		.set = py_lsa_EnumPrivs_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_EnumPrivs_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_EnumPrivs, type);
}

static PyObject *py_lsa_EnumPrivs_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(2);
}

static PyObject *py_lsa_EnumPrivs_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumPrivs *object = (struct lsa_EnumPrivs *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 3) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumPrivs_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[2];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_EnumPrivs_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_EnumPrivs_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_EnumPrivs_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_EnumPrivs_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_EnumPrivs_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumPrivs *object = (struct lsa_EnumPrivs *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 3) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumPrivs_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[2];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_EnumPrivs_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_EnumPrivs_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_EnumPrivs_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_EnumPrivs_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_EnumPrivs_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumPrivs *object = (struct lsa_EnumPrivs *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 3) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumPrivs_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[2];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_EnumPrivs_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_EnumPrivs_ndr_print(py_obj, "lsa_EnumPrivs_in", NDR_IN);
}

static PyObject *py_lsa_EnumPrivs_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_EnumPrivs_ndr_print(py_obj, "lsa_EnumPrivs_out", NDR_OUT);
}

static PyMethodDef py_lsa_EnumPrivs_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_EnumPrivs_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.EnumPrivs.opnum() -> 2 (0x02) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_EnumPrivs_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_EnumPrivs_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_EnumPrivs_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_EnumPrivs_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_EnumPrivs_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_EnumPrivs_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_EnumPrivs_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.EnumPrivs",
	.tp_getset = py_lsa_EnumPrivs_getsetters,
	.tp_methods = py_lsa_EnumPrivs_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_EnumPrivs_new,
};

static bool pack_py_lsa_EnumPrivs_args_in(PyObject *args, PyObject *kwargs, struct lsa_EnumPrivs *r)
{
	PyObject *py_handle;
	PyObject *py_resume_handle;
	PyObject *py_max_count;
	const char *kwnames[] = {
		"handle", "resume_handle", "max_count", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_EnumPrivs", discard_const_p(char *, kwnames), &py_handle, &py_resume_handle, &py_max_count)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_resume_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.resume_handle");
		return false;
	}
	r->in.resume_handle = talloc_ptrtype(r, r->in.resume_handle);
	if (r->in.resume_handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*r->in.resume_handle));
		if (PyLong_Check(py_resume_handle)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_resume_handle);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.resume_handle = test_var;
		} else if (PyInt_Check(py_resume_handle)) {
			long test_var;
			test_var = PyInt_AsLong(py_resume_handle);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.resume_handle = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_max_count == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.max_count");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.max_count));
		if (PyLong_Check(py_max_count)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_max_count);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.max_count = test_var;
		} else if (PyInt_Check(py_max_count)) {
			long test_var;
			test_var = PyInt_AsLong(py_max_count);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.max_count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_EnumPrivs_args_out(struct lsa_EnumPrivs *r)
{
	PyObject *result;
	PyObject *py_resume_handle;
	PyObject *py_privs;
	result = PyTuple_New(2);
	py_resume_handle = ndr_PyLong_FromUnsignedLongLong((uint32_t)*r->out.resume_handle);
	PyTuple_SetItem(result, 0, py_resume_handle);
	py_privs = pytalloc_reference_ex(&lsa_PrivArray_Type, r->out.privs, r->out.privs);
	PyTuple_SetItem(result, 1, py_privs);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_QuerySecurity_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_QuerySecurity *object = (struct lsa_QuerySecurity *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_QuerySecurity_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QuerySecurity *object = (struct lsa_QuerySecurity *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_QuerySecurity_in_get_sec_info(PyObject *obj, void *closure)
{
	struct lsa_QuerySecurity *object = (struct lsa_QuerySecurity *)pytalloc_get_ptr(obj);
	PyObject *py_sec_info;
	py_sec_info = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.sec_info);
	return py_sec_info;
}

static int py_lsa_QuerySecurity_in_set_sec_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QuerySecurity *object = (struct lsa_QuerySecurity *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sec_info");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.sec_info));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.sec_info = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.sec_info = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_QuerySecurity_out_get_sdbuf(PyObject *obj, void *closure)
{
	struct lsa_QuerySecurity *object = (struct lsa_QuerySecurity *)pytalloc_get_ptr(obj);
	PyObject *py_sdbuf;
	if (*object->out.sdbuf == NULL) {
		py_sdbuf = Py_None;
		Py_INCREF(py_sdbuf);
	} else {
		py_sdbuf = pytalloc_reference_ex(sec_desc_buf_Type, *object->out.sdbuf, *object->out.sdbuf);
	}
	return py_sdbuf;
}

static int py_lsa_QuerySecurity_out_set_sdbuf(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QuerySecurity *object = (struct lsa_QuerySecurity *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.sdbuf));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.sdbuf");
		return -1;
	}
	object->out.sdbuf = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.sdbuf);
	if (object->out.sdbuf == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.sdbuf = NULL;
	} else {
		*object->out.sdbuf = NULL;
		PY_CHECK_TYPE(sec_desc_buf_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		*object->out.sdbuf = (struct sec_desc_buf *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_QuerySecurity_get_result(PyObject *obj, void *closure)
{
	struct lsa_QuerySecurity *object = (struct lsa_QuerySecurity *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_QuerySecurity_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QuerySecurity *object = (struct lsa_QuerySecurity *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_QuerySecurity_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_QuerySecurity_in_get_handle,
		.set = py_lsa_QuerySecurity_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_sec_info"),
		.get = py_lsa_QuerySecurity_in_get_sec_info,
		.set = py_lsa_QuerySecurity_in_set_sec_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type security_secinfo")
	},
	{
		.name = discard_const_p(char, "out_sdbuf"),
		.get = py_lsa_QuerySecurity_out_get_sdbuf,
		.set = py_lsa_QuerySecurity_out_set_sdbuf,
		.doc = discard_const_p(char, "PIDL-generated element of base type sec_desc_buf")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_QuerySecurity_get_result,
		.set = py_lsa_QuerySecurity_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_QuerySecurity_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_QuerySecurity, type);
}

static PyObject *py_lsa_QuerySecurity_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(3);
}

static PyObject *py_lsa_QuerySecurity_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QuerySecurity *object = (struct lsa_QuerySecurity *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 4) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QuerySecurity_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[3];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_QuerySecurity_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_QuerySecurity_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_QuerySecurity_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_QuerySecurity_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_QuerySecurity_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QuerySecurity *object = (struct lsa_QuerySecurity *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 4) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QuerySecurity_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[3];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_QuerySecurity_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_QuerySecurity_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_QuerySecurity_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_QuerySecurity_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_QuerySecurity_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QuerySecurity *object = (struct lsa_QuerySecurity *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 4) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QuerySecurity_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[3];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_QuerySecurity_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_QuerySecurity_ndr_print(py_obj, "lsa_QuerySecurity_in", NDR_IN);
}

static PyObject *py_lsa_QuerySecurity_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_QuerySecurity_ndr_print(py_obj, "lsa_QuerySecurity_out", NDR_OUT);
}

static PyMethodDef py_lsa_QuerySecurity_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_QuerySecurity_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.QuerySecurity.opnum() -> 3 (0x03) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_QuerySecurity_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_QuerySecurity_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_QuerySecurity_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_QuerySecurity_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_QuerySecurity_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_QuerySecurity_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_QuerySecurity_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.QuerySecurity",
	.tp_getset = py_lsa_QuerySecurity_getsetters,
	.tp_methods = py_lsa_QuerySecurity_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_QuerySecurity_new,
};

static bool pack_py_lsa_QuerySecurity_args_in(PyObject *args, PyObject *kwargs, struct lsa_QuerySecurity *r)
{
	PyObject *py_handle;
	PyObject *py_sec_info;
	const char *kwnames[] = {
		"handle", "sec_info", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:lsa_QuerySecurity", discard_const_p(char *, kwnames), &py_handle, &py_sec_info)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_sec_info == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sec_info");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.sec_info));
		if (PyLong_Check(py_sec_info)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_sec_info);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.sec_info = test_var;
		} else if (PyInt_Check(py_sec_info)) {
			long test_var;
			test_var = PyInt_AsLong(py_sec_info);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.sec_info = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_QuerySecurity_args_out(struct lsa_QuerySecurity *r)
{
	PyObject *result;
	PyObject *py_sdbuf;
	if (*r->out.sdbuf == NULL) {
		py_sdbuf = Py_None;
		Py_INCREF(py_sdbuf);
	} else {
		py_sdbuf = pytalloc_reference_ex(sec_desc_buf_Type, *r->out.sdbuf, *r->out.sdbuf);
	}
	result = py_sdbuf;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_SetSecObj_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_SetSecObj *object = (struct lsa_SetSecObj *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_SetSecObj_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetSecObj *object = (struct lsa_SetSecObj *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_SetSecObj_in_get_sec_info(PyObject *obj, void *closure)
{
	struct lsa_SetSecObj *object = (struct lsa_SetSecObj *)pytalloc_get_ptr(obj);
	PyObject *py_sec_info;
	py_sec_info = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.sec_info);
	return py_sec_info;
}

static int py_lsa_SetSecObj_in_set_sec_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetSecObj *object = (struct lsa_SetSecObj *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sec_info");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.sec_info));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.sec_info = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.sec_info = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_SetSecObj_in_get_sdbuf(PyObject *obj, void *closure)
{
	struct lsa_SetSecObj *object = (struct lsa_SetSecObj *)pytalloc_get_ptr(obj);
	PyObject *py_sdbuf;
	py_sdbuf = pytalloc_reference_ex(sec_desc_buf_Type, object->in.sdbuf, object->in.sdbuf);
	return py_sdbuf;
}

static int py_lsa_SetSecObj_in_set_sdbuf(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetSecObj *object = (struct lsa_SetSecObj *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.sdbuf));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sdbuf");
		return -1;
	}
	object->in.sdbuf = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.sdbuf);
	if (object->in.sdbuf == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(sec_desc_buf_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.sdbuf = (struct sec_desc_buf *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_SetSecObj_get_result(PyObject *obj, void *closure)
{
	struct lsa_SetSecObj *object = (struct lsa_SetSecObj *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_SetSecObj_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetSecObj *object = (struct lsa_SetSecObj *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_SetSecObj_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_SetSecObj_in_get_handle,
		.set = py_lsa_SetSecObj_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_sec_info"),
		.get = py_lsa_SetSecObj_in_get_sec_info,
		.set = py_lsa_SetSecObj_in_set_sec_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type security_secinfo")
	},
	{
		.name = discard_const_p(char, "in_sdbuf"),
		.get = py_lsa_SetSecObj_in_get_sdbuf,
		.set = py_lsa_SetSecObj_in_set_sdbuf,
		.doc = discard_const_p(char, "PIDL-generated element of base type sec_desc_buf")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_SetSecObj_get_result,
		.set = py_lsa_SetSecObj_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_SetSecObj_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_SetSecObj, type);
}

static PyObject *py_lsa_SetSecObj_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(4);
}

static PyObject *py_lsa_SetSecObj_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetSecObj *object = (struct lsa_SetSecObj *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 5) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetSecObj_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[4];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_SetSecObj_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetSecObj_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_SetSecObj_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetSecObj_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_SetSecObj_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetSecObj *object = (struct lsa_SetSecObj *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 5) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetSecObj_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[4];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_SetSecObj_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetSecObj_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetSecObj_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetSecObj_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetSecObj_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetSecObj *object = (struct lsa_SetSecObj *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 5) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetSecObj_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[4];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_SetSecObj_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_SetSecObj_ndr_print(py_obj, "lsa_SetSecObj_in", NDR_IN);
}

static PyObject *py_lsa_SetSecObj_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_SetSecObj_ndr_print(py_obj, "lsa_SetSecObj_out", NDR_OUT);
}

static PyMethodDef py_lsa_SetSecObj_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_SetSecObj_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.SetSecObj.opnum() -> 4 (0x04) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_SetSecObj_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_SetSecObj_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_SetSecObj_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_SetSecObj_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_SetSecObj_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_SetSecObj_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_SetSecObj_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.SetSecObj",
	.tp_getset = py_lsa_SetSecObj_getsetters,
	.tp_methods = py_lsa_SetSecObj_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_SetSecObj_new,
};

static bool pack_py_lsa_SetSecObj_args_in(PyObject *args, PyObject *kwargs, struct lsa_SetSecObj *r)
{
	PyObject *py_handle;
	PyObject *py_sec_info;
	PyObject *py_sdbuf;
	const char *kwnames[] = {
		"handle", "sec_info", "sdbuf", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_SetSecObj", discard_const_p(char *, kwnames), &py_handle, &py_sec_info, &py_sdbuf)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_sec_info == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sec_info");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.sec_info));
		if (PyLong_Check(py_sec_info)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_sec_info);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.sec_info = test_var;
		} else if (PyInt_Check(py_sec_info)) {
			long test_var;
			test_var = PyInt_AsLong(py_sec_info);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.sec_info = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_sdbuf == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sdbuf");
		return false;
	}
	r->in.sdbuf = talloc_ptrtype(r, r->in.sdbuf);
	if (r->in.sdbuf == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(sec_desc_buf_Type, py_sdbuf, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_sdbuf)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.sdbuf = (struct sec_desc_buf *)pytalloc_get_ptr(py_sdbuf);
	return true;
}

static PyObject *unpack_py_lsa_SetSecObj_args_out(struct lsa_SetSecObj *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_OpenPolicy_in_get_system_name(PyObject *obj, void *closure)
{
	struct lsa_OpenPolicy *object = (struct lsa_OpenPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_system_name;
	if (object->in.system_name == NULL) {
		py_system_name = Py_None;
		Py_INCREF(py_system_name);
	} else {
		py_system_name = PyInt_FromLong((uint16_t)*object->in.system_name);
	}
	return py_system_name;
}

static int py_lsa_OpenPolicy_in_set_system_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenPolicy *object = (struct lsa_OpenPolicy *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.system_name));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.system_name");
		return -1;
	}
	if (value == Py_None) {
		object->in.system_name = NULL;
	} else {
		object->in.system_name = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.system_name);
		if (object->in.system_name == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		{
			const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->in.system_name));
			if (PyLong_Check(value)) {
				unsigned long long test_var;
				test_var = PyLong_AsUnsignedLongLong(value);
				if (PyErr_Occurred() != NULL) {
					return -1;
				}
				if (test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return -1;
				}
				*object->in.system_name = test_var;
			} else if (PyInt_Check(value)) {
				long test_var;
				test_var = PyInt_AsLong(value);
				if (test_var < 0 || test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return -1;
				}
				*object->in.system_name = test_var;
			} else {
				PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name);
				return -1;
			}
		}
	}
	return 0;
}

static PyObject *py_lsa_OpenPolicy_in_get_attr(PyObject *obj, void *closure)
{
	struct lsa_OpenPolicy *object = (struct lsa_OpenPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_attr;
	py_attr = pytalloc_reference_ex(&lsa_ObjectAttribute_Type, object->in.attr, object->in.attr);
	return py_attr;
}

static int py_lsa_OpenPolicy_in_set_attr(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenPolicy *object = (struct lsa_OpenPolicy *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.attr));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.attr");
		return -1;
	}
	object->in.attr = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.attr);
	if (object->in.attr == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_ObjectAttribute_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.attr = (struct lsa_ObjectAttribute *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_OpenPolicy_in_get_access_mask(PyObject *obj, void *closure)
{
	struct lsa_OpenPolicy *object = (struct lsa_OpenPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_access_mask;
	py_access_mask = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.access_mask);
	return py_access_mask;
}

static int py_lsa_OpenPolicy_in_set_access_mask(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenPolicy *object = (struct lsa_OpenPolicy *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.access_mask");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.access_mask));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_OpenPolicy_out_get_handle(PyObject *obj, void *closure)
{
	struct lsa_OpenPolicy *object = (struct lsa_OpenPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->out.handle, object->out.handle);
	return py_handle;
}

static int py_lsa_OpenPolicy_out_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenPolicy *object = (struct lsa_OpenPolicy *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.handle");
		return -1;
	}
	object->out.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.handle);
	if (object->out.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_OpenPolicy_get_result(PyObject *obj, void *closure)
{
	struct lsa_OpenPolicy *object = (struct lsa_OpenPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_OpenPolicy_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenPolicy *object = (struct lsa_OpenPolicy *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_OpenPolicy_getsetters[] = {
	{
		.name = discard_const_p(char, "in_system_name"),
		.get = py_lsa_OpenPolicy_in_get_system_name,
		.set = py_lsa_OpenPolicy_in_set_system_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "in_attr"),
		.get = py_lsa_OpenPolicy_in_get_attr,
		.set = py_lsa_OpenPolicy_in_set_attr,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ObjectAttribute")
	},
	{
		.name = discard_const_p(char, "in_access_mask"),
		.get = py_lsa_OpenPolicy_in_get_access_mask,
		.set = py_lsa_OpenPolicy_in_set_access_mask,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_PolicyAccessMask")
	},
	{
		.name = discard_const_p(char, "out_handle"),
		.get = py_lsa_OpenPolicy_out_get_handle,
		.set = py_lsa_OpenPolicy_out_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_OpenPolicy_get_result,
		.set = py_lsa_OpenPolicy_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_OpenPolicy_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_OpenPolicy, type);
}

static PyObject *py_lsa_OpenPolicy_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(6);
}

static PyObject *py_lsa_OpenPolicy_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenPolicy *object = (struct lsa_OpenPolicy *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 7) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenPolicy_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[6];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_OpenPolicy_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_OpenPolicy_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_OpenPolicy_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_OpenPolicy_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_OpenPolicy_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenPolicy *object = (struct lsa_OpenPolicy *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 7) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenPolicy_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[6];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_OpenPolicy_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_OpenPolicy_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_OpenPolicy_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_OpenPolicy_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_OpenPolicy_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenPolicy *object = (struct lsa_OpenPolicy *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 7) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenPolicy_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[6];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_OpenPolicy_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_OpenPolicy_ndr_print(py_obj, "lsa_OpenPolicy_in", NDR_IN);
}

static PyObject *py_lsa_OpenPolicy_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_OpenPolicy_ndr_print(py_obj, "lsa_OpenPolicy_out", NDR_OUT);
}

static PyMethodDef py_lsa_OpenPolicy_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_OpenPolicy_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.OpenPolicy.opnum() -> 6 (0x06) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_OpenPolicy_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_OpenPolicy_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_OpenPolicy_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_OpenPolicy_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_OpenPolicy_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_OpenPolicy_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_OpenPolicy_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.OpenPolicy",
	.tp_getset = py_lsa_OpenPolicy_getsetters,
	.tp_methods = py_lsa_OpenPolicy_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_OpenPolicy_new,
};

static bool pack_py_lsa_OpenPolicy_args_in(PyObject *args, PyObject *kwargs, struct lsa_OpenPolicy *r)
{
	PyObject *py_system_name;
	PyObject *py_attr;
	PyObject *py_access_mask;
	const char *kwnames[] = {
		"system_name", "attr", "access_mask", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_OpenPolicy", discard_const_p(char *, kwnames), &py_system_name, &py_attr, &py_access_mask)) {
		return false;
	}

	if (py_system_name == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.system_name");
		return false;
	}
	if (py_system_name == Py_None) {
		r->in.system_name = NULL;
	} else {
		r->in.system_name = talloc_ptrtype(r, r->in.system_name);
		if (r->in.system_name == NULL) {
			PyErr_NoMemory();
			return false;
		}
		{
			const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*r->in.system_name));
			if (PyLong_Check(py_system_name)) {
				unsigned long long test_var;
				test_var = PyLong_AsUnsignedLongLong(py_system_name);
				if (PyErr_Occurred() != NULL) {
					return false;
				}
				if (test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return false;
				}
				*r->in.system_name = test_var;
			} else if (PyInt_Check(py_system_name)) {
				long test_var;
				test_var = PyInt_AsLong(py_system_name);
				if (test_var < 0 || test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return false;
				}
				*r->in.system_name = test_var;
			} else {
				PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name);
				return false;
			}
		}
	}
	if (py_attr == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.attr");
		return false;
	}
	r->in.attr = talloc_ptrtype(r, r->in.attr);
	if (r->in.attr == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_ObjectAttribute_Type, py_attr, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_attr)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.attr = (struct lsa_ObjectAttribute *)pytalloc_get_ptr(py_attr);
	if (py_access_mask == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.access_mask");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.access_mask));
		if (PyLong_Check(py_access_mask)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_access_mask);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else if (PyInt_Check(py_access_mask)) {
			long test_var;
			test_var = PyInt_AsLong(py_access_mask);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_OpenPolicy_args_out(struct lsa_OpenPolicy *r)
{
	PyObject *result;
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, r->out.handle, r->out.handle);
	result = py_handle;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_QueryInfoPolicy_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_QueryInfoPolicy *object = (struct lsa_QueryInfoPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_QueryInfoPolicy_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryInfoPolicy *object = (struct lsa_QueryInfoPolicy *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_QueryInfoPolicy_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_QueryInfoPolicy *object = (struct lsa_QueryInfoPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_QueryInfoPolicy_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryInfoPolicy *object = (struct lsa_QueryInfoPolicy *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_QueryInfoPolicy_out_get_info(PyObject *obj, void *closure)
{
	struct lsa_QueryInfoPolicy *object = (struct lsa_QueryInfoPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_info;
	if (*object->out.info == NULL) {
		py_info = Py_None;
		Py_INCREF(py_info);
	} else {
		py_info = pyrpc_import_union(&lsa_PolicyInformation_Type, *object->out.info, object->in.level, *object->out.info, "union lsa_PolicyInformation");
		if (py_info == NULL) {
			return NULL;
		}
	}
	return py_info;
}

static int py_lsa_QueryInfoPolicy_out_set_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryInfoPolicy *object = (struct lsa_QueryInfoPolicy *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.info");
		return -1;
	}
	object->out.info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.info);
	if (object->out.info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.info = NULL;
	} else {
		*object->out.info = NULL;
		{
			union lsa_PolicyInformation *info_switch_2;
			info_switch_2 = (union lsa_PolicyInformation *)pyrpc_export_union(&lsa_PolicyInformation_Type, pytalloc_get_mem_ctx(py_obj), object->in.level, value, "union lsa_PolicyInformation");
			if (info_switch_2 == NULL) {
				return -1;
			}
			*object->out.info = info_switch_2;
		}
	}
	return 0;
}

static PyObject *py_lsa_QueryInfoPolicy_get_result(PyObject *obj, void *closure)
{
	struct lsa_QueryInfoPolicy *object = (struct lsa_QueryInfoPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_QueryInfoPolicy_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryInfoPolicy *object = (struct lsa_QueryInfoPolicy *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_QueryInfoPolicy_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_QueryInfoPolicy_in_get_handle,
		.set = py_lsa_QueryInfoPolicy_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_QueryInfoPolicy_in_get_level,
		.set = py_lsa_QueryInfoPolicy_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_PolicyInfo")
	},
	{
		.name = discard_const_p(char, "out_info"),
		.get = py_lsa_QueryInfoPolicy_out_get_info,
		.set = py_lsa_QueryInfoPolicy_out_set_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_PolicyInformation")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_QueryInfoPolicy_get_result,
		.set = py_lsa_QueryInfoPolicy_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_QueryInfoPolicy_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_QueryInfoPolicy, type);
}

static PyObject *py_lsa_QueryInfoPolicy_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(7);
}

static PyObject *py_lsa_QueryInfoPolicy_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryInfoPolicy *object = (struct lsa_QueryInfoPolicy *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 8) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryInfoPolicy_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[7];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_QueryInfoPolicy_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_QueryInfoPolicy_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_QueryInfoPolicy_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_QueryInfoPolicy_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_QueryInfoPolicy_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryInfoPolicy *object = (struct lsa_QueryInfoPolicy *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 8) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryInfoPolicy_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[7];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_QueryInfoPolicy_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_QueryInfoPolicy_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_QueryInfoPolicy_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_QueryInfoPolicy_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_QueryInfoPolicy_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryInfoPolicy *object = (struct lsa_QueryInfoPolicy *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 8) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryInfoPolicy_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[7];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_QueryInfoPolicy_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_QueryInfoPolicy_ndr_print(py_obj, "lsa_QueryInfoPolicy_in", NDR_IN);
}

static PyObject *py_lsa_QueryInfoPolicy_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_QueryInfoPolicy_ndr_print(py_obj, "lsa_QueryInfoPolicy_out", NDR_OUT);
}

static PyMethodDef py_lsa_QueryInfoPolicy_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_QueryInfoPolicy_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.QueryInfoPolicy.opnum() -> 7 (0x07) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_QueryInfoPolicy_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_QueryInfoPolicy_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_QueryInfoPolicy_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_QueryInfoPolicy_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_QueryInfoPolicy_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_QueryInfoPolicy_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_QueryInfoPolicy_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.QueryInfoPolicy",
	.tp_getset = py_lsa_QueryInfoPolicy_getsetters,
	.tp_methods = py_lsa_QueryInfoPolicy_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_QueryInfoPolicy_new,
};

static bool pack_py_lsa_QueryInfoPolicy_args_in(PyObject *args, PyObject *kwargs, struct lsa_QueryInfoPolicy *r)
{
	PyObject *py_handle;
	PyObject *py_level;
	const char *kwnames[] = {
		"handle", "level", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:lsa_QueryInfoPolicy", discard_const_p(char *, kwnames), &py_handle, &py_level)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_QueryInfoPolicy_args_out(struct lsa_QueryInfoPolicy *r)
{
	PyObject *result;
	PyObject *py_info;
	if (*r->out.info == NULL) {
		py_info = Py_None;
		Py_INCREF(py_info);
	} else {
		py_info = pyrpc_import_union(&lsa_PolicyInformation_Type, *r->out.info, r->in.level, *r->out.info, "union lsa_PolicyInformation");
		if (py_info == NULL) {
			return NULL;
		}
	}
	result = py_info;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_SetInfoPolicy_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_SetInfoPolicy *object = (struct lsa_SetInfoPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_SetInfoPolicy_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetInfoPolicy *object = (struct lsa_SetInfoPolicy *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_SetInfoPolicy_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_SetInfoPolicy *object = (struct lsa_SetInfoPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_SetInfoPolicy_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetInfoPolicy *object = (struct lsa_SetInfoPolicy *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_SetInfoPolicy_in_get_info(PyObject *obj, void *closure)
{
	struct lsa_SetInfoPolicy *object = (struct lsa_SetInfoPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_info;
	py_info = pyrpc_import_union(&lsa_PolicyInformation_Type, object->in.info, object->in.level, object->in.info, "union lsa_PolicyInformation");
	if (py_info == NULL) {
		return NULL;
	}
	return py_info;
}

static int py_lsa_SetInfoPolicy_in_set_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetInfoPolicy *object = (struct lsa_SetInfoPolicy *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.info");
		return -1;
	}
	object->in.info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.info);
	if (object->in.info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		union lsa_PolicyInformation *info_switch_1;
		info_switch_1 = (union lsa_PolicyInformation *)pyrpc_export_union(&lsa_PolicyInformation_Type, pytalloc_get_mem_ctx(py_obj), object->in.level, value, "union lsa_PolicyInformation");
		if (info_switch_1 == NULL) {
			return -1;
		}
		object->in.info = info_switch_1;
	}
	return 0;
}

static PyObject *py_lsa_SetInfoPolicy_get_result(PyObject *obj, void *closure)
{
	struct lsa_SetInfoPolicy *object = (struct lsa_SetInfoPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_SetInfoPolicy_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetInfoPolicy *object = (struct lsa_SetInfoPolicy *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_SetInfoPolicy_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_SetInfoPolicy_in_get_handle,
		.set = py_lsa_SetInfoPolicy_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_SetInfoPolicy_in_get_level,
		.set = py_lsa_SetInfoPolicy_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_PolicyInfo")
	},
	{
		.name = discard_const_p(char, "in_info"),
		.get = py_lsa_SetInfoPolicy_in_get_info,
		.set = py_lsa_SetInfoPolicy_in_set_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_PolicyInformation")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_SetInfoPolicy_get_result,
		.set = py_lsa_SetInfoPolicy_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_SetInfoPolicy_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_SetInfoPolicy, type);
}

static PyObject *py_lsa_SetInfoPolicy_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(8);
}

static PyObject *py_lsa_SetInfoPolicy_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetInfoPolicy *object = (struct lsa_SetInfoPolicy *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 9) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetInfoPolicy_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[8];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_SetInfoPolicy_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetInfoPolicy_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_SetInfoPolicy_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetInfoPolicy_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_SetInfoPolicy_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetInfoPolicy *object = (struct lsa_SetInfoPolicy *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 9) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetInfoPolicy_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[8];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_SetInfoPolicy_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetInfoPolicy_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetInfoPolicy_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetInfoPolicy_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetInfoPolicy_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetInfoPolicy *object = (struct lsa_SetInfoPolicy *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 9) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetInfoPolicy_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[8];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_SetInfoPolicy_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_SetInfoPolicy_ndr_print(py_obj, "lsa_SetInfoPolicy_in", NDR_IN);
}

static PyObject *py_lsa_SetInfoPolicy_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_SetInfoPolicy_ndr_print(py_obj, "lsa_SetInfoPolicy_out", NDR_OUT);
}

static PyMethodDef py_lsa_SetInfoPolicy_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_SetInfoPolicy_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.SetInfoPolicy.opnum() -> 8 (0x08) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_SetInfoPolicy_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_SetInfoPolicy_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_SetInfoPolicy_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_SetInfoPolicy_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_SetInfoPolicy_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_SetInfoPolicy_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_SetInfoPolicy_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.SetInfoPolicy",
	.tp_getset = py_lsa_SetInfoPolicy_getsetters,
	.tp_methods = py_lsa_SetInfoPolicy_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_SetInfoPolicy_new,
};

static bool pack_py_lsa_SetInfoPolicy_args_in(PyObject *args, PyObject *kwargs, struct lsa_SetInfoPolicy *r)
{
	PyObject *py_handle;
	PyObject *py_level;
	PyObject *py_info;
	const char *kwnames[] = {
		"handle", "level", "info", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_SetInfoPolicy", discard_const_p(char *, kwnames), &py_handle, &py_level, &py_info)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_info == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.info");
		return false;
	}
	r->in.info = talloc_ptrtype(r, r->in.info);
	if (r->in.info == NULL) {
		PyErr_NoMemory();
		return false;
	}
	{
		union lsa_PolicyInformation *info_switch_1;
		info_switch_1 = (union lsa_PolicyInformation *)pyrpc_export_union(&lsa_PolicyInformation_Type, r, r->in.level, py_info, "union lsa_PolicyInformation");
		if (info_switch_1 == NULL) {
			return false;
		}
		r->in.info = info_switch_1;
	}
	return true;
}

static PyObject *unpack_py_lsa_SetInfoPolicy_args_out(struct lsa_SetInfoPolicy *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_CreateAccount_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_CreateAccount *object = (struct lsa_CreateAccount *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_CreateAccount_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateAccount *object = (struct lsa_CreateAccount *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CreateAccount_in_get_sid(PyObject *obj, void *closure)
{
	struct lsa_CreateAccount *object = (struct lsa_CreateAccount *)pytalloc_get_ptr(obj);
	PyObject *py_sid;
	py_sid = pytalloc_reference_ex(dom_sid_Type, object->in.sid, object->in.sid);
	return py_sid;
}

static int py_lsa_CreateAccount_in_set_sid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateAccount *object = (struct lsa_CreateAccount *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.sid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sid");
		return -1;
	}
	object->in.sid = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.sid);
	if (object->in.sid == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(dom_sid_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.sid = (struct dom_sid *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CreateAccount_in_get_access_mask(PyObject *obj, void *closure)
{
	struct lsa_CreateAccount *object = (struct lsa_CreateAccount *)pytalloc_get_ptr(obj);
	PyObject *py_access_mask;
	py_access_mask = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.access_mask);
	return py_access_mask;
}

static int py_lsa_CreateAccount_in_set_access_mask(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateAccount *object = (struct lsa_CreateAccount *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.access_mask");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.access_mask));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_CreateAccount_out_get_acct_handle(PyObject *obj, void *closure)
{
	struct lsa_CreateAccount *object = (struct lsa_CreateAccount *)pytalloc_get_ptr(obj);
	PyObject *py_acct_handle;
	py_acct_handle = pytalloc_reference_ex(policy_handle_Type, object->out.acct_handle, object->out.acct_handle);
	return py_acct_handle;
}

static int py_lsa_CreateAccount_out_set_acct_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateAccount *object = (struct lsa_CreateAccount *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.acct_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.acct_handle");
		return -1;
	}
	object->out.acct_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.acct_handle);
	if (object->out.acct_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.acct_handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CreateAccount_get_result(PyObject *obj, void *closure)
{
	struct lsa_CreateAccount *object = (struct lsa_CreateAccount *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_CreateAccount_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateAccount *object = (struct lsa_CreateAccount *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_CreateAccount_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_CreateAccount_in_get_handle,
		.set = py_lsa_CreateAccount_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_sid"),
		.get = py_lsa_CreateAccount_in_get_sid,
		.set = py_lsa_CreateAccount_in_set_sid,
		.doc = discard_const_p(char, "PIDL-generated element of base type dom_sid2")
	},
	{
		.name = discard_const_p(char, "in_access_mask"),
		.get = py_lsa_CreateAccount_in_get_access_mask,
		.set = py_lsa_CreateAccount_in_set_access_mask,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_AccountAccessMask")
	},
	{
		.name = discard_const_p(char, "out_acct_handle"),
		.get = py_lsa_CreateAccount_out_get_acct_handle,
		.set = py_lsa_CreateAccount_out_set_acct_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_CreateAccount_get_result,
		.set = py_lsa_CreateAccount_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_CreateAccount_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_CreateAccount, type);
}

static PyObject *py_lsa_CreateAccount_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(10);
}

static PyObject *py_lsa_CreateAccount_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CreateAccount *object = (struct lsa_CreateAccount *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 11) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CreateAccount_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[10];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_CreateAccount_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_CreateAccount_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_CreateAccount_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_CreateAccount_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_CreateAccount_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CreateAccount *object = (struct lsa_CreateAccount *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 11) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CreateAccount_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[10];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_CreateAccount_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_CreateAccount_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_CreateAccount_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_CreateAccount_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_CreateAccount_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CreateAccount *object = (struct lsa_CreateAccount *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 11) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CreateAccount_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[10];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_CreateAccount_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_CreateAccount_ndr_print(py_obj, "lsa_CreateAccount_in", NDR_IN);
}

static PyObject *py_lsa_CreateAccount_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_CreateAccount_ndr_print(py_obj, "lsa_CreateAccount_out", NDR_OUT);
}

static PyMethodDef py_lsa_CreateAccount_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_CreateAccount_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.CreateAccount.opnum() -> 10 (0x0a) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_CreateAccount_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_CreateAccount_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_CreateAccount_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_CreateAccount_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_CreateAccount_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_CreateAccount_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_CreateAccount_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.CreateAccount",
	.tp_getset = py_lsa_CreateAccount_getsetters,
	.tp_methods = py_lsa_CreateAccount_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_CreateAccount_new,
};

static bool pack_py_lsa_CreateAccount_args_in(PyObject *args, PyObject *kwargs, struct lsa_CreateAccount *r)
{
	PyObject *py_handle;
	PyObject *py_sid;
	PyObject *py_access_mask;
	const char *kwnames[] = {
		"handle", "sid", "access_mask", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_CreateAccount", discard_const_p(char *, kwnames), &py_handle, &py_sid, &py_access_mask)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_sid == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sid");
		return false;
	}
	r->in.sid = talloc_ptrtype(r, r->in.sid);
	if (r->in.sid == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(dom_sid_Type, py_sid, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_sid)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.sid = (struct dom_sid *)pytalloc_get_ptr(py_sid);
	if (py_access_mask == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.access_mask");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.access_mask));
		if (PyLong_Check(py_access_mask)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_access_mask);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else if (PyInt_Check(py_access_mask)) {
			long test_var;
			test_var = PyInt_AsLong(py_access_mask);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_CreateAccount_args_out(struct lsa_CreateAccount *r)
{
	PyObject *result;
	PyObject *py_acct_handle;
	py_acct_handle = pytalloc_reference_ex(policy_handle_Type, r->out.acct_handle, r->out.acct_handle);
	result = py_acct_handle;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_EnumAccounts_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_EnumAccounts *object = (struct lsa_EnumAccounts *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_EnumAccounts_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumAccounts *object = (struct lsa_EnumAccounts *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_EnumAccounts_in_get_resume_handle(PyObject *obj, void *closure)
{
	struct lsa_EnumAccounts *object = (struct lsa_EnumAccounts *)pytalloc_get_ptr(obj);
	PyObject *py_resume_handle;
	py_resume_handle = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->in.resume_handle);
	return py_resume_handle;
}

static int py_lsa_EnumAccounts_in_set_resume_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumAccounts *object = (struct lsa_EnumAccounts *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.resume_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.resume_handle");
		return -1;
	}
	object->in.resume_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.resume_handle);
	if (object->in.resume_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->in.resume_handle));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.resume_handle = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.resume_handle = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_EnumAccounts_out_get_resume_handle(PyObject *obj, void *closure)
{
	struct lsa_EnumAccounts *object = (struct lsa_EnumAccounts *)pytalloc_get_ptr(obj);
	PyObject *py_resume_handle;
	py_resume_handle = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->out.resume_handle);
	return py_resume_handle;
}

static int py_lsa_EnumAccounts_out_set_resume_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumAccounts *object = (struct lsa_EnumAccounts *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.resume_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.resume_handle");
		return -1;
	}
	object->out.resume_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.resume_handle);
	if (object->out.resume_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->out.resume_handle));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.resume_handle = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.resume_handle = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_EnumAccounts_out_get_sids(PyObject *obj, void *closure)
{
	struct lsa_EnumAccounts *object = (struct lsa_EnumAccounts *)pytalloc_get_ptr(obj);
	PyObject *py_sids;
	py_sids = pytalloc_reference_ex(&lsa_SidArray_Type, object->out.sids, object->out.sids);
	return py_sids;
}

static int py_lsa_EnumAccounts_out_set_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumAccounts *object = (struct lsa_EnumAccounts *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.sids));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.sids");
		return -1;
	}
	object->out.sids = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.sids);
	if (object->out.sids == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_SidArray_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.sids = (struct lsa_SidArray *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_EnumAccounts_in_get_num_entries(PyObject *obj, void *closure)
{
	struct lsa_EnumAccounts *object = (struct lsa_EnumAccounts *)pytalloc_get_ptr(obj);
	PyObject *py_num_entries;
	py_num_entries = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.num_entries);
	return py_num_entries;
}

static int py_lsa_EnumAccounts_in_set_num_entries(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumAccounts *object = (struct lsa_EnumAccounts *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.num_entries");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.num_entries));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.num_entries = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.num_entries = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_EnumAccounts_get_result(PyObject *obj, void *closure)
{
	struct lsa_EnumAccounts *object = (struct lsa_EnumAccounts *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_EnumAccounts_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumAccounts *object = (struct lsa_EnumAccounts *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_EnumAccounts_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_EnumAccounts_in_get_handle,
		.set = py_lsa_EnumAccounts_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_resume_handle"),
		.get = py_lsa_EnumAccounts_in_get_resume_handle,
		.set = py_lsa_EnumAccounts_in_set_resume_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "out_resume_handle"),
		.get = py_lsa_EnumAccounts_out_get_resume_handle,
		.set = py_lsa_EnumAccounts_out_set_resume_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "out_sids"),
		.get = py_lsa_EnumAccounts_out_get_sids,
		.set = py_lsa_EnumAccounts_out_set_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_SidArray")
	},
	{
		.name = discard_const_p(char, "in_num_entries"),
		.get = py_lsa_EnumAccounts_in_get_num_entries,
		.set = py_lsa_EnumAccounts_in_set_num_entries,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_EnumAccounts_get_result,
		.set = py_lsa_EnumAccounts_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_EnumAccounts_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_EnumAccounts, type);
}

static PyObject *py_lsa_EnumAccounts_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(11);
}

static PyObject *py_lsa_EnumAccounts_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumAccounts *object = (struct lsa_EnumAccounts *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 12) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumAccounts_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[11];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_EnumAccounts_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_EnumAccounts_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_EnumAccounts_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_EnumAccounts_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_EnumAccounts_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumAccounts *object = (struct lsa_EnumAccounts *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 12) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumAccounts_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[11];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_EnumAccounts_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_EnumAccounts_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_EnumAccounts_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_EnumAccounts_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_EnumAccounts_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumAccounts *object = (struct lsa_EnumAccounts *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 12) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumAccounts_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[11];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_EnumAccounts_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_EnumAccounts_ndr_print(py_obj, "lsa_EnumAccounts_in", NDR_IN);
}

static PyObject *py_lsa_EnumAccounts_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_EnumAccounts_ndr_print(py_obj, "lsa_EnumAccounts_out", NDR_OUT);
}

static PyMethodDef py_lsa_EnumAccounts_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_EnumAccounts_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.EnumAccounts.opnum() -> 11 (0x0b) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_EnumAccounts_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_EnumAccounts_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_EnumAccounts_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_EnumAccounts_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_EnumAccounts_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_EnumAccounts_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_EnumAccounts_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.EnumAccounts",
	.tp_getset = py_lsa_EnumAccounts_getsetters,
	.tp_methods = py_lsa_EnumAccounts_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_EnumAccounts_new,
};

static bool pack_py_lsa_EnumAccounts_args_in(PyObject *args, PyObject *kwargs, struct lsa_EnumAccounts *r)
{
	PyObject *py_handle;
	PyObject *py_resume_handle;
	PyObject *py_num_entries;
	const char *kwnames[] = {
		"handle", "resume_handle", "num_entries", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_EnumAccounts", discard_const_p(char *, kwnames), &py_handle, &py_resume_handle, &py_num_entries)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_resume_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.resume_handle");
		return false;
	}
	r->in.resume_handle = talloc_ptrtype(r, r->in.resume_handle);
	if (r->in.resume_handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*r->in.resume_handle));
		if (PyLong_Check(py_resume_handle)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_resume_handle);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.resume_handle = test_var;
		} else if (PyInt_Check(py_resume_handle)) {
			long test_var;
			test_var = PyInt_AsLong(py_resume_handle);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.resume_handle = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_num_entries == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.num_entries");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.num_entries));
		if (PyLong_Check(py_num_entries)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_num_entries);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.num_entries = test_var;
		} else if (PyInt_Check(py_num_entries)) {
			long test_var;
			test_var = PyInt_AsLong(py_num_entries);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.num_entries = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_EnumAccounts_args_out(struct lsa_EnumAccounts *r)
{
	PyObject *result;
	PyObject *py_resume_handle;
	PyObject *py_sids;
	result = PyTuple_New(2);
	py_resume_handle = ndr_PyLong_FromUnsignedLongLong((uint32_t)*r->out.resume_handle);
	PyTuple_SetItem(result, 0, py_resume_handle);
	py_sids = pytalloc_reference_ex(&lsa_SidArray_Type, r->out.sids, r->out.sids);
	PyTuple_SetItem(result, 1, py_sids);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_CreateTrustedDomain_in_get_policy_handle(PyObject *obj, void *closure)
{
	struct lsa_CreateTrustedDomain *object = (struct lsa_CreateTrustedDomain *)pytalloc_get_ptr(obj);
	PyObject *py_policy_handle;
	py_policy_handle = pytalloc_reference_ex(policy_handle_Type, object->in.policy_handle, object->in.policy_handle);
	return py_policy_handle;
}

static int py_lsa_CreateTrustedDomain_in_set_policy_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateTrustedDomain *object = (struct lsa_CreateTrustedDomain *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.policy_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.policy_handle");
		return -1;
	}
	object->in.policy_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.policy_handle);
	if (object->in.policy_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.policy_handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CreateTrustedDomain_in_get_info(PyObject *obj, void *closure)
{
	struct lsa_CreateTrustedDomain *object = (struct lsa_CreateTrustedDomain *)pytalloc_get_ptr(obj);
	PyObject *py_info;
	py_info = pytalloc_reference_ex(&lsa_DomainInfo_Type, object->in.info, object->in.info);
	return py_info;
}

static int py_lsa_CreateTrustedDomain_in_set_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateTrustedDomain *object = (struct lsa_CreateTrustedDomain *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.info");
		return -1;
	}
	object->in.info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.info);
	if (object->in.info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_DomainInfo_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.info = (struct lsa_DomainInfo *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CreateTrustedDomain_in_get_access_mask(PyObject *obj, void *closure)
{
	struct lsa_CreateTrustedDomain *object = (struct lsa_CreateTrustedDomain *)pytalloc_get_ptr(obj);
	PyObject *py_access_mask;
	py_access_mask = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.access_mask);
	return py_access_mask;
}

static int py_lsa_CreateTrustedDomain_in_set_access_mask(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateTrustedDomain *object = (struct lsa_CreateTrustedDomain *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.access_mask");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.access_mask));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_CreateTrustedDomain_out_get_trustdom_handle(PyObject *obj, void *closure)
{
	struct lsa_CreateTrustedDomain *object = (struct lsa_CreateTrustedDomain *)pytalloc_get_ptr(obj);
	PyObject *py_trustdom_handle;
	py_trustdom_handle = pytalloc_reference_ex(policy_handle_Type, object->out.trustdom_handle, object->out.trustdom_handle);
	return py_trustdom_handle;
}

static int py_lsa_CreateTrustedDomain_out_set_trustdom_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateTrustedDomain *object = (struct lsa_CreateTrustedDomain *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.trustdom_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.trustdom_handle");
		return -1;
	}
	object->out.trustdom_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.trustdom_handle);
	if (object->out.trustdom_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.trustdom_handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CreateTrustedDomain_get_result(PyObject *obj, void *closure)
{
	struct lsa_CreateTrustedDomain *object = (struct lsa_CreateTrustedDomain *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_CreateTrustedDomain_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateTrustedDomain *object = (struct lsa_CreateTrustedDomain *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_CreateTrustedDomain_getsetters[] = {
	{
		.name = discard_const_p(char, "in_policy_handle"),
		.get = py_lsa_CreateTrustedDomain_in_get_policy_handle,
		.set = py_lsa_CreateTrustedDomain_in_set_policy_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_info"),
		.get = py_lsa_CreateTrustedDomain_in_get_info,
		.set = py_lsa_CreateTrustedDomain_in_set_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DomainInfo")
	},
	{
		.name = discard_const_p(char, "in_access_mask"),
		.get = py_lsa_CreateTrustedDomain_in_get_access_mask,
		.set = py_lsa_CreateTrustedDomain_in_set_access_mask,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustedAccessMask")
	},
	{
		.name = discard_const_p(char, "out_trustdom_handle"),
		.get = py_lsa_CreateTrustedDomain_out_get_trustdom_handle,
		.set = py_lsa_CreateTrustedDomain_out_set_trustdom_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_CreateTrustedDomain_get_result,
		.set = py_lsa_CreateTrustedDomain_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_CreateTrustedDomain_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_CreateTrustedDomain, type);
}

static PyObject *py_lsa_CreateTrustedDomain_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(12);
}

static PyObject *py_lsa_CreateTrustedDomain_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CreateTrustedDomain *object = (struct lsa_CreateTrustedDomain *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 13) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CreateTrustedDomain_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[12];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_CreateTrustedDomain_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_CreateTrustedDomain_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_CreateTrustedDomain_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_CreateTrustedDomain_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_CreateTrustedDomain_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CreateTrustedDomain *object = (struct lsa_CreateTrustedDomain *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 13) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CreateTrustedDomain_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[12];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_CreateTrustedDomain_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_CreateTrustedDomain_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_CreateTrustedDomain_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_CreateTrustedDomain_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_CreateTrustedDomain_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CreateTrustedDomain *object = (struct lsa_CreateTrustedDomain *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 13) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CreateTrustedDomain_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[12];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_CreateTrustedDomain_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_CreateTrustedDomain_ndr_print(py_obj, "lsa_CreateTrustedDomain_in", NDR_IN);
}

static PyObject *py_lsa_CreateTrustedDomain_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_CreateTrustedDomain_ndr_print(py_obj, "lsa_CreateTrustedDomain_out", NDR_OUT);
}

static PyMethodDef py_lsa_CreateTrustedDomain_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_CreateTrustedDomain_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.CreateTrustedDomain.opnum() -> 12 (0x0c) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_CreateTrustedDomain_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_CreateTrustedDomain_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_CreateTrustedDomain_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_CreateTrustedDomain_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_CreateTrustedDomain_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_CreateTrustedDomain_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_CreateTrustedDomain_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.CreateTrustedDomain",
	.tp_getset = py_lsa_CreateTrustedDomain_getsetters,
	.tp_methods = py_lsa_CreateTrustedDomain_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_CreateTrustedDomain_new,
};

static bool pack_py_lsa_CreateTrustedDomain_args_in(PyObject *args, PyObject *kwargs, struct lsa_CreateTrustedDomain *r)
{
	PyObject *py_policy_handle;
	PyObject *py_info;
	PyObject *py_access_mask;
	const char *kwnames[] = {
		"policy_handle", "info", "access_mask", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_CreateTrustedDomain", discard_const_p(char *, kwnames), &py_policy_handle, &py_info, &py_access_mask)) {
		return false;
	}

	if (py_policy_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.policy_handle");
		return false;
	}
	r->in.policy_handle = talloc_ptrtype(r, r->in.policy_handle);
	if (r->in.policy_handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_policy_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_policy_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.policy_handle = (struct policy_handle *)pytalloc_get_ptr(py_policy_handle);
	if (py_info == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.info");
		return false;
	}
	r->in.info = talloc_ptrtype(r, r->in.info);
	if (r->in.info == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_DomainInfo_Type, py_info, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_info)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.info = (struct lsa_DomainInfo *)pytalloc_get_ptr(py_info);
	if (py_access_mask == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.access_mask");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.access_mask));
		if (PyLong_Check(py_access_mask)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_access_mask);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else if (PyInt_Check(py_access_mask)) {
			long test_var;
			test_var = PyInt_AsLong(py_access_mask);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_CreateTrustedDomain_args_out(struct lsa_CreateTrustedDomain *r)
{
	PyObject *result;
	PyObject *py_trustdom_handle;
	py_trustdom_handle = pytalloc_reference_ex(policy_handle_Type, r->out.trustdom_handle, r->out.trustdom_handle);
	result = py_trustdom_handle;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_EnumTrustDom_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_EnumTrustDom *object = (struct lsa_EnumTrustDom *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_EnumTrustDom_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumTrustDom *object = (struct lsa_EnumTrustDom *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_EnumTrustDom_in_get_resume_handle(PyObject *obj, void *closure)
{
	struct lsa_EnumTrustDom *object = (struct lsa_EnumTrustDom *)pytalloc_get_ptr(obj);
	PyObject *py_resume_handle;
	py_resume_handle = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->in.resume_handle);
	return py_resume_handle;
}

static int py_lsa_EnumTrustDom_in_set_resume_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumTrustDom *object = (struct lsa_EnumTrustDom *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.resume_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.resume_handle");
		return -1;
	}
	object->in.resume_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.resume_handle);
	if (object->in.resume_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->in.resume_handle));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.resume_handle = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.resume_handle = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_EnumTrustDom_out_get_resume_handle(PyObject *obj, void *closure)
{
	struct lsa_EnumTrustDom *object = (struct lsa_EnumTrustDom *)pytalloc_get_ptr(obj);
	PyObject *py_resume_handle;
	py_resume_handle = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->out.resume_handle);
	return py_resume_handle;
}

static int py_lsa_EnumTrustDom_out_set_resume_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumTrustDom *object = (struct lsa_EnumTrustDom *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.resume_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.resume_handle");
		return -1;
	}
	object->out.resume_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.resume_handle);
	if (object->out.resume_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->out.resume_handle));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.resume_handle = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.resume_handle = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_EnumTrustDom_out_get_domains(PyObject *obj, void *closure)
{
	struct lsa_EnumTrustDom *object = (struct lsa_EnumTrustDom *)pytalloc_get_ptr(obj);
	PyObject *py_domains;
	py_domains = pytalloc_reference_ex(&lsa_DomainList_Type, object->out.domains, object->out.domains);
	return py_domains;
}

static int py_lsa_EnumTrustDom_out_set_domains(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumTrustDom *object = (struct lsa_EnumTrustDom *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.domains));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.domains");
		return -1;
	}
	object->out.domains = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.domains);
	if (object->out.domains == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_DomainList_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.domains = (struct lsa_DomainList *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_EnumTrustDom_in_get_max_size(PyObject *obj, void *closure)
{
	struct lsa_EnumTrustDom *object = (struct lsa_EnumTrustDom *)pytalloc_get_ptr(obj);
	PyObject *py_max_size;
	py_max_size = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.max_size);
	return py_max_size;
}

static int py_lsa_EnumTrustDom_in_set_max_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumTrustDom *object = (struct lsa_EnumTrustDom *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.max_size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.max_size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.max_size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.max_size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_EnumTrustDom_get_result(PyObject *obj, void *closure)
{
	struct lsa_EnumTrustDom *object = (struct lsa_EnumTrustDom *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_EnumTrustDom_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumTrustDom *object = (struct lsa_EnumTrustDom *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_EnumTrustDom_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_EnumTrustDom_in_get_handle,
		.set = py_lsa_EnumTrustDom_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_resume_handle"),
		.get = py_lsa_EnumTrustDom_in_get_resume_handle,
		.set = py_lsa_EnumTrustDom_in_set_resume_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "out_resume_handle"),
		.get = py_lsa_EnumTrustDom_out_get_resume_handle,
		.set = py_lsa_EnumTrustDom_out_set_resume_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "out_domains"),
		.get = py_lsa_EnumTrustDom_out_get_domains,
		.set = py_lsa_EnumTrustDom_out_set_domains,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DomainList")
	},
	{
		.name = discard_const_p(char, "in_max_size"),
		.get = py_lsa_EnumTrustDom_in_get_max_size,
		.set = py_lsa_EnumTrustDom_in_set_max_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_EnumTrustDom_get_result,
		.set = py_lsa_EnumTrustDom_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_EnumTrustDom_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_EnumTrustDom, type);
}

static PyObject *py_lsa_EnumTrustDom_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(13);
}

static PyObject *py_lsa_EnumTrustDom_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumTrustDom *object = (struct lsa_EnumTrustDom *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 14) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumTrustDom_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[13];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_EnumTrustDom_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_EnumTrustDom_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_EnumTrustDom_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_EnumTrustDom_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_EnumTrustDom_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumTrustDom *object = (struct lsa_EnumTrustDom *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 14) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumTrustDom_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[13];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_EnumTrustDom_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_EnumTrustDom_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_EnumTrustDom_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_EnumTrustDom_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_EnumTrustDom_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumTrustDom *object = (struct lsa_EnumTrustDom *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 14) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumTrustDom_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[13];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_EnumTrustDom_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_EnumTrustDom_ndr_print(py_obj, "lsa_EnumTrustDom_in", NDR_IN);
}

static PyObject *py_lsa_EnumTrustDom_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_EnumTrustDom_ndr_print(py_obj, "lsa_EnumTrustDom_out", NDR_OUT);
}

static PyMethodDef py_lsa_EnumTrustDom_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_EnumTrustDom_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.EnumTrustDom.opnum() -> 13 (0x0d) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_EnumTrustDom_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_EnumTrustDom_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_EnumTrustDom_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_EnumTrustDom_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_EnumTrustDom_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_EnumTrustDom_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_EnumTrustDom_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.EnumTrustDom",
	.tp_getset = py_lsa_EnumTrustDom_getsetters,
	.tp_methods = py_lsa_EnumTrustDom_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_EnumTrustDom_new,
};

static bool pack_py_lsa_EnumTrustDom_args_in(PyObject *args, PyObject *kwargs, struct lsa_EnumTrustDom *r)
{
	PyObject *py_handle;
	PyObject *py_resume_handle;
	PyObject *py_max_size;
	const char *kwnames[] = {
		"handle", "resume_handle", "max_size", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_EnumTrustDom", discard_const_p(char *, kwnames), &py_handle, &py_resume_handle, &py_max_size)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_resume_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.resume_handle");
		return false;
	}
	r->in.resume_handle = talloc_ptrtype(r, r->in.resume_handle);
	if (r->in.resume_handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*r->in.resume_handle));
		if (PyLong_Check(py_resume_handle)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_resume_handle);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.resume_handle = test_var;
		} else if (PyInt_Check(py_resume_handle)) {
			long test_var;
			test_var = PyInt_AsLong(py_resume_handle);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.resume_handle = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_max_size == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.max_size");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.max_size));
		if (PyLong_Check(py_max_size)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_max_size);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.max_size = test_var;
		} else if (PyInt_Check(py_max_size)) {
			long test_var;
			test_var = PyInt_AsLong(py_max_size);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.max_size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_EnumTrustDom_args_out(struct lsa_EnumTrustDom *r)
{
	PyObject *result;
	PyObject *py_resume_handle;
	PyObject *py_domains;
	result = PyTuple_New(2);
	py_resume_handle = ndr_PyLong_FromUnsignedLongLong((uint32_t)*r->out.resume_handle);
	PyTuple_SetItem(result, 0, py_resume_handle);
	py_domains = pytalloc_reference_ex(&lsa_DomainList_Type, r->out.domains, r->out.domains);
	PyTuple_SetItem(result, 1, py_domains);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_LookupNames_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_LookupNames_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupNames_in_get_num_names(PyObject *obj, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(obj);
	PyObject *py_num_names;
	py_num_names = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.num_names);
	return py_num_names;
}

static int py_lsa_LookupNames_in_set_num_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.num_names");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.num_names));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.num_names = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.num_names = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames_in_get_names(PyObject *obj, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(obj);
	PyObject *py_names;
	py_names = PyList_New(object->in.num_names);
	if (py_names == NULL) {
		return NULL;
	}
	{
		int names_cntr_0;
		for (names_cntr_0 = 0; names_cntr_0 < (object->in.num_names); names_cntr_0++) {
			PyObject *py_names_0;
			py_names_0 = pytalloc_reference_ex(&lsa_String_Type, object->in.names, &object->in.names[names_cntr_0]);
			PyList_SetItem(py_names, names_cntr_0, py_names_0);
		}
	}
	return py_names;
}

static int py_lsa_LookupNames_in_set_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.names");
		return -1;
	}
	PY_CHECK_TYPE(&PyList_Type, value, return -1;);
	{
		int names_cntr_0;
		object->in.names = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.names, PyList_GET_SIZE(value));
		if (!object->in.names) { return -1;; }
		talloc_set_name_const(object->in.names, "ARRAY: object->in.names");
		for (names_cntr_0 = 0; names_cntr_0 < PyList_GET_SIZE(value); names_cntr_0++) {
			if (PyList_GET_ITEM(value, names_cntr_0) == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.names[names_cntr_0]");
				return -1;
			}
			PY_CHECK_TYPE(&lsa_String_Type, PyList_GET_ITEM(value, names_cntr_0), return -1;);
			if (talloc_reference(object->in.names, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, names_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->in.names[names_cntr_0] = *(struct lsa_String *)pytalloc_get_ptr(PyList_GET_ITEM(value, names_cntr_0));
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames_out_get_domains(PyObject *obj, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(obj);
	PyObject *py_domains;
	if (*object->out.domains == NULL) {
		py_domains = Py_None;
		Py_INCREF(py_domains);
	} else {
		py_domains = pytalloc_reference_ex(&lsa_RefDomainList_Type, *object->out.domains, *object->out.domains);
	}
	return py_domains;
}

static int py_lsa_LookupNames_out_set_domains(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.domains));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.domains");
		return -1;
	}
	object->out.domains = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.domains);
	if (object->out.domains == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.domains = NULL;
	} else {
		*object->out.domains = NULL;
		PY_CHECK_TYPE(&lsa_RefDomainList_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		*object->out.domains = (struct lsa_RefDomainList *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_LookupNames_in_get_sids(PyObject *obj, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(obj);
	PyObject *py_sids;
	py_sids = pytalloc_reference_ex(&lsa_TransSidArray_Type, object->in.sids, object->in.sids);
	return py_sids;
}

static int py_lsa_LookupNames_in_set_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.sids));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sids");
		return -1;
	}
	object->in.sids = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.sids);
	if (object->in.sids == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TransSidArray_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.sids = (struct lsa_TransSidArray *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupNames_out_get_sids(PyObject *obj, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(obj);
	PyObject *py_sids;
	py_sids = pytalloc_reference_ex(&lsa_TransSidArray_Type, object->out.sids, object->out.sids);
	return py_sids;
}

static int py_lsa_LookupNames_out_set_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.sids));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.sids");
		return -1;
	}
	object->out.sids = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.sids);
	if (object->out.sids == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TransSidArray_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.sids = (struct lsa_TransSidArray *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupNames_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_LookupNames_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames_in_get_count(PyObject *obj, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->in.count);
	return py_count;
}

static int py_lsa_LookupNames_in_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.count));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.count");
		return -1;
	}
	object->in.count = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.count);
	if (object->in.count == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->in.count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames_out_get_count(PyObject *obj, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->out.count);
	return py_count;
}

static int py_lsa_LookupNames_out_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.count));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.count");
		return -1;
	}
	object->out.count = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.count);
	if (object->out.count == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->out.count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames_get_result(PyObject *obj, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_LookupNames_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_LookupNames_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_LookupNames_in_get_handle,
		.set = py_lsa_LookupNames_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_num_names"),
		.get = py_lsa_LookupNames_in_get_num_names,
		.set = py_lsa_LookupNames_in_set_num_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "in_names"),
		.get = py_lsa_LookupNames_in_get_names,
		.set = py_lsa_LookupNames_in_set_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "out_domains"),
		.get = py_lsa_LookupNames_out_get_domains,
		.set = py_lsa_LookupNames_out_set_domains,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_RefDomainList")
	},
	{
		.name = discard_const_p(char, "in_sids"),
		.get = py_lsa_LookupNames_in_get_sids,
		.set = py_lsa_LookupNames_in_set_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TransSidArray")
	},
	{
		.name = discard_const_p(char, "out_sids"),
		.get = py_lsa_LookupNames_out_get_sids,
		.set = py_lsa_LookupNames_out_set_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TransSidArray")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_LookupNames_in_get_level,
		.set = py_lsa_LookupNames_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_LookupNamesLevel")
	},
	{
		.name = discard_const_p(char, "in_count"),
		.get = py_lsa_LookupNames_in_get_count,
		.set = py_lsa_LookupNames_in_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "out_count"),
		.get = py_lsa_LookupNames_out_get_count,
		.set = py_lsa_LookupNames_out_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_LookupNames_get_result,
		.set = py_lsa_LookupNames_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_LookupNames_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_LookupNames, type);
}

static PyObject *py_lsa_LookupNames_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(14);
}

static PyObject *py_lsa_LookupNames_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 15) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupNames_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[14];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_LookupNames_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupNames_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_LookupNames_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupNames_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_LookupNames_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 15) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupNames_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[14];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_LookupNames_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupNames_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupNames_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupNames_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupNames_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupNames *object = (struct lsa_LookupNames *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 15) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupNames_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[14];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_LookupNames_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_LookupNames_ndr_print(py_obj, "lsa_LookupNames_in", NDR_IN);
}

static PyObject *py_lsa_LookupNames_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_LookupNames_ndr_print(py_obj, "lsa_LookupNames_out", NDR_OUT);
}

static PyMethodDef py_lsa_LookupNames_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_LookupNames_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.LookupNames.opnum() -> 14 (0x0e) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_LookupNames_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_LookupNames_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_LookupNames_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_LookupNames_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_LookupNames_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_LookupNames_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_LookupNames_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.LookupNames",
	.tp_getset = py_lsa_LookupNames_getsetters,
	.tp_methods = py_lsa_LookupNames_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_LookupNames_new,
};

static bool pack_py_lsa_LookupNames_args_in(PyObject *args, PyObject *kwargs, struct lsa_LookupNames *r)
{
	PyObject *py_handle;
	PyObject *py_names;
	PyObject *py_sids;
	PyObject *py_level;
	PyObject *py_count;
	const char *kwnames[] = {
		"handle", "names", "sids", "level", "count", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOOO:lsa_LookupNames", discard_const_p(char *, kwnames), &py_handle, &py_names, &py_sids, &py_level, &py_count)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	PY_CHECK_TYPE(&PyList_Type, py_names, return false;);
	r->in.num_names = PyList_GET_SIZE(py_names);
	if (py_names == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.names");
		return false;
	}
	PY_CHECK_TYPE(&PyList_Type, py_names, return false;);
	{
		int names_cntr_0;
		r->in.names = talloc_array_ptrtype(r, r->in.names, PyList_GET_SIZE(py_names));
		if (!r->in.names) { return false;; }
		talloc_set_name_const(r->in.names, "ARRAY: r->in.names");
		for (names_cntr_0 = 0; names_cntr_0 < PyList_GET_SIZE(py_names); names_cntr_0++) {
			if (PyList_GET_ITEM(py_names, names_cntr_0) == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.names[names_cntr_0]");
				return false;
			}
			PY_CHECK_TYPE(&lsa_String_Type, PyList_GET_ITEM(py_names, names_cntr_0), return false;);
			if (talloc_reference(r->in.names, pytalloc_get_mem_ctx(PyList_GET_ITEM(py_names, names_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return false;
			}
			r->in.names[names_cntr_0] = *(struct lsa_String *)pytalloc_get_ptr(PyList_GET_ITEM(py_names, names_cntr_0));
		}
	}
	if (py_sids == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sids");
		return false;
	}
	r->in.sids = talloc_ptrtype(r, r->in.sids);
	if (r->in.sids == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_TransSidArray_Type, py_sids, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_sids)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.sids = (struct lsa_TransSidArray *)pytalloc_get_ptr(py_sids);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_count == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.count");
		return false;
	}
	r->in.count = talloc_ptrtype(r, r->in.count);
	if (r->in.count == NULL) {
		PyErr_NoMemory();
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*r->in.count));
		if (PyLong_Check(py_count)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_count);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.count = test_var;
		} else if (PyInt_Check(py_count)) {
			long test_var;
			test_var = PyInt_AsLong(py_count);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_LookupNames_args_out(struct lsa_LookupNames *r)
{
	PyObject *result;
	PyObject *py_domains;
	PyObject *py_sids;
	PyObject *py_count;
	result = PyTuple_New(3);
	if (*r->out.domains == NULL) {
		py_domains = Py_None;
		Py_INCREF(py_domains);
	} else {
		py_domains = pytalloc_reference_ex(&lsa_RefDomainList_Type, *r->out.domains, *r->out.domains);
	}
	PyTuple_SetItem(result, 0, py_domains);
	py_sids = pytalloc_reference_ex(&lsa_TransSidArray_Type, r->out.sids, r->out.sids);
	PyTuple_SetItem(result, 1, py_sids);
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*r->out.count);
	PyTuple_SetItem(result, 2, py_count);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_LookupSids_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_LookupSids_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupSids_in_get_sids(PyObject *obj, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(obj);
	PyObject *py_sids;
	py_sids = pytalloc_reference_ex(&lsa_SidArray_Type, object->in.sids, object->in.sids);
	return py_sids;
}

static int py_lsa_LookupSids_in_set_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.sids));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sids");
		return -1;
	}
	object->in.sids = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.sids);
	if (object->in.sids == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_SidArray_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.sids = (struct lsa_SidArray *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupSids_out_get_domains(PyObject *obj, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(obj);
	PyObject *py_domains;
	if (*object->out.domains == NULL) {
		py_domains = Py_None;
		Py_INCREF(py_domains);
	} else {
		py_domains = pytalloc_reference_ex(&lsa_RefDomainList_Type, *object->out.domains, *object->out.domains);
	}
	return py_domains;
}

static int py_lsa_LookupSids_out_set_domains(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.domains));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.domains");
		return -1;
	}
	object->out.domains = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.domains);
	if (object->out.domains == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.domains = NULL;
	} else {
		*object->out.domains = NULL;
		PY_CHECK_TYPE(&lsa_RefDomainList_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		*object->out.domains = (struct lsa_RefDomainList *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_LookupSids_in_get_names(PyObject *obj, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(obj);
	PyObject *py_names;
	py_names = pytalloc_reference_ex(&lsa_TransNameArray_Type, object->in.names, object->in.names);
	return py_names;
}

static int py_lsa_LookupSids_in_set_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.names));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.names");
		return -1;
	}
	object->in.names = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.names);
	if (object->in.names == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TransNameArray_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.names = (struct lsa_TransNameArray *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupSids_out_get_names(PyObject *obj, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(obj);
	PyObject *py_names;
	py_names = pytalloc_reference_ex(&lsa_TransNameArray_Type, object->out.names, object->out.names);
	return py_names;
}

static int py_lsa_LookupSids_out_set_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.names));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.names");
		return -1;
	}
	object->out.names = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.names);
	if (object->out.names == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TransNameArray_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.names = (struct lsa_TransNameArray *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupSids_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_LookupSids_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupSids_in_get_count(PyObject *obj, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->in.count);
	return py_count;
}

static int py_lsa_LookupSids_in_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.count));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.count");
		return -1;
	}
	object->in.count = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.count);
	if (object->in.count == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->in.count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupSids_out_get_count(PyObject *obj, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->out.count);
	return py_count;
}

static int py_lsa_LookupSids_out_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.count));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.count");
		return -1;
	}
	object->out.count = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.count);
	if (object->out.count == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->out.count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupSids_get_result(PyObject *obj, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_LookupSids_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_LookupSids_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_LookupSids_in_get_handle,
		.set = py_lsa_LookupSids_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_sids"),
		.get = py_lsa_LookupSids_in_get_sids,
		.set = py_lsa_LookupSids_in_set_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_SidArray")
	},
	{
		.name = discard_const_p(char, "out_domains"),
		.get = py_lsa_LookupSids_out_get_domains,
		.set = py_lsa_LookupSids_out_set_domains,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_RefDomainList")
	},
	{
		.name = discard_const_p(char, "in_names"),
		.get = py_lsa_LookupSids_in_get_names,
		.set = py_lsa_LookupSids_in_set_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TransNameArray")
	},
	{
		.name = discard_const_p(char, "out_names"),
		.get = py_lsa_LookupSids_out_get_names,
		.set = py_lsa_LookupSids_out_set_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TransNameArray")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_LookupSids_in_get_level,
		.set = py_lsa_LookupSids_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_LookupNamesLevel")
	},
	{
		.name = discard_const_p(char, "in_count"),
		.get = py_lsa_LookupSids_in_get_count,
		.set = py_lsa_LookupSids_in_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "out_count"),
		.get = py_lsa_LookupSids_out_get_count,
		.set = py_lsa_LookupSids_out_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_LookupSids_get_result,
		.set = py_lsa_LookupSids_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_LookupSids_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_LookupSids, type);
}

static PyObject *py_lsa_LookupSids_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(15);
}

static PyObject *py_lsa_LookupSids_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 16) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupSids_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[15];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_LookupSids_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupSids_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_LookupSids_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupSids_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_LookupSids_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 16) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupSids_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[15];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_LookupSids_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupSids_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupSids_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupSids_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupSids_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupSids *object = (struct lsa_LookupSids *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 16) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupSids_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[15];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_LookupSids_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_LookupSids_ndr_print(py_obj, "lsa_LookupSids_in", NDR_IN);
}

static PyObject *py_lsa_LookupSids_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_LookupSids_ndr_print(py_obj, "lsa_LookupSids_out", NDR_OUT);
}

static PyMethodDef py_lsa_LookupSids_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_LookupSids_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.LookupSids.opnum() -> 15 (0x0f) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_LookupSids_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_LookupSids_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_LookupSids_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_LookupSids_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_LookupSids_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_LookupSids_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_LookupSids_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.LookupSids",
	.tp_getset = py_lsa_LookupSids_getsetters,
	.tp_methods = py_lsa_LookupSids_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_LookupSids_new,
};

static bool pack_py_lsa_LookupSids_args_in(PyObject *args, PyObject *kwargs, struct lsa_LookupSids *r)
{
	PyObject *py_handle;
	PyObject *py_sids;
	PyObject *py_names;
	PyObject *py_level;
	PyObject *py_count;
	const char *kwnames[] = {
		"handle", "sids", "names", "level", "count", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOOO:lsa_LookupSids", discard_const_p(char *, kwnames), &py_handle, &py_sids, &py_names, &py_level, &py_count)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_sids == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sids");
		return false;
	}
	r->in.sids = talloc_ptrtype(r, r->in.sids);
	if (r->in.sids == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_SidArray_Type, py_sids, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_sids)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.sids = (struct lsa_SidArray *)pytalloc_get_ptr(py_sids);
	if (py_names == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.names");
		return false;
	}
	r->in.names = talloc_ptrtype(r, r->in.names);
	if (r->in.names == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_TransNameArray_Type, py_names, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_names)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.names = (struct lsa_TransNameArray *)pytalloc_get_ptr(py_names);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_count == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.count");
		return false;
	}
	r->in.count = talloc_ptrtype(r, r->in.count);
	if (r->in.count == NULL) {
		PyErr_NoMemory();
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*r->in.count));
		if (PyLong_Check(py_count)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_count);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.count = test_var;
		} else if (PyInt_Check(py_count)) {
			long test_var;
			test_var = PyInt_AsLong(py_count);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_LookupSids_args_out(struct lsa_LookupSids *r)
{
	PyObject *result;
	PyObject *py_domains;
	PyObject *py_names;
	PyObject *py_count;
	result = PyTuple_New(3);
	if (*r->out.domains == NULL) {
		py_domains = Py_None;
		Py_INCREF(py_domains);
	} else {
		py_domains = pytalloc_reference_ex(&lsa_RefDomainList_Type, *r->out.domains, *r->out.domains);
	}
	PyTuple_SetItem(result, 0, py_domains);
	py_names = pytalloc_reference_ex(&lsa_TransNameArray_Type, r->out.names, r->out.names);
	PyTuple_SetItem(result, 1, py_names);
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*r->out.count);
	PyTuple_SetItem(result, 2, py_count);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_CreateSecret_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_CreateSecret *object = (struct lsa_CreateSecret *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_CreateSecret_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateSecret *object = (struct lsa_CreateSecret *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CreateSecret_in_get_name(PyObject *obj, void *closure)
{
	struct lsa_CreateSecret *object = (struct lsa_CreateSecret *)pytalloc_get_ptr(obj);
	PyObject *py_name;
	py_name = pytalloc_reference_ex(&lsa_String_Type, pytalloc_get_mem_ctx(obj), &object->in.name);
	return py_name;
}

static int py_lsa_CreateSecret_in_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateSecret *object = (struct lsa_CreateSecret *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.name");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.name = *(struct lsa_String *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CreateSecret_in_get_access_mask(PyObject *obj, void *closure)
{
	struct lsa_CreateSecret *object = (struct lsa_CreateSecret *)pytalloc_get_ptr(obj);
	PyObject *py_access_mask;
	py_access_mask = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.access_mask);
	return py_access_mask;
}

static int py_lsa_CreateSecret_in_set_access_mask(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateSecret *object = (struct lsa_CreateSecret *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.access_mask");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.access_mask));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_CreateSecret_out_get_sec_handle(PyObject *obj, void *closure)
{
	struct lsa_CreateSecret *object = (struct lsa_CreateSecret *)pytalloc_get_ptr(obj);
	PyObject *py_sec_handle;
	py_sec_handle = pytalloc_reference_ex(policy_handle_Type, object->out.sec_handle, object->out.sec_handle);
	return py_sec_handle;
}

static int py_lsa_CreateSecret_out_set_sec_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateSecret *object = (struct lsa_CreateSecret *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.sec_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.sec_handle");
		return -1;
	}
	object->out.sec_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.sec_handle);
	if (object->out.sec_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.sec_handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CreateSecret_get_result(PyObject *obj, void *closure)
{
	struct lsa_CreateSecret *object = (struct lsa_CreateSecret *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_CreateSecret_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateSecret *object = (struct lsa_CreateSecret *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_CreateSecret_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_CreateSecret_in_get_handle,
		.set = py_lsa_CreateSecret_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_name"),
		.get = py_lsa_CreateSecret_in_get_name,
		.set = py_lsa_CreateSecret_in_set_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "in_access_mask"),
		.get = py_lsa_CreateSecret_in_get_access_mask,
		.set = py_lsa_CreateSecret_in_set_access_mask,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_SecretAccessMask")
	},
	{
		.name = discard_const_p(char, "out_sec_handle"),
		.get = py_lsa_CreateSecret_out_get_sec_handle,
		.set = py_lsa_CreateSecret_out_set_sec_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_CreateSecret_get_result,
		.set = py_lsa_CreateSecret_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_CreateSecret_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_CreateSecret, type);
}

static PyObject *py_lsa_CreateSecret_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(16);
}

static PyObject *py_lsa_CreateSecret_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CreateSecret *object = (struct lsa_CreateSecret *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 17) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CreateSecret_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[16];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_CreateSecret_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_CreateSecret_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_CreateSecret_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_CreateSecret_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_CreateSecret_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CreateSecret *object = (struct lsa_CreateSecret *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 17) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CreateSecret_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[16];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_CreateSecret_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_CreateSecret_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_CreateSecret_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_CreateSecret_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_CreateSecret_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CreateSecret *object = (struct lsa_CreateSecret *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 17) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CreateSecret_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[16];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_CreateSecret_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_CreateSecret_ndr_print(py_obj, "lsa_CreateSecret_in", NDR_IN);
}

static PyObject *py_lsa_CreateSecret_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_CreateSecret_ndr_print(py_obj, "lsa_CreateSecret_out", NDR_OUT);
}

static PyMethodDef py_lsa_CreateSecret_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_CreateSecret_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.CreateSecret.opnum() -> 16 (0x10) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_CreateSecret_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_CreateSecret_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_CreateSecret_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_CreateSecret_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_CreateSecret_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_CreateSecret_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_CreateSecret_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.CreateSecret",
	.tp_getset = py_lsa_CreateSecret_getsetters,
	.tp_methods = py_lsa_CreateSecret_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_CreateSecret_new,
};

static bool pack_py_lsa_CreateSecret_args_in(PyObject *args, PyObject *kwargs, struct lsa_CreateSecret *r)
{
	PyObject *py_handle;
	PyObject *py_name;
	PyObject *py_access_mask;
	const char *kwnames[] = {
		"handle", "name", "access_mask", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_CreateSecret", discard_const_p(char *, kwnames), &py_handle, &py_name, &py_access_mask)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_name == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.name");
		return false;
	}
	PY_CHECK_TYPE(&lsa_String_Type, py_name, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_name)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.name = *(struct lsa_String *)pytalloc_get_ptr(py_name);
	if (py_access_mask == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.access_mask");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.access_mask));
		if (PyLong_Check(py_access_mask)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_access_mask);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else if (PyInt_Check(py_access_mask)) {
			long test_var;
			test_var = PyInt_AsLong(py_access_mask);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_CreateSecret_args_out(struct lsa_CreateSecret *r)
{
	PyObject *result;
	PyObject *py_sec_handle;
	py_sec_handle = pytalloc_reference_ex(policy_handle_Type, r->out.sec_handle, r->out.sec_handle);
	result = py_sec_handle;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_OpenAccount_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_OpenAccount *object = (struct lsa_OpenAccount *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_OpenAccount_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenAccount *object = (struct lsa_OpenAccount *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_OpenAccount_in_get_sid(PyObject *obj, void *closure)
{
	struct lsa_OpenAccount *object = (struct lsa_OpenAccount *)pytalloc_get_ptr(obj);
	PyObject *py_sid;
	py_sid = pytalloc_reference_ex(dom_sid_Type, object->in.sid, object->in.sid);
	return py_sid;
}

static int py_lsa_OpenAccount_in_set_sid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenAccount *object = (struct lsa_OpenAccount *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.sid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sid");
		return -1;
	}
	object->in.sid = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.sid);
	if (object->in.sid == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(dom_sid_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.sid = (struct dom_sid *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_OpenAccount_in_get_access_mask(PyObject *obj, void *closure)
{
	struct lsa_OpenAccount *object = (struct lsa_OpenAccount *)pytalloc_get_ptr(obj);
	PyObject *py_access_mask;
	py_access_mask = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.access_mask);
	return py_access_mask;
}

static int py_lsa_OpenAccount_in_set_access_mask(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenAccount *object = (struct lsa_OpenAccount *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.access_mask");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.access_mask));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_OpenAccount_out_get_acct_handle(PyObject *obj, void *closure)
{
	struct lsa_OpenAccount *object = (struct lsa_OpenAccount *)pytalloc_get_ptr(obj);
	PyObject *py_acct_handle;
	py_acct_handle = pytalloc_reference_ex(policy_handle_Type, object->out.acct_handle, object->out.acct_handle);
	return py_acct_handle;
}

static int py_lsa_OpenAccount_out_set_acct_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenAccount *object = (struct lsa_OpenAccount *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.acct_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.acct_handle");
		return -1;
	}
	object->out.acct_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.acct_handle);
	if (object->out.acct_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.acct_handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_OpenAccount_get_result(PyObject *obj, void *closure)
{
	struct lsa_OpenAccount *object = (struct lsa_OpenAccount *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_OpenAccount_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenAccount *object = (struct lsa_OpenAccount *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_OpenAccount_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_OpenAccount_in_get_handle,
		.set = py_lsa_OpenAccount_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_sid"),
		.get = py_lsa_OpenAccount_in_get_sid,
		.set = py_lsa_OpenAccount_in_set_sid,
		.doc = discard_const_p(char, "PIDL-generated element of base type dom_sid2")
	},
	{
		.name = discard_const_p(char, "in_access_mask"),
		.get = py_lsa_OpenAccount_in_get_access_mask,
		.set = py_lsa_OpenAccount_in_set_access_mask,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_AccountAccessMask")
	},
	{
		.name = discard_const_p(char, "out_acct_handle"),
		.get = py_lsa_OpenAccount_out_get_acct_handle,
		.set = py_lsa_OpenAccount_out_set_acct_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_OpenAccount_get_result,
		.set = py_lsa_OpenAccount_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_OpenAccount_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_OpenAccount, type);
}

static PyObject *py_lsa_OpenAccount_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(17);
}

static PyObject *py_lsa_OpenAccount_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenAccount *object = (struct lsa_OpenAccount *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 18) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenAccount_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[17];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_OpenAccount_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_OpenAccount_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_OpenAccount_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_OpenAccount_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_OpenAccount_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenAccount *object = (struct lsa_OpenAccount *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 18) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenAccount_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[17];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_OpenAccount_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_OpenAccount_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_OpenAccount_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_OpenAccount_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_OpenAccount_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenAccount *object = (struct lsa_OpenAccount *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 18) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenAccount_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[17];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_OpenAccount_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_OpenAccount_ndr_print(py_obj, "lsa_OpenAccount_in", NDR_IN);
}

static PyObject *py_lsa_OpenAccount_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_OpenAccount_ndr_print(py_obj, "lsa_OpenAccount_out", NDR_OUT);
}

static PyMethodDef py_lsa_OpenAccount_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_OpenAccount_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.OpenAccount.opnum() -> 17 (0x11) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_OpenAccount_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_OpenAccount_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_OpenAccount_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_OpenAccount_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_OpenAccount_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_OpenAccount_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_OpenAccount_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.OpenAccount",
	.tp_getset = py_lsa_OpenAccount_getsetters,
	.tp_methods = py_lsa_OpenAccount_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_OpenAccount_new,
};

static bool pack_py_lsa_OpenAccount_args_in(PyObject *args, PyObject *kwargs, struct lsa_OpenAccount *r)
{
	PyObject *py_handle;
	PyObject *py_sid;
	PyObject *py_access_mask;
	const char *kwnames[] = {
		"handle", "sid", "access_mask", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_OpenAccount", discard_const_p(char *, kwnames), &py_handle, &py_sid, &py_access_mask)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_sid == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sid");
		return false;
	}
	r->in.sid = talloc_ptrtype(r, r->in.sid);
	if (r->in.sid == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(dom_sid_Type, py_sid, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_sid)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.sid = (struct dom_sid *)pytalloc_get_ptr(py_sid);
	if (py_access_mask == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.access_mask");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.access_mask));
		if (PyLong_Check(py_access_mask)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_access_mask);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else if (PyInt_Check(py_access_mask)) {
			long test_var;
			test_var = PyInt_AsLong(py_access_mask);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_OpenAccount_args_out(struct lsa_OpenAccount *r)
{
	PyObject *result;
	PyObject *py_acct_handle;
	py_acct_handle = pytalloc_reference_ex(policy_handle_Type, r->out.acct_handle, r->out.acct_handle);
	result = py_acct_handle;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_EnumPrivsAccount_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_EnumPrivsAccount *object = (struct lsa_EnumPrivsAccount *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_EnumPrivsAccount_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumPrivsAccount *object = (struct lsa_EnumPrivsAccount *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_EnumPrivsAccount_out_get_privs(PyObject *obj, void *closure)
{
	struct lsa_EnumPrivsAccount *object = (struct lsa_EnumPrivsAccount *)pytalloc_get_ptr(obj);
	PyObject *py_privs;
	if (*object->out.privs == NULL) {
		py_privs = Py_None;
		Py_INCREF(py_privs);
	} else {
		py_privs = pytalloc_reference_ex(&lsa_PrivilegeSet_Type, *object->out.privs, *object->out.privs);
	}
	return py_privs;
}

static int py_lsa_EnumPrivsAccount_out_set_privs(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumPrivsAccount *object = (struct lsa_EnumPrivsAccount *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.privs));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.privs");
		return -1;
	}
	object->out.privs = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.privs);
	if (object->out.privs == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.privs = NULL;
	} else {
		*object->out.privs = NULL;
		PY_CHECK_TYPE(&lsa_PrivilegeSet_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		*object->out.privs = (struct lsa_PrivilegeSet *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_EnumPrivsAccount_get_result(PyObject *obj, void *closure)
{
	struct lsa_EnumPrivsAccount *object = (struct lsa_EnumPrivsAccount *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_EnumPrivsAccount_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumPrivsAccount *object = (struct lsa_EnumPrivsAccount *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_EnumPrivsAccount_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_EnumPrivsAccount_in_get_handle,
		.set = py_lsa_EnumPrivsAccount_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "out_privs"),
		.get = py_lsa_EnumPrivsAccount_out_get_privs,
		.set = py_lsa_EnumPrivsAccount_out_set_privs,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_PrivilegeSet")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_EnumPrivsAccount_get_result,
		.set = py_lsa_EnumPrivsAccount_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_EnumPrivsAccount_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_EnumPrivsAccount, type);
}

static PyObject *py_lsa_EnumPrivsAccount_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(18);
}

static PyObject *py_lsa_EnumPrivsAccount_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumPrivsAccount *object = (struct lsa_EnumPrivsAccount *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 19) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumPrivsAccount_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[18];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_EnumPrivsAccount_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_EnumPrivsAccount_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_EnumPrivsAccount_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_EnumPrivsAccount_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_EnumPrivsAccount_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumPrivsAccount *object = (struct lsa_EnumPrivsAccount *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 19) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumPrivsAccount_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[18];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_EnumPrivsAccount_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_EnumPrivsAccount_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_EnumPrivsAccount_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_EnumPrivsAccount_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_EnumPrivsAccount_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumPrivsAccount *object = (struct lsa_EnumPrivsAccount *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 19) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumPrivsAccount_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[18];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_EnumPrivsAccount_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_EnumPrivsAccount_ndr_print(py_obj, "lsa_EnumPrivsAccount_in", NDR_IN);
}

static PyObject *py_lsa_EnumPrivsAccount_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_EnumPrivsAccount_ndr_print(py_obj, "lsa_EnumPrivsAccount_out", NDR_OUT);
}

static PyMethodDef py_lsa_EnumPrivsAccount_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_EnumPrivsAccount_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.EnumPrivsAccount.opnum() -> 18 (0x12) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_EnumPrivsAccount_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_EnumPrivsAccount_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_EnumPrivsAccount_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_EnumPrivsAccount_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_EnumPrivsAccount_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_EnumPrivsAccount_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_EnumPrivsAccount_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.EnumPrivsAccount",
	.tp_getset = py_lsa_EnumPrivsAccount_getsetters,
	.tp_methods = py_lsa_EnumPrivsAccount_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_EnumPrivsAccount_new,
};

static bool pack_py_lsa_EnumPrivsAccount_args_in(PyObject *args, PyObject *kwargs, struct lsa_EnumPrivsAccount *r)
{
	PyObject *py_handle;
	const char *kwnames[] = {
		"handle", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:lsa_EnumPrivsAccount", discard_const_p(char *, kwnames), &py_handle)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	return true;
}

static PyObject *unpack_py_lsa_EnumPrivsAccount_args_out(struct lsa_EnumPrivsAccount *r)
{
	PyObject *result;
	PyObject *py_privs;
	if (*r->out.privs == NULL) {
		py_privs = Py_None;
		Py_INCREF(py_privs);
	} else {
		py_privs = pytalloc_reference_ex(&lsa_PrivilegeSet_Type, *r->out.privs, *r->out.privs);
	}
	result = py_privs;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_AddPrivilegesToAccount_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_AddPrivilegesToAccount *object = (struct lsa_AddPrivilegesToAccount *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_AddPrivilegesToAccount_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AddPrivilegesToAccount *object = (struct lsa_AddPrivilegesToAccount *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_AddPrivilegesToAccount_in_get_privs(PyObject *obj, void *closure)
{
	struct lsa_AddPrivilegesToAccount *object = (struct lsa_AddPrivilegesToAccount *)pytalloc_get_ptr(obj);
	PyObject *py_privs;
	py_privs = pytalloc_reference_ex(&lsa_PrivilegeSet_Type, object->in.privs, object->in.privs);
	return py_privs;
}

static int py_lsa_AddPrivilegesToAccount_in_set_privs(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AddPrivilegesToAccount *object = (struct lsa_AddPrivilegesToAccount *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.privs));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.privs");
		return -1;
	}
	object->in.privs = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.privs);
	if (object->in.privs == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_PrivilegeSet_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.privs = (struct lsa_PrivilegeSet *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_AddPrivilegesToAccount_get_result(PyObject *obj, void *closure)
{
	struct lsa_AddPrivilegesToAccount *object = (struct lsa_AddPrivilegesToAccount *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_AddPrivilegesToAccount_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AddPrivilegesToAccount *object = (struct lsa_AddPrivilegesToAccount *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_AddPrivilegesToAccount_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_AddPrivilegesToAccount_in_get_handle,
		.set = py_lsa_AddPrivilegesToAccount_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_privs"),
		.get = py_lsa_AddPrivilegesToAccount_in_get_privs,
		.set = py_lsa_AddPrivilegesToAccount_in_set_privs,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_PrivilegeSet")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_AddPrivilegesToAccount_get_result,
		.set = py_lsa_AddPrivilegesToAccount_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_AddPrivilegesToAccount_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_AddPrivilegesToAccount, type);
}

static PyObject *py_lsa_AddPrivilegesToAccount_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(19);
}

static PyObject *py_lsa_AddPrivilegesToAccount_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_AddPrivilegesToAccount *object = (struct lsa_AddPrivilegesToAccount *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 20) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_AddPrivilegesToAccount_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[19];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_AddPrivilegesToAccount_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_AddPrivilegesToAccount_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_AddPrivilegesToAccount_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_AddPrivilegesToAccount_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_AddPrivilegesToAccount_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_AddPrivilegesToAccount *object = (struct lsa_AddPrivilegesToAccount *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 20) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_AddPrivilegesToAccount_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[19];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_AddPrivilegesToAccount_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_AddPrivilegesToAccount_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_AddPrivilegesToAccount_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_AddPrivilegesToAccount_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_AddPrivilegesToAccount_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_AddPrivilegesToAccount *object = (struct lsa_AddPrivilegesToAccount *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 20) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_AddPrivilegesToAccount_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[19];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_AddPrivilegesToAccount_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_AddPrivilegesToAccount_ndr_print(py_obj, "lsa_AddPrivilegesToAccount_in", NDR_IN);
}

static PyObject *py_lsa_AddPrivilegesToAccount_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_AddPrivilegesToAccount_ndr_print(py_obj, "lsa_AddPrivilegesToAccount_out", NDR_OUT);
}

static PyMethodDef py_lsa_AddPrivilegesToAccount_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_AddPrivilegesToAccount_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.AddPrivilegesToAccount.opnum() -> 19 (0x13) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_AddPrivilegesToAccount_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_AddPrivilegesToAccount_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_AddPrivilegesToAccount_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_AddPrivilegesToAccount_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_AddPrivilegesToAccount_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_AddPrivilegesToAccount_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_AddPrivilegesToAccount_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.AddPrivilegesToAccount",
	.tp_getset = py_lsa_AddPrivilegesToAccount_getsetters,
	.tp_methods = py_lsa_AddPrivilegesToAccount_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_AddPrivilegesToAccount_new,
};

static bool pack_py_lsa_AddPrivilegesToAccount_args_in(PyObject *args, PyObject *kwargs, struct lsa_AddPrivilegesToAccount *r)
{
	PyObject *py_handle;
	PyObject *py_privs;
	const char *kwnames[] = {
		"handle", "privs", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:lsa_AddPrivilegesToAccount", discard_const_p(char *, kwnames), &py_handle, &py_privs)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_privs == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.privs");
		return false;
	}
	r->in.privs = talloc_ptrtype(r, r->in.privs);
	if (r->in.privs == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_PrivilegeSet_Type, py_privs, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_privs)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.privs = (struct lsa_PrivilegeSet *)pytalloc_get_ptr(py_privs);
	return true;
}

static PyObject *unpack_py_lsa_AddPrivilegesToAccount_args_out(struct lsa_AddPrivilegesToAccount *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_RemovePrivilegesFromAccount_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_RemovePrivilegesFromAccount *object = (struct lsa_RemovePrivilegesFromAccount *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_RemovePrivilegesFromAccount_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RemovePrivilegesFromAccount *object = (struct lsa_RemovePrivilegesFromAccount *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_RemovePrivilegesFromAccount_in_get_remove_all(PyObject *obj, void *closure)
{
	struct lsa_RemovePrivilegesFromAccount *object = (struct lsa_RemovePrivilegesFromAccount *)pytalloc_get_ptr(obj);
	PyObject *py_remove_all;
	py_remove_all = PyInt_FromLong((uint16_t)object->in.remove_all);
	return py_remove_all;
}

static int py_lsa_RemovePrivilegesFromAccount_in_set_remove_all(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RemovePrivilegesFromAccount *object = (struct lsa_RemovePrivilegesFromAccount *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.remove_all");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.remove_all));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.remove_all = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.remove_all = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_RemovePrivilegesFromAccount_in_get_privs(PyObject *obj, void *closure)
{
	struct lsa_RemovePrivilegesFromAccount *object = (struct lsa_RemovePrivilegesFromAccount *)pytalloc_get_ptr(obj);
	PyObject *py_privs;
	if (object->in.privs == NULL) {
		py_privs = Py_None;
		Py_INCREF(py_privs);
	} else {
		py_privs = pytalloc_reference_ex(&lsa_PrivilegeSet_Type, object->in.privs, object->in.privs);
	}
	return py_privs;
}

static int py_lsa_RemovePrivilegesFromAccount_in_set_privs(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RemovePrivilegesFromAccount *object = (struct lsa_RemovePrivilegesFromAccount *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.privs));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.privs");
		return -1;
	}
	if (value == Py_None) {
		object->in.privs = NULL;
	} else {
		object->in.privs = NULL;
		PY_CHECK_TYPE(&lsa_PrivilegeSet_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->in.privs = (struct lsa_PrivilegeSet *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_RemovePrivilegesFromAccount_get_result(PyObject *obj, void *closure)
{
	struct lsa_RemovePrivilegesFromAccount *object = (struct lsa_RemovePrivilegesFromAccount *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_RemovePrivilegesFromAccount_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RemovePrivilegesFromAccount *object = (struct lsa_RemovePrivilegesFromAccount *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_RemovePrivilegesFromAccount_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_RemovePrivilegesFromAccount_in_get_handle,
		.set = py_lsa_RemovePrivilegesFromAccount_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_remove_all"),
		.get = py_lsa_RemovePrivilegesFromAccount_in_get_remove_all,
		.set = py_lsa_RemovePrivilegesFromAccount_in_set_remove_all,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{
		.name = discard_const_p(char, "in_privs"),
		.get = py_lsa_RemovePrivilegesFromAccount_in_get_privs,
		.set = py_lsa_RemovePrivilegesFromAccount_in_set_privs,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_PrivilegeSet")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_RemovePrivilegesFromAccount_get_result,
		.set = py_lsa_RemovePrivilegesFromAccount_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_RemovePrivilegesFromAccount_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_RemovePrivilegesFromAccount, type);
}

static PyObject *py_lsa_RemovePrivilegesFromAccount_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(20);
}

static PyObject *py_lsa_RemovePrivilegesFromAccount_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_RemovePrivilegesFromAccount *object = (struct lsa_RemovePrivilegesFromAccount *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 21) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_RemovePrivilegesFromAccount_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[20];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_RemovePrivilegesFromAccount_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_RemovePrivilegesFromAccount_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_RemovePrivilegesFromAccount_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_RemovePrivilegesFromAccount_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_RemovePrivilegesFromAccount_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_RemovePrivilegesFromAccount *object = (struct lsa_RemovePrivilegesFromAccount *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 21) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_RemovePrivilegesFromAccount_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[20];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_RemovePrivilegesFromAccount_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_RemovePrivilegesFromAccount_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_RemovePrivilegesFromAccount_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_RemovePrivilegesFromAccount_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_RemovePrivilegesFromAccount_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_RemovePrivilegesFromAccount *object = (struct lsa_RemovePrivilegesFromAccount *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 21) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_RemovePrivilegesFromAccount_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[20];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_RemovePrivilegesFromAccount_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_RemovePrivilegesFromAccount_ndr_print(py_obj, "lsa_RemovePrivilegesFromAccount_in", NDR_IN);
}

static PyObject *py_lsa_RemovePrivilegesFromAccount_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_RemovePrivilegesFromAccount_ndr_print(py_obj, "lsa_RemovePrivilegesFromAccount_out", NDR_OUT);
}

static PyMethodDef py_lsa_RemovePrivilegesFromAccount_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_RemovePrivilegesFromAccount_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.RemovePrivilegesFromAccount.opnum() -> 20 (0x14) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_RemovePrivilegesFromAccount_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_RemovePrivilegesFromAccount_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_RemovePrivilegesFromAccount_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_RemovePrivilegesFromAccount_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_RemovePrivilegesFromAccount_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_RemovePrivilegesFromAccount_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_RemovePrivilegesFromAccount_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.RemovePrivilegesFromAccount",
	.tp_getset = py_lsa_RemovePrivilegesFromAccount_getsetters,
	.tp_methods = py_lsa_RemovePrivilegesFromAccount_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_RemovePrivilegesFromAccount_new,
};

static bool pack_py_lsa_RemovePrivilegesFromAccount_args_in(PyObject *args, PyObject *kwargs, struct lsa_RemovePrivilegesFromAccount *r)
{
	PyObject *py_handle;
	PyObject *py_remove_all;
	PyObject *py_privs;
	const char *kwnames[] = {
		"handle", "remove_all", "privs", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_RemovePrivilegesFromAccount", discard_const_p(char *, kwnames), &py_handle, &py_remove_all, &py_privs)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_remove_all == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.remove_all");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.remove_all));
		if (PyLong_Check(py_remove_all)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_remove_all);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.remove_all = test_var;
		} else if (PyInt_Check(py_remove_all)) {
			long test_var;
			test_var = PyInt_AsLong(py_remove_all);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.remove_all = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_privs == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.privs");
		return false;
	}
	if (py_privs == Py_None) {
		r->in.privs = NULL;
	} else {
		r->in.privs = NULL;
		PY_CHECK_TYPE(&lsa_PrivilegeSet_Type, py_privs, return false;);
		if (talloc_reference(r, pytalloc_get_mem_ctx(py_privs)) == NULL) {
			PyErr_NoMemory();
			return false;
		}
		r->in.privs = (struct lsa_PrivilegeSet *)pytalloc_get_ptr(py_privs);
	}
	return true;
}

static PyObject *unpack_py_lsa_RemovePrivilegesFromAccount_args_out(struct lsa_RemovePrivilegesFromAccount *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_GetSystemAccessAccount_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_GetSystemAccessAccount *object = (struct lsa_GetSystemAccessAccount *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_GetSystemAccessAccount_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_GetSystemAccessAccount *object = (struct lsa_GetSystemAccessAccount *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_GetSystemAccessAccount_out_get_access_mask(PyObject *obj, void *closure)
{
	struct lsa_GetSystemAccessAccount *object = (struct lsa_GetSystemAccessAccount *)pytalloc_get_ptr(obj);
	PyObject *py_access_mask;
	py_access_mask = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->out.access_mask);
	return py_access_mask;
}

static int py_lsa_GetSystemAccessAccount_out_set_access_mask(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_GetSystemAccessAccount *object = (struct lsa_GetSystemAccessAccount *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.access_mask));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.access_mask");
		return -1;
	}
	object->out.access_mask = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.access_mask);
	if (object->out.access_mask == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->out.access_mask));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.access_mask = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_GetSystemAccessAccount_get_result(PyObject *obj, void *closure)
{
	struct lsa_GetSystemAccessAccount *object = (struct lsa_GetSystemAccessAccount *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_GetSystemAccessAccount_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_GetSystemAccessAccount *object = (struct lsa_GetSystemAccessAccount *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_GetSystemAccessAccount_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_GetSystemAccessAccount_in_get_handle,
		.set = py_lsa_GetSystemAccessAccount_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "out_access_mask"),
		.get = py_lsa_GetSystemAccessAccount_out_get_access_mask,
		.set = py_lsa_GetSystemAccessAccount_out_set_access_mask,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_AccountAccessMask")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_GetSystemAccessAccount_get_result,
		.set = py_lsa_GetSystemAccessAccount_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_GetSystemAccessAccount_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_GetSystemAccessAccount, type);
}

static PyObject *py_lsa_GetSystemAccessAccount_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(23);
}

static PyObject *py_lsa_GetSystemAccessAccount_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_GetSystemAccessAccount *object = (struct lsa_GetSystemAccessAccount *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 24) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_GetSystemAccessAccount_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[23];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_GetSystemAccessAccount_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_GetSystemAccessAccount_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_GetSystemAccessAccount_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_GetSystemAccessAccount_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_GetSystemAccessAccount_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_GetSystemAccessAccount *object = (struct lsa_GetSystemAccessAccount *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 24) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_GetSystemAccessAccount_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[23];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_GetSystemAccessAccount_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_GetSystemAccessAccount_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_GetSystemAccessAccount_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_GetSystemAccessAccount_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_GetSystemAccessAccount_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_GetSystemAccessAccount *object = (struct lsa_GetSystemAccessAccount *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 24) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_GetSystemAccessAccount_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[23];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_GetSystemAccessAccount_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_GetSystemAccessAccount_ndr_print(py_obj, "lsa_GetSystemAccessAccount_in", NDR_IN);
}

static PyObject *py_lsa_GetSystemAccessAccount_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_GetSystemAccessAccount_ndr_print(py_obj, "lsa_GetSystemAccessAccount_out", NDR_OUT);
}

static PyMethodDef py_lsa_GetSystemAccessAccount_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_GetSystemAccessAccount_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.GetSystemAccessAccount.opnum() -> 23 (0x17) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_GetSystemAccessAccount_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_GetSystemAccessAccount_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_GetSystemAccessAccount_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_GetSystemAccessAccount_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_GetSystemAccessAccount_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_GetSystemAccessAccount_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_GetSystemAccessAccount_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.GetSystemAccessAccount",
	.tp_getset = py_lsa_GetSystemAccessAccount_getsetters,
	.tp_methods = py_lsa_GetSystemAccessAccount_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_GetSystemAccessAccount_new,
};

static bool pack_py_lsa_GetSystemAccessAccount_args_in(PyObject *args, PyObject *kwargs, struct lsa_GetSystemAccessAccount *r)
{
	PyObject *py_handle;
	const char *kwnames[] = {
		"handle", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:lsa_GetSystemAccessAccount", discard_const_p(char *, kwnames), &py_handle)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	return true;
}

static PyObject *unpack_py_lsa_GetSystemAccessAccount_args_out(struct lsa_GetSystemAccessAccount *r)
{
	PyObject *result;
	PyObject *py_access_mask;
	py_access_mask = ndr_PyLong_FromUnsignedLongLong((uint32_t)*r->out.access_mask);
	result = py_access_mask;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_SetSystemAccessAccount_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_SetSystemAccessAccount *object = (struct lsa_SetSystemAccessAccount *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_SetSystemAccessAccount_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetSystemAccessAccount *object = (struct lsa_SetSystemAccessAccount *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_SetSystemAccessAccount_in_get_access_mask(PyObject *obj, void *closure)
{
	struct lsa_SetSystemAccessAccount *object = (struct lsa_SetSystemAccessAccount *)pytalloc_get_ptr(obj);
	PyObject *py_access_mask;
	py_access_mask = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.access_mask);
	return py_access_mask;
}

static int py_lsa_SetSystemAccessAccount_in_set_access_mask(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetSystemAccessAccount *object = (struct lsa_SetSystemAccessAccount *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.access_mask");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.access_mask));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_SetSystemAccessAccount_get_result(PyObject *obj, void *closure)
{
	struct lsa_SetSystemAccessAccount *object = (struct lsa_SetSystemAccessAccount *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_SetSystemAccessAccount_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetSystemAccessAccount *object = (struct lsa_SetSystemAccessAccount *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_SetSystemAccessAccount_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_SetSystemAccessAccount_in_get_handle,
		.set = py_lsa_SetSystemAccessAccount_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_access_mask"),
		.get = py_lsa_SetSystemAccessAccount_in_get_access_mask,
		.set = py_lsa_SetSystemAccessAccount_in_set_access_mask,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_AccountAccessMask")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_SetSystemAccessAccount_get_result,
		.set = py_lsa_SetSystemAccessAccount_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_SetSystemAccessAccount_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_SetSystemAccessAccount, type);
}

static PyObject *py_lsa_SetSystemAccessAccount_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(24);
}

static PyObject *py_lsa_SetSystemAccessAccount_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetSystemAccessAccount *object = (struct lsa_SetSystemAccessAccount *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 25) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetSystemAccessAccount_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[24];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_SetSystemAccessAccount_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetSystemAccessAccount_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_SetSystemAccessAccount_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetSystemAccessAccount_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_SetSystemAccessAccount_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetSystemAccessAccount *object = (struct lsa_SetSystemAccessAccount *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 25) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetSystemAccessAccount_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[24];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_SetSystemAccessAccount_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetSystemAccessAccount_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetSystemAccessAccount_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetSystemAccessAccount_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetSystemAccessAccount_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetSystemAccessAccount *object = (struct lsa_SetSystemAccessAccount *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 25) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetSystemAccessAccount_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[24];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_SetSystemAccessAccount_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_SetSystemAccessAccount_ndr_print(py_obj, "lsa_SetSystemAccessAccount_in", NDR_IN);
}

static PyObject *py_lsa_SetSystemAccessAccount_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_SetSystemAccessAccount_ndr_print(py_obj, "lsa_SetSystemAccessAccount_out", NDR_OUT);
}

static PyMethodDef py_lsa_SetSystemAccessAccount_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_SetSystemAccessAccount_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.SetSystemAccessAccount.opnum() -> 24 (0x18) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_SetSystemAccessAccount_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_SetSystemAccessAccount_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_SetSystemAccessAccount_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_SetSystemAccessAccount_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_SetSystemAccessAccount_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_SetSystemAccessAccount_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_SetSystemAccessAccount_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.SetSystemAccessAccount",
	.tp_getset = py_lsa_SetSystemAccessAccount_getsetters,
	.tp_methods = py_lsa_SetSystemAccessAccount_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_SetSystemAccessAccount_new,
};

static bool pack_py_lsa_SetSystemAccessAccount_args_in(PyObject *args, PyObject *kwargs, struct lsa_SetSystemAccessAccount *r)
{
	PyObject *py_handle;
	PyObject *py_access_mask;
	const char *kwnames[] = {
		"handle", "access_mask", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:lsa_SetSystemAccessAccount", discard_const_p(char *, kwnames), &py_handle, &py_access_mask)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_access_mask == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.access_mask");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.access_mask));
		if (PyLong_Check(py_access_mask)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_access_mask);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else if (PyInt_Check(py_access_mask)) {
			long test_var;
			test_var = PyInt_AsLong(py_access_mask);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_SetSystemAccessAccount_args_out(struct lsa_SetSystemAccessAccount *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_OpenTrustedDomain_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_OpenTrustedDomain *object = (struct lsa_OpenTrustedDomain *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_OpenTrustedDomain_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenTrustedDomain *object = (struct lsa_OpenTrustedDomain *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_OpenTrustedDomain_in_get_sid(PyObject *obj, void *closure)
{
	struct lsa_OpenTrustedDomain *object = (struct lsa_OpenTrustedDomain *)pytalloc_get_ptr(obj);
	PyObject *py_sid;
	py_sid = pytalloc_reference_ex(dom_sid_Type, object->in.sid, object->in.sid);
	return py_sid;
}

static int py_lsa_OpenTrustedDomain_in_set_sid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenTrustedDomain *object = (struct lsa_OpenTrustedDomain *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.sid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sid");
		return -1;
	}
	object->in.sid = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.sid);
	if (object->in.sid == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(dom_sid_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.sid = (struct dom_sid *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_OpenTrustedDomain_in_get_access_mask(PyObject *obj, void *closure)
{
	struct lsa_OpenTrustedDomain *object = (struct lsa_OpenTrustedDomain *)pytalloc_get_ptr(obj);
	PyObject *py_access_mask;
	py_access_mask = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.access_mask);
	return py_access_mask;
}

static int py_lsa_OpenTrustedDomain_in_set_access_mask(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenTrustedDomain *object = (struct lsa_OpenTrustedDomain *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.access_mask");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.access_mask));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_OpenTrustedDomain_out_get_trustdom_handle(PyObject *obj, void *closure)
{
	struct lsa_OpenTrustedDomain *object = (struct lsa_OpenTrustedDomain *)pytalloc_get_ptr(obj);
	PyObject *py_trustdom_handle;
	py_trustdom_handle = pytalloc_reference_ex(policy_handle_Type, object->out.trustdom_handle, object->out.trustdom_handle);
	return py_trustdom_handle;
}

static int py_lsa_OpenTrustedDomain_out_set_trustdom_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenTrustedDomain *object = (struct lsa_OpenTrustedDomain *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.trustdom_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.trustdom_handle");
		return -1;
	}
	object->out.trustdom_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.trustdom_handle);
	if (object->out.trustdom_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.trustdom_handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_OpenTrustedDomain_get_result(PyObject *obj, void *closure)
{
	struct lsa_OpenTrustedDomain *object = (struct lsa_OpenTrustedDomain *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_OpenTrustedDomain_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenTrustedDomain *object = (struct lsa_OpenTrustedDomain *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_OpenTrustedDomain_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_OpenTrustedDomain_in_get_handle,
		.set = py_lsa_OpenTrustedDomain_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_sid"),
		.get = py_lsa_OpenTrustedDomain_in_get_sid,
		.set = py_lsa_OpenTrustedDomain_in_set_sid,
		.doc = discard_const_p(char, "PIDL-generated element of base type dom_sid2")
	},
	{
		.name = discard_const_p(char, "in_access_mask"),
		.get = py_lsa_OpenTrustedDomain_in_get_access_mask,
		.set = py_lsa_OpenTrustedDomain_in_set_access_mask,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustedAccessMask")
	},
	{
		.name = discard_const_p(char, "out_trustdom_handle"),
		.get = py_lsa_OpenTrustedDomain_out_get_trustdom_handle,
		.set = py_lsa_OpenTrustedDomain_out_set_trustdom_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_OpenTrustedDomain_get_result,
		.set = py_lsa_OpenTrustedDomain_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_OpenTrustedDomain_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_OpenTrustedDomain, type);
}

static PyObject *py_lsa_OpenTrustedDomain_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(25);
}

static PyObject *py_lsa_OpenTrustedDomain_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenTrustedDomain *object = (struct lsa_OpenTrustedDomain *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 26) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenTrustedDomain_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[25];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_OpenTrustedDomain_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_OpenTrustedDomain_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_OpenTrustedDomain_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_OpenTrustedDomain_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_OpenTrustedDomain_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenTrustedDomain *object = (struct lsa_OpenTrustedDomain *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 26) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenTrustedDomain_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[25];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_OpenTrustedDomain_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_OpenTrustedDomain_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_OpenTrustedDomain_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_OpenTrustedDomain_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_OpenTrustedDomain_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenTrustedDomain *object = (struct lsa_OpenTrustedDomain *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 26) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenTrustedDomain_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[25];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_OpenTrustedDomain_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_OpenTrustedDomain_ndr_print(py_obj, "lsa_OpenTrustedDomain_in", NDR_IN);
}

static PyObject *py_lsa_OpenTrustedDomain_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_OpenTrustedDomain_ndr_print(py_obj, "lsa_OpenTrustedDomain_out", NDR_OUT);
}

static PyMethodDef py_lsa_OpenTrustedDomain_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_OpenTrustedDomain_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.OpenTrustedDomain.opnum() -> 25 (0x19) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_OpenTrustedDomain_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_OpenTrustedDomain_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_OpenTrustedDomain_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_OpenTrustedDomain_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_OpenTrustedDomain_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_OpenTrustedDomain_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_OpenTrustedDomain_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.OpenTrustedDomain",
	.tp_getset = py_lsa_OpenTrustedDomain_getsetters,
	.tp_methods = py_lsa_OpenTrustedDomain_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_OpenTrustedDomain_new,
};

static bool pack_py_lsa_OpenTrustedDomain_args_in(PyObject *args, PyObject *kwargs, struct lsa_OpenTrustedDomain *r)
{
	PyObject *py_handle;
	PyObject *py_sid;
	PyObject *py_access_mask;
	const char *kwnames[] = {
		"handle", "sid", "access_mask", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_OpenTrustedDomain", discard_const_p(char *, kwnames), &py_handle, &py_sid, &py_access_mask)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_sid == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sid");
		return false;
	}
	r->in.sid = talloc_ptrtype(r, r->in.sid);
	if (r->in.sid == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(dom_sid_Type, py_sid, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_sid)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.sid = (struct dom_sid *)pytalloc_get_ptr(py_sid);
	if (py_access_mask == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.access_mask");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.access_mask));
		if (PyLong_Check(py_access_mask)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_access_mask);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else if (PyInt_Check(py_access_mask)) {
			long test_var;
			test_var = PyInt_AsLong(py_access_mask);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_OpenTrustedDomain_args_out(struct lsa_OpenTrustedDomain *r)
{
	PyObject *result;
	PyObject *py_trustdom_handle;
	py_trustdom_handle = pytalloc_reference_ex(policy_handle_Type, r->out.trustdom_handle, r->out.trustdom_handle);
	result = py_trustdom_handle;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_QueryTrustedDomainInfo_in_get_trustdom_handle(PyObject *obj, void *closure)
{
	struct lsa_QueryTrustedDomainInfo *object = (struct lsa_QueryTrustedDomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_trustdom_handle;
	py_trustdom_handle = pytalloc_reference_ex(policy_handle_Type, object->in.trustdom_handle, object->in.trustdom_handle);
	return py_trustdom_handle;
}

static int py_lsa_QueryTrustedDomainInfo_in_set_trustdom_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryTrustedDomainInfo *object = (struct lsa_QueryTrustedDomainInfo *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.trustdom_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.trustdom_handle");
		return -1;
	}
	object->in.trustdom_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.trustdom_handle);
	if (object->in.trustdom_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.trustdom_handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_QueryTrustedDomainInfo_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_QueryTrustedDomainInfo *object = (struct lsa_QueryTrustedDomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_QueryTrustedDomainInfo_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryTrustedDomainInfo *object = (struct lsa_QueryTrustedDomainInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_QueryTrustedDomainInfo_out_get_info(PyObject *obj, void *closure)
{
	struct lsa_QueryTrustedDomainInfo *object = (struct lsa_QueryTrustedDomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_info;
	if (*object->out.info == NULL) {
		py_info = Py_None;
		Py_INCREF(py_info);
	} else {
		py_info = pyrpc_import_union(&lsa_TrustedDomainInfo_Type, *object->out.info, object->in.level, *object->out.info, "union lsa_TrustedDomainInfo");
		if (py_info == NULL) {
			return NULL;
		}
	}
	return py_info;
}

static int py_lsa_QueryTrustedDomainInfo_out_set_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryTrustedDomainInfo *object = (struct lsa_QueryTrustedDomainInfo *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.info");
		return -1;
	}
	object->out.info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.info);
	if (object->out.info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.info = NULL;
	} else {
		*object->out.info = NULL;
		{
			union lsa_TrustedDomainInfo *info_switch_2;
			info_switch_2 = (union lsa_TrustedDomainInfo *)pyrpc_export_union(&lsa_TrustedDomainInfo_Type, pytalloc_get_mem_ctx(py_obj), object->in.level, value, "union lsa_TrustedDomainInfo");
			if (info_switch_2 == NULL) {
				return -1;
			}
			*object->out.info = info_switch_2;
		}
	}
	return 0;
}

static PyObject *py_lsa_QueryTrustedDomainInfo_get_result(PyObject *obj, void *closure)
{
	struct lsa_QueryTrustedDomainInfo *object = (struct lsa_QueryTrustedDomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_QueryTrustedDomainInfo_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryTrustedDomainInfo *object = (struct lsa_QueryTrustedDomainInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_QueryTrustedDomainInfo_getsetters[] = {
	{
		.name = discard_const_p(char, "in_trustdom_handle"),
		.get = py_lsa_QueryTrustedDomainInfo_in_get_trustdom_handle,
		.set = py_lsa_QueryTrustedDomainInfo_in_set_trustdom_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_QueryTrustedDomainInfo_in_get_level,
		.set = py_lsa_QueryTrustedDomainInfo_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomInfoEnum")
	},
	{
		.name = discard_const_p(char, "out_info"),
		.get = py_lsa_QueryTrustedDomainInfo_out_get_info,
		.set = py_lsa_QueryTrustedDomainInfo_out_set_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustedDomainInfo")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_QueryTrustedDomainInfo_get_result,
		.set = py_lsa_QueryTrustedDomainInfo_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_QueryTrustedDomainInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_QueryTrustedDomainInfo, type);
}

static PyObject *py_lsa_QueryTrustedDomainInfo_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(26);
}

static PyObject *py_lsa_QueryTrustedDomainInfo_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryTrustedDomainInfo *object = (struct lsa_QueryTrustedDomainInfo *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 27) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryTrustedDomainInfo_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[26];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_QueryTrustedDomainInfo_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_QueryTrustedDomainInfo_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_QueryTrustedDomainInfo_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_QueryTrustedDomainInfo_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_QueryTrustedDomainInfo_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryTrustedDomainInfo *object = (struct lsa_QueryTrustedDomainInfo *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 27) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryTrustedDomainInfo_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[26];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_QueryTrustedDomainInfo_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_QueryTrustedDomainInfo_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_QueryTrustedDomainInfo_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_QueryTrustedDomainInfo_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_QueryTrustedDomainInfo_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryTrustedDomainInfo *object = (struct lsa_QueryTrustedDomainInfo *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 27) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryTrustedDomainInfo_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[26];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_QueryTrustedDomainInfo_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_QueryTrustedDomainInfo_ndr_print(py_obj, "lsa_QueryTrustedDomainInfo_in", NDR_IN);
}

static PyObject *py_lsa_QueryTrustedDomainInfo_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_QueryTrustedDomainInfo_ndr_print(py_obj, "lsa_QueryTrustedDomainInfo_out", NDR_OUT);
}

static PyMethodDef py_lsa_QueryTrustedDomainInfo_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_QueryTrustedDomainInfo_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.QueryTrustedDomainInfo.opnum() -> 26 (0x1a) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_QueryTrustedDomainInfo_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_QueryTrustedDomainInfo_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_QueryTrustedDomainInfo_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_QueryTrustedDomainInfo_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_QueryTrustedDomainInfo_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_QueryTrustedDomainInfo_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_QueryTrustedDomainInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.QueryTrustedDomainInfo",
	.tp_getset = py_lsa_QueryTrustedDomainInfo_getsetters,
	.tp_methods = py_lsa_QueryTrustedDomainInfo_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_QueryTrustedDomainInfo_new,
};

static bool pack_py_lsa_QueryTrustedDomainInfo_args_in(PyObject *args, PyObject *kwargs, struct lsa_QueryTrustedDomainInfo *r)
{
	PyObject *py_trustdom_handle;
	PyObject *py_level;
	const char *kwnames[] = {
		"trustdom_handle", "level", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:lsa_QueryTrustedDomainInfo", discard_const_p(char *, kwnames), &py_trustdom_handle, &py_level)) {
		return false;
	}

	if (py_trustdom_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.trustdom_handle");
		return false;
	}
	r->in.trustdom_handle = talloc_ptrtype(r, r->in.trustdom_handle);
	if (r->in.trustdom_handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_trustdom_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_trustdom_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.trustdom_handle = (struct policy_handle *)pytalloc_get_ptr(py_trustdom_handle);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_QueryTrustedDomainInfo_args_out(struct lsa_QueryTrustedDomainInfo *r)
{
	PyObject *result;
	PyObject *py_info;
	if (*r->out.info == NULL) {
		py_info = Py_None;
		Py_INCREF(py_info);
	} else {
		py_info = pyrpc_import_union(&lsa_TrustedDomainInfo_Type, *r->out.info, r->in.level, *r->out.info, "union lsa_TrustedDomainInfo");
		if (py_info == NULL) {
			return NULL;
		}
	}
	result = py_info;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_SetInformationTrustedDomain_in_get_trustdom_handle(PyObject *obj, void *closure)
{
	struct lsa_SetInformationTrustedDomain *object = (struct lsa_SetInformationTrustedDomain *)pytalloc_get_ptr(obj);
	PyObject *py_trustdom_handle;
	py_trustdom_handle = pytalloc_reference_ex(policy_handle_Type, object->in.trustdom_handle, object->in.trustdom_handle);
	return py_trustdom_handle;
}

static int py_lsa_SetInformationTrustedDomain_in_set_trustdom_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetInformationTrustedDomain *object = (struct lsa_SetInformationTrustedDomain *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.trustdom_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.trustdom_handle");
		return -1;
	}
	object->in.trustdom_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.trustdom_handle);
	if (object->in.trustdom_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.trustdom_handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_SetInformationTrustedDomain_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_SetInformationTrustedDomain *object = (struct lsa_SetInformationTrustedDomain *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_SetInformationTrustedDomain_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetInformationTrustedDomain *object = (struct lsa_SetInformationTrustedDomain *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_SetInformationTrustedDomain_in_get_info(PyObject *obj, void *closure)
{
	struct lsa_SetInformationTrustedDomain *object = (struct lsa_SetInformationTrustedDomain *)pytalloc_get_ptr(obj);
	PyObject *py_info;
	py_info = pyrpc_import_union(&lsa_TrustedDomainInfo_Type, object->in.info, object->in.level, object->in.info, "union lsa_TrustedDomainInfo");
	if (py_info == NULL) {
		return NULL;
	}
	return py_info;
}

static int py_lsa_SetInformationTrustedDomain_in_set_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetInformationTrustedDomain *object = (struct lsa_SetInformationTrustedDomain *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.info");
		return -1;
	}
	object->in.info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.info);
	if (object->in.info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		union lsa_TrustedDomainInfo *info_switch_1;
		info_switch_1 = (union lsa_TrustedDomainInfo *)pyrpc_export_union(&lsa_TrustedDomainInfo_Type, pytalloc_get_mem_ctx(py_obj), object->in.level, value, "union lsa_TrustedDomainInfo");
		if (info_switch_1 == NULL) {
			return -1;
		}
		object->in.info = info_switch_1;
	}
	return 0;
}

static PyObject *py_lsa_SetInformationTrustedDomain_get_result(PyObject *obj, void *closure)
{
	struct lsa_SetInformationTrustedDomain *object = (struct lsa_SetInformationTrustedDomain *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_SetInformationTrustedDomain_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetInformationTrustedDomain *object = (struct lsa_SetInformationTrustedDomain *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_SetInformationTrustedDomain_getsetters[] = {
	{
		.name = discard_const_p(char, "in_trustdom_handle"),
		.get = py_lsa_SetInformationTrustedDomain_in_get_trustdom_handle,
		.set = py_lsa_SetInformationTrustedDomain_in_set_trustdom_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_SetInformationTrustedDomain_in_get_level,
		.set = py_lsa_SetInformationTrustedDomain_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomInfoEnum")
	},
	{
		.name = discard_const_p(char, "in_info"),
		.get = py_lsa_SetInformationTrustedDomain_in_get_info,
		.set = py_lsa_SetInformationTrustedDomain_in_set_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustedDomainInfo")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_SetInformationTrustedDomain_get_result,
		.set = py_lsa_SetInformationTrustedDomain_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_SetInformationTrustedDomain_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_SetInformationTrustedDomain, type);
}

static PyObject *py_lsa_SetInformationTrustedDomain_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(27);
}

static PyObject *py_lsa_SetInformationTrustedDomain_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetInformationTrustedDomain *object = (struct lsa_SetInformationTrustedDomain *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 28) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetInformationTrustedDomain_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[27];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_SetInformationTrustedDomain_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetInformationTrustedDomain_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_SetInformationTrustedDomain_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetInformationTrustedDomain_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_SetInformationTrustedDomain_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetInformationTrustedDomain *object = (struct lsa_SetInformationTrustedDomain *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 28) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetInformationTrustedDomain_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[27];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_SetInformationTrustedDomain_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetInformationTrustedDomain_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetInformationTrustedDomain_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetInformationTrustedDomain_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetInformationTrustedDomain_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetInformationTrustedDomain *object = (struct lsa_SetInformationTrustedDomain *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 28) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetInformationTrustedDomain_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[27];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_SetInformationTrustedDomain_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_SetInformationTrustedDomain_ndr_print(py_obj, "lsa_SetInformationTrustedDomain_in", NDR_IN);
}

static PyObject *py_lsa_SetInformationTrustedDomain_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_SetInformationTrustedDomain_ndr_print(py_obj, "lsa_SetInformationTrustedDomain_out", NDR_OUT);
}

static PyMethodDef py_lsa_SetInformationTrustedDomain_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_SetInformationTrustedDomain_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.SetInformationTrustedDomain.opnum() -> 27 (0x1b) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_SetInformationTrustedDomain_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_SetInformationTrustedDomain_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_SetInformationTrustedDomain_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_SetInformationTrustedDomain_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_SetInformationTrustedDomain_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_SetInformationTrustedDomain_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_SetInformationTrustedDomain_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.SetInformationTrustedDomain",
	.tp_getset = py_lsa_SetInformationTrustedDomain_getsetters,
	.tp_methods = py_lsa_SetInformationTrustedDomain_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_SetInformationTrustedDomain_new,
};

static bool pack_py_lsa_SetInformationTrustedDomain_args_in(PyObject *args, PyObject *kwargs, struct lsa_SetInformationTrustedDomain *r)
{
	PyObject *py_trustdom_handle;
	PyObject *py_level;
	PyObject *py_info;
	const char *kwnames[] = {
		"trustdom_handle", "level", "info", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_SetInformationTrustedDomain", discard_const_p(char *, kwnames), &py_trustdom_handle, &py_level, &py_info)) {
		return false;
	}

	if (py_trustdom_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.trustdom_handle");
		return false;
	}
	r->in.trustdom_handle = talloc_ptrtype(r, r->in.trustdom_handle);
	if (r->in.trustdom_handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_trustdom_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_trustdom_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.trustdom_handle = (struct policy_handle *)pytalloc_get_ptr(py_trustdom_handle);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_info == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.info");
		return false;
	}
	r->in.info = talloc_ptrtype(r, r->in.info);
	if (r->in.info == NULL) {
		PyErr_NoMemory();
		return false;
	}
	{
		union lsa_TrustedDomainInfo *info_switch_1;
		info_switch_1 = (union lsa_TrustedDomainInfo *)pyrpc_export_union(&lsa_TrustedDomainInfo_Type, r, r->in.level, py_info, "union lsa_TrustedDomainInfo");
		if (info_switch_1 == NULL) {
			return false;
		}
		r->in.info = info_switch_1;
	}
	return true;
}

static PyObject *unpack_py_lsa_SetInformationTrustedDomain_args_out(struct lsa_SetInformationTrustedDomain *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_OpenSecret_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_OpenSecret *object = (struct lsa_OpenSecret *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_OpenSecret_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenSecret *object = (struct lsa_OpenSecret *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_OpenSecret_in_get_name(PyObject *obj, void *closure)
{
	struct lsa_OpenSecret *object = (struct lsa_OpenSecret *)pytalloc_get_ptr(obj);
	PyObject *py_name;
	py_name = pytalloc_reference_ex(&lsa_String_Type, pytalloc_get_mem_ctx(obj), &object->in.name);
	return py_name;
}

static int py_lsa_OpenSecret_in_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenSecret *object = (struct lsa_OpenSecret *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.name");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.name = *(struct lsa_String *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_OpenSecret_in_get_access_mask(PyObject *obj, void *closure)
{
	struct lsa_OpenSecret *object = (struct lsa_OpenSecret *)pytalloc_get_ptr(obj);
	PyObject *py_access_mask;
	py_access_mask = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.access_mask);
	return py_access_mask;
}

static int py_lsa_OpenSecret_in_set_access_mask(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenSecret *object = (struct lsa_OpenSecret *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.access_mask");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.access_mask));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_OpenSecret_out_get_sec_handle(PyObject *obj, void *closure)
{
	struct lsa_OpenSecret *object = (struct lsa_OpenSecret *)pytalloc_get_ptr(obj);
	PyObject *py_sec_handle;
	py_sec_handle = pytalloc_reference_ex(policy_handle_Type, object->out.sec_handle, object->out.sec_handle);
	return py_sec_handle;
}

static int py_lsa_OpenSecret_out_set_sec_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenSecret *object = (struct lsa_OpenSecret *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.sec_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.sec_handle");
		return -1;
	}
	object->out.sec_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.sec_handle);
	if (object->out.sec_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.sec_handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_OpenSecret_get_result(PyObject *obj, void *closure)
{
	struct lsa_OpenSecret *object = (struct lsa_OpenSecret *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_OpenSecret_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenSecret *object = (struct lsa_OpenSecret *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_OpenSecret_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_OpenSecret_in_get_handle,
		.set = py_lsa_OpenSecret_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_name"),
		.get = py_lsa_OpenSecret_in_get_name,
		.set = py_lsa_OpenSecret_in_set_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "in_access_mask"),
		.get = py_lsa_OpenSecret_in_get_access_mask,
		.set = py_lsa_OpenSecret_in_set_access_mask,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_SecretAccessMask")
	},
	{
		.name = discard_const_p(char, "out_sec_handle"),
		.get = py_lsa_OpenSecret_out_get_sec_handle,
		.set = py_lsa_OpenSecret_out_set_sec_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_OpenSecret_get_result,
		.set = py_lsa_OpenSecret_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_OpenSecret_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_OpenSecret, type);
}

static PyObject *py_lsa_OpenSecret_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(28);
}

static PyObject *py_lsa_OpenSecret_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenSecret *object = (struct lsa_OpenSecret *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 29) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenSecret_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[28];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_OpenSecret_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_OpenSecret_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_OpenSecret_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_OpenSecret_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_OpenSecret_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenSecret *object = (struct lsa_OpenSecret *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 29) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenSecret_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[28];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_OpenSecret_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_OpenSecret_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_OpenSecret_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_OpenSecret_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_OpenSecret_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenSecret *object = (struct lsa_OpenSecret *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 29) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenSecret_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[28];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_OpenSecret_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_OpenSecret_ndr_print(py_obj, "lsa_OpenSecret_in", NDR_IN);
}

static PyObject *py_lsa_OpenSecret_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_OpenSecret_ndr_print(py_obj, "lsa_OpenSecret_out", NDR_OUT);
}

static PyMethodDef py_lsa_OpenSecret_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_OpenSecret_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.OpenSecret.opnum() -> 28 (0x1c) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_OpenSecret_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_OpenSecret_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_OpenSecret_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_OpenSecret_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_OpenSecret_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_OpenSecret_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_OpenSecret_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.OpenSecret",
	.tp_getset = py_lsa_OpenSecret_getsetters,
	.tp_methods = py_lsa_OpenSecret_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_OpenSecret_new,
};

static bool pack_py_lsa_OpenSecret_args_in(PyObject *args, PyObject *kwargs, struct lsa_OpenSecret *r)
{
	PyObject *py_handle;
	PyObject *py_name;
	PyObject *py_access_mask;
	const char *kwnames[] = {
		"handle", "name", "access_mask", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_OpenSecret", discard_const_p(char *, kwnames), &py_handle, &py_name, &py_access_mask)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_name == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.name");
		return false;
	}
	PY_CHECK_TYPE(&lsa_String_Type, py_name, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_name)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.name = *(struct lsa_String *)pytalloc_get_ptr(py_name);
	if (py_access_mask == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.access_mask");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.access_mask));
		if (PyLong_Check(py_access_mask)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_access_mask);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else if (PyInt_Check(py_access_mask)) {
			long test_var;
			test_var = PyInt_AsLong(py_access_mask);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_OpenSecret_args_out(struct lsa_OpenSecret *r)
{
	PyObject *result;
	PyObject *py_sec_handle;
	py_sec_handle = pytalloc_reference_ex(policy_handle_Type, r->out.sec_handle, r->out.sec_handle);
	result = py_sec_handle;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_SetSecret_in_get_sec_handle(PyObject *obj, void *closure)
{
	struct lsa_SetSecret *object = (struct lsa_SetSecret *)pytalloc_get_ptr(obj);
	PyObject *py_sec_handle;
	py_sec_handle = pytalloc_reference_ex(policy_handle_Type, object->in.sec_handle, object->in.sec_handle);
	return py_sec_handle;
}

static int py_lsa_SetSecret_in_set_sec_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetSecret *object = (struct lsa_SetSecret *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.sec_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sec_handle");
		return -1;
	}
	object->in.sec_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.sec_handle);
	if (object->in.sec_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.sec_handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_SetSecret_in_get_new_val(PyObject *obj, void *closure)
{
	struct lsa_SetSecret *object = (struct lsa_SetSecret *)pytalloc_get_ptr(obj);
	PyObject *py_new_val;
	if (object->in.new_val == NULL) {
		py_new_val = Py_None;
		Py_INCREF(py_new_val);
	} else {
		py_new_val = pytalloc_reference_ex(&lsa_DATA_BUF_Type, object->in.new_val, object->in.new_val);
	}
	return py_new_val;
}

static int py_lsa_SetSecret_in_set_new_val(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetSecret *object = (struct lsa_SetSecret *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.new_val));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.new_val");
		return -1;
	}
	if (value == Py_None) {
		object->in.new_val = NULL;
	} else {
		object->in.new_val = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->in.new_val = (struct lsa_DATA_BUF *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_SetSecret_in_get_old_val(PyObject *obj, void *closure)
{
	struct lsa_SetSecret *object = (struct lsa_SetSecret *)pytalloc_get_ptr(obj);
	PyObject *py_old_val;
	if (object->in.old_val == NULL) {
		py_old_val = Py_None;
		Py_INCREF(py_old_val);
	} else {
		py_old_val = pytalloc_reference_ex(&lsa_DATA_BUF_Type, object->in.old_val, object->in.old_val);
	}
	return py_old_val;
}

static int py_lsa_SetSecret_in_set_old_val(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetSecret *object = (struct lsa_SetSecret *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.old_val));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.old_val");
		return -1;
	}
	if (value == Py_None) {
		object->in.old_val = NULL;
	} else {
		object->in.old_val = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->in.old_val = (struct lsa_DATA_BUF *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_SetSecret_get_result(PyObject *obj, void *closure)
{
	struct lsa_SetSecret *object = (struct lsa_SetSecret *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_SetSecret_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetSecret *object = (struct lsa_SetSecret *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_SetSecret_getsetters[] = {
	{
		.name = discard_const_p(char, "in_sec_handle"),
		.get = py_lsa_SetSecret_in_get_sec_handle,
		.set = py_lsa_SetSecret_in_set_sec_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_new_val"),
		.get = py_lsa_SetSecret_in_get_new_val,
		.set = py_lsa_SetSecret_in_set_new_val,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DATA_BUF")
	},
	{
		.name = discard_const_p(char, "in_old_val"),
		.get = py_lsa_SetSecret_in_get_old_val,
		.set = py_lsa_SetSecret_in_set_old_val,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DATA_BUF")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_SetSecret_get_result,
		.set = py_lsa_SetSecret_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_SetSecret_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_SetSecret, type);
}

static PyObject *py_lsa_SetSecret_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(29);
}

static PyObject *py_lsa_SetSecret_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetSecret *object = (struct lsa_SetSecret *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 30) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetSecret_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[29];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_SetSecret_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetSecret_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_SetSecret_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetSecret_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_SetSecret_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetSecret *object = (struct lsa_SetSecret *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 30) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetSecret_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[29];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_SetSecret_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetSecret_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetSecret_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetSecret_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetSecret_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetSecret *object = (struct lsa_SetSecret *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 30) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetSecret_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[29];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_SetSecret_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_SetSecret_ndr_print(py_obj, "lsa_SetSecret_in", NDR_IN);
}

static PyObject *py_lsa_SetSecret_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_SetSecret_ndr_print(py_obj, "lsa_SetSecret_out", NDR_OUT);
}

static PyMethodDef py_lsa_SetSecret_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_SetSecret_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.SetSecret.opnum() -> 29 (0x1d) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_SetSecret_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_SetSecret_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_SetSecret_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_SetSecret_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_SetSecret_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_SetSecret_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_SetSecret_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.SetSecret",
	.tp_getset = py_lsa_SetSecret_getsetters,
	.tp_methods = py_lsa_SetSecret_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_SetSecret_new,
};

static bool pack_py_lsa_SetSecret_args_in(PyObject *args, PyObject *kwargs, struct lsa_SetSecret *r)
{
	PyObject *py_sec_handle;
	PyObject *py_new_val;
	PyObject *py_old_val;
	const char *kwnames[] = {
		"sec_handle", "new_val", "old_val", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_SetSecret", discard_const_p(char *, kwnames), &py_sec_handle, &py_new_val, &py_old_val)) {
		return false;
	}

	if (py_sec_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sec_handle");
		return false;
	}
	r->in.sec_handle = talloc_ptrtype(r, r->in.sec_handle);
	if (r->in.sec_handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_sec_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_sec_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.sec_handle = (struct policy_handle *)pytalloc_get_ptr(py_sec_handle);
	if (py_new_val == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.new_val");
		return false;
	}
	if (py_new_val == Py_None) {
		r->in.new_val = NULL;
	} else {
		r->in.new_val = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_Type, py_new_val, return false;);
		if (talloc_reference(r, pytalloc_get_mem_ctx(py_new_val)) == NULL) {
			PyErr_NoMemory();
			return false;
		}
		r->in.new_val = (struct lsa_DATA_BUF *)pytalloc_get_ptr(py_new_val);
	}
	if (py_old_val == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.old_val");
		return false;
	}
	if (py_old_val == Py_None) {
		r->in.old_val = NULL;
	} else {
		r->in.old_val = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_Type, py_old_val, return false;);
		if (talloc_reference(r, pytalloc_get_mem_ctx(py_old_val)) == NULL) {
			PyErr_NoMemory();
			return false;
		}
		r->in.old_val = (struct lsa_DATA_BUF *)pytalloc_get_ptr(py_old_val);
	}
	return true;
}

static PyObject *unpack_py_lsa_SetSecret_args_out(struct lsa_SetSecret *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_QuerySecret_in_get_sec_handle(PyObject *obj, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(obj);
	PyObject *py_sec_handle;
	py_sec_handle = pytalloc_reference_ex(policy_handle_Type, object->in.sec_handle, object->in.sec_handle);
	return py_sec_handle;
}

static int py_lsa_QuerySecret_in_set_sec_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.sec_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sec_handle");
		return -1;
	}
	object->in.sec_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.sec_handle);
	if (object->in.sec_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.sec_handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_QuerySecret_in_get_new_val(PyObject *obj, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(obj);
	PyObject *py_new_val;
	if (object->in.new_val == NULL) {
		py_new_val = Py_None;
		Py_INCREF(py_new_val);
	} else {
		py_new_val = pytalloc_reference_ex(&lsa_DATA_BUF_PTR_Type, object->in.new_val, object->in.new_val);
	}
	return py_new_val;
}

static int py_lsa_QuerySecret_in_set_new_val(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.new_val));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.new_val");
		return -1;
	}
	if (value == Py_None) {
		object->in.new_val = NULL;
	} else {
		object->in.new_val = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_PTR_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->in.new_val = (struct lsa_DATA_BUF_PTR *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_QuerySecret_out_get_new_val(PyObject *obj, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(obj);
	PyObject *py_new_val;
	if (object->out.new_val == NULL) {
		py_new_val = Py_None;
		Py_INCREF(py_new_val);
	} else {
		py_new_val = pytalloc_reference_ex(&lsa_DATA_BUF_PTR_Type, object->out.new_val, object->out.new_val);
	}
	return py_new_val;
}

static int py_lsa_QuerySecret_out_set_new_val(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.new_val));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.new_val");
		return -1;
	}
	if (value == Py_None) {
		object->out.new_val = NULL;
	} else {
		object->out.new_val = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_PTR_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->out.new_val = (struct lsa_DATA_BUF_PTR *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_QuerySecret_in_get_new_mtime(PyObject *obj, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(obj);
	PyObject *py_new_mtime;
	if (object->in.new_mtime == NULL) {
		py_new_mtime = Py_None;
		Py_INCREF(py_new_mtime);
	} else {
		py_new_mtime = ndr_PyLong_FromUnsignedLongLong(*object->in.new_mtime);
	}
	return py_new_mtime;
}

static int py_lsa_QuerySecret_in_set_new_mtime(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.new_mtime));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.new_mtime");
		return -1;
	}
	if (value == Py_None) {
		object->in.new_mtime = NULL;
	} else {
		object->in.new_mtime = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.new_mtime);
		if (object->in.new_mtime == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		{
			const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->in.new_mtime));
			if (PyLong_Check(value)) {
				unsigned long long test_var;
				test_var = PyLong_AsUnsignedLongLong(value);
				if (PyErr_Occurred() != NULL) {
					return -1;
				}
				if (test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return -1;
				}
				*object->in.new_mtime = test_var;
			} else if (PyInt_Check(value)) {
				long test_var;
				test_var = PyInt_AsLong(value);
				if (test_var < 0 || test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return -1;
				}
				*object->in.new_mtime = test_var;
			} else {
				PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name);
				return -1;
			}
		}
	}
	return 0;
}

static PyObject *py_lsa_QuerySecret_out_get_new_mtime(PyObject *obj, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(obj);
	PyObject *py_new_mtime;
	if (object->out.new_mtime == NULL) {
		py_new_mtime = Py_None;
		Py_INCREF(py_new_mtime);
	} else {
		py_new_mtime = ndr_PyLong_FromUnsignedLongLong(*object->out.new_mtime);
	}
	return py_new_mtime;
}

static int py_lsa_QuerySecret_out_set_new_mtime(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.new_mtime));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.new_mtime");
		return -1;
	}
	if (value == Py_None) {
		object->out.new_mtime = NULL;
	} else {
		object->out.new_mtime = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.new_mtime);
		if (object->out.new_mtime == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		{
			const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->out.new_mtime));
			if (PyLong_Check(value)) {
				unsigned long long test_var;
				test_var = PyLong_AsUnsignedLongLong(value);
				if (PyErr_Occurred() != NULL) {
					return -1;
				}
				if (test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return -1;
				}
				*object->out.new_mtime = test_var;
			} else if (PyInt_Check(value)) {
				long test_var;
				test_var = PyInt_AsLong(value);
				if (test_var < 0 || test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return -1;
				}
				*object->out.new_mtime = test_var;
			} else {
				PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name);
				return -1;
			}
		}
	}
	return 0;
}

static PyObject *py_lsa_QuerySecret_in_get_old_val(PyObject *obj, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(obj);
	PyObject *py_old_val;
	if (object->in.old_val == NULL) {
		py_old_val = Py_None;
		Py_INCREF(py_old_val);
	} else {
		py_old_val = pytalloc_reference_ex(&lsa_DATA_BUF_PTR_Type, object->in.old_val, object->in.old_val);
	}
	return py_old_val;
}

static int py_lsa_QuerySecret_in_set_old_val(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.old_val));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.old_val");
		return -1;
	}
	if (value == Py_None) {
		object->in.old_val = NULL;
	} else {
		object->in.old_val = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_PTR_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->in.old_val = (struct lsa_DATA_BUF_PTR *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_QuerySecret_out_get_old_val(PyObject *obj, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(obj);
	PyObject *py_old_val;
	if (object->out.old_val == NULL) {
		py_old_val = Py_None;
		Py_INCREF(py_old_val);
	} else {
		py_old_val = pytalloc_reference_ex(&lsa_DATA_BUF_PTR_Type, object->out.old_val, object->out.old_val);
	}
	return py_old_val;
}

static int py_lsa_QuerySecret_out_set_old_val(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.old_val));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.old_val");
		return -1;
	}
	if (value == Py_None) {
		object->out.old_val = NULL;
	} else {
		object->out.old_val = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_PTR_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->out.old_val = (struct lsa_DATA_BUF_PTR *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_QuerySecret_in_get_old_mtime(PyObject *obj, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(obj);
	PyObject *py_old_mtime;
	if (object->in.old_mtime == NULL) {
		py_old_mtime = Py_None;
		Py_INCREF(py_old_mtime);
	} else {
		py_old_mtime = ndr_PyLong_FromUnsignedLongLong(*object->in.old_mtime);
	}
	return py_old_mtime;
}

static int py_lsa_QuerySecret_in_set_old_mtime(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.old_mtime));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.old_mtime");
		return -1;
	}
	if (value == Py_None) {
		object->in.old_mtime = NULL;
	} else {
		object->in.old_mtime = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.old_mtime);
		if (object->in.old_mtime == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		{
			const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->in.old_mtime));
			if (PyLong_Check(value)) {
				unsigned long long test_var;
				test_var = PyLong_AsUnsignedLongLong(value);
				if (PyErr_Occurred() != NULL) {
					return -1;
				}
				if (test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return -1;
				}
				*object->in.old_mtime = test_var;
			} else if (PyInt_Check(value)) {
				long test_var;
				test_var = PyInt_AsLong(value);
				if (test_var < 0 || test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return -1;
				}
				*object->in.old_mtime = test_var;
			} else {
				PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name);
				return -1;
			}
		}
	}
	return 0;
}

static PyObject *py_lsa_QuerySecret_out_get_old_mtime(PyObject *obj, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(obj);
	PyObject *py_old_mtime;
	if (object->out.old_mtime == NULL) {
		py_old_mtime = Py_None;
		Py_INCREF(py_old_mtime);
	} else {
		py_old_mtime = ndr_PyLong_FromUnsignedLongLong(*object->out.old_mtime);
	}
	return py_old_mtime;
}

static int py_lsa_QuerySecret_out_set_old_mtime(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.old_mtime));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.old_mtime");
		return -1;
	}
	if (value == Py_None) {
		object->out.old_mtime = NULL;
	} else {
		object->out.old_mtime = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.old_mtime);
		if (object->out.old_mtime == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		{
			const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->out.old_mtime));
			if (PyLong_Check(value)) {
				unsigned long long test_var;
				test_var = PyLong_AsUnsignedLongLong(value);
				if (PyErr_Occurred() != NULL) {
					return -1;
				}
				if (test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return -1;
				}
				*object->out.old_mtime = test_var;
			} else if (PyInt_Check(value)) {
				long test_var;
				test_var = PyInt_AsLong(value);
				if (test_var < 0 || test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return -1;
				}
				*object->out.old_mtime = test_var;
			} else {
				PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name);
				return -1;
			}
		}
	}
	return 0;
}

static PyObject *py_lsa_QuerySecret_get_result(PyObject *obj, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_QuerySecret_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_QuerySecret_getsetters[] = {
	{
		.name = discard_const_p(char, "in_sec_handle"),
		.get = py_lsa_QuerySecret_in_get_sec_handle,
		.set = py_lsa_QuerySecret_in_set_sec_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_new_val"),
		.get = py_lsa_QuerySecret_in_get_new_val,
		.set = py_lsa_QuerySecret_in_set_new_val,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DATA_BUF_PTR")
	},
	{
		.name = discard_const_p(char, "out_new_val"),
		.get = py_lsa_QuerySecret_out_get_new_val,
		.set = py_lsa_QuerySecret_out_set_new_val,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DATA_BUF_PTR")
	},
	{
		.name = discard_const_p(char, "in_new_mtime"),
		.get = py_lsa_QuerySecret_in_get_new_mtime,
		.set = py_lsa_QuerySecret_in_set_new_mtime,
		.doc = discard_const_p(char, "PIDL-generated element of base type NTTIME_hyper")
	},
	{
		.name = discard_const_p(char, "out_new_mtime"),
		.get = py_lsa_QuerySecret_out_get_new_mtime,
		.set = py_lsa_QuerySecret_out_set_new_mtime,
		.doc = discard_const_p(char, "PIDL-generated element of base type NTTIME_hyper")
	},
	{
		.name = discard_const_p(char, "in_old_val"),
		.get = py_lsa_QuerySecret_in_get_old_val,
		.set = py_lsa_QuerySecret_in_set_old_val,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DATA_BUF_PTR")
	},
	{
		.name = discard_const_p(char, "out_old_val"),
		.get = py_lsa_QuerySecret_out_get_old_val,
		.set = py_lsa_QuerySecret_out_set_old_val,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DATA_BUF_PTR")
	},
	{
		.name = discard_const_p(char, "in_old_mtime"),
		.get = py_lsa_QuerySecret_in_get_old_mtime,
		.set = py_lsa_QuerySecret_in_set_old_mtime,
		.doc = discard_const_p(char, "PIDL-generated element of base type NTTIME_hyper")
	},
	{
		.name = discard_const_p(char, "out_old_mtime"),
		.get = py_lsa_QuerySecret_out_get_old_mtime,
		.set = py_lsa_QuerySecret_out_set_old_mtime,
		.doc = discard_const_p(char, "PIDL-generated element of base type NTTIME_hyper")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_QuerySecret_get_result,
		.set = py_lsa_QuerySecret_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_QuerySecret_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_QuerySecret, type);
}

static PyObject *py_lsa_QuerySecret_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(30);
}

static PyObject *py_lsa_QuerySecret_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 31) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QuerySecret_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[30];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_QuerySecret_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_QuerySecret_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_QuerySecret_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_QuerySecret_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_QuerySecret_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 31) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QuerySecret_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[30];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_QuerySecret_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_QuerySecret_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_QuerySecret_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_QuerySecret_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_QuerySecret_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QuerySecret *object = (struct lsa_QuerySecret *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 31) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QuerySecret_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[30];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_QuerySecret_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_QuerySecret_ndr_print(py_obj, "lsa_QuerySecret_in", NDR_IN);
}

static PyObject *py_lsa_QuerySecret_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_QuerySecret_ndr_print(py_obj, "lsa_QuerySecret_out", NDR_OUT);
}

static PyMethodDef py_lsa_QuerySecret_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_QuerySecret_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.QuerySecret.opnum() -> 30 (0x1e) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_QuerySecret_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_QuerySecret_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_QuerySecret_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_QuerySecret_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_QuerySecret_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_QuerySecret_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_QuerySecret_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.QuerySecret",
	.tp_getset = py_lsa_QuerySecret_getsetters,
	.tp_methods = py_lsa_QuerySecret_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_QuerySecret_new,
};

static bool pack_py_lsa_QuerySecret_args_in(PyObject *args, PyObject *kwargs, struct lsa_QuerySecret *r)
{
	PyObject *py_sec_handle;
	PyObject *py_new_val;
	PyObject *py_new_mtime;
	PyObject *py_old_val;
	PyObject *py_old_mtime;
	const char *kwnames[] = {
		"sec_handle", "new_val", "new_mtime", "old_val", "old_mtime", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOOO:lsa_QuerySecret", discard_const_p(char *, kwnames), &py_sec_handle, &py_new_val, &py_new_mtime, &py_old_val, &py_old_mtime)) {
		return false;
	}

	if (py_sec_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sec_handle");
		return false;
	}
	r->in.sec_handle = talloc_ptrtype(r, r->in.sec_handle);
	if (r->in.sec_handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_sec_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_sec_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.sec_handle = (struct policy_handle *)pytalloc_get_ptr(py_sec_handle);
	if (py_new_val == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.new_val");
		return false;
	}
	if (py_new_val == Py_None) {
		r->in.new_val = NULL;
	} else {
		r->in.new_val = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_PTR_Type, py_new_val, return false;);
		if (talloc_reference(r, pytalloc_get_mem_ctx(py_new_val)) == NULL) {
			PyErr_NoMemory();
			return false;
		}
		r->in.new_val = (struct lsa_DATA_BUF_PTR *)pytalloc_get_ptr(py_new_val);
	}
	if (py_new_mtime == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.new_mtime");
		return false;
	}
	if (py_new_mtime == Py_None) {
		r->in.new_mtime = NULL;
	} else {
		r->in.new_mtime = talloc_ptrtype(r, r->in.new_mtime);
		if (r->in.new_mtime == NULL) {
			PyErr_NoMemory();
			return false;
		}
		{
			const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*r->in.new_mtime));
			if (PyLong_Check(py_new_mtime)) {
				unsigned long long test_var;
				test_var = PyLong_AsUnsignedLongLong(py_new_mtime);
				if (PyErr_Occurred() != NULL) {
					return false;
				}
				if (test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return false;
				}
				*r->in.new_mtime = test_var;
			} else if (PyInt_Check(py_new_mtime)) {
				long test_var;
				test_var = PyInt_AsLong(py_new_mtime);
				if (test_var < 0 || test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return false;
				}
				*r->in.new_mtime = test_var;
			} else {
				PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name);
				return false;
			}
		}
	}
	if (py_old_val == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.old_val");
		return false;
	}
	if (py_old_val == Py_None) {
		r->in.old_val = NULL;
	} else {
		r->in.old_val = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_PTR_Type, py_old_val, return false;);
		if (talloc_reference(r, pytalloc_get_mem_ctx(py_old_val)) == NULL) {
			PyErr_NoMemory();
			return false;
		}
		r->in.old_val = (struct lsa_DATA_BUF_PTR *)pytalloc_get_ptr(py_old_val);
	}
	if (py_old_mtime == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.old_mtime");
		return false;
	}
	if (py_old_mtime == Py_None) {
		r->in.old_mtime = NULL;
	} else {
		r->in.old_mtime = talloc_ptrtype(r, r->in.old_mtime);
		if (r->in.old_mtime == NULL) {
			PyErr_NoMemory();
			return false;
		}
		{
			const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*r->in.old_mtime));
			if (PyLong_Check(py_old_mtime)) {
				unsigned long long test_var;
				test_var = PyLong_AsUnsignedLongLong(py_old_mtime);
				if (PyErr_Occurred() != NULL) {
					return false;
				}
				if (test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return false;
				}
				*r->in.old_mtime = test_var;
			} else if (PyInt_Check(py_old_mtime)) {
				long test_var;
				test_var = PyInt_AsLong(py_old_mtime);
				if (test_var < 0 || test_var > uint_max) {
					PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
					return false;
				}
				*r->in.old_mtime = test_var;
			} else {
				PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name);
				return false;
			}
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_QuerySecret_args_out(struct lsa_QuerySecret *r)
{
	PyObject *result;
	PyObject *py_new_val;
	PyObject *py_new_mtime;
	PyObject *py_old_val;
	PyObject *py_old_mtime;
	result = PyTuple_New(4);
	if (r->out.new_val == NULL) {
		py_new_val = Py_None;
		Py_INCREF(py_new_val);
	} else {
		py_new_val = pytalloc_reference_ex(&lsa_DATA_BUF_PTR_Type, r->out.new_val, r->out.new_val);
	}
	PyTuple_SetItem(result, 0, py_new_val);
	if (r->out.new_mtime == NULL) {
		py_new_mtime = Py_None;
		Py_INCREF(py_new_mtime);
	} else {
		py_new_mtime = ndr_PyLong_FromUnsignedLongLong(*r->out.new_mtime);
	}
	PyTuple_SetItem(result, 1, py_new_mtime);
	if (r->out.old_val == NULL) {
		py_old_val = Py_None;
		Py_INCREF(py_old_val);
	} else {
		py_old_val = pytalloc_reference_ex(&lsa_DATA_BUF_PTR_Type, r->out.old_val, r->out.old_val);
	}
	PyTuple_SetItem(result, 2, py_old_val);
	if (r->out.old_mtime == NULL) {
		py_old_mtime = Py_None;
		Py_INCREF(py_old_mtime);
	} else {
		py_old_mtime = ndr_PyLong_FromUnsignedLongLong(*r->out.old_mtime);
	}
	PyTuple_SetItem(result, 3, py_old_mtime);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_LookupPrivValue_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_LookupPrivValue *object = (struct lsa_LookupPrivValue *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_LookupPrivValue_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupPrivValue *object = (struct lsa_LookupPrivValue *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupPrivValue_in_get_name(PyObject *obj, void *closure)
{
	struct lsa_LookupPrivValue *object = (struct lsa_LookupPrivValue *)pytalloc_get_ptr(obj);
	PyObject *py_name;
	py_name = pytalloc_reference_ex(&lsa_String_Type, object->in.name, object->in.name);
	return py_name;
}

static int py_lsa_LookupPrivValue_in_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupPrivValue *object = (struct lsa_LookupPrivValue *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.name));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.name");
		return -1;
	}
	object->in.name = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.name);
	if (object->in.name == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.name = (struct lsa_String *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupPrivValue_out_get_luid(PyObject *obj, void *closure)
{
	struct lsa_LookupPrivValue *object = (struct lsa_LookupPrivValue *)pytalloc_get_ptr(obj);
	PyObject *py_luid;
	py_luid = pytalloc_reference_ex(&lsa_LUID_Type, object->out.luid, object->out.luid);
	return py_luid;
}

static int py_lsa_LookupPrivValue_out_set_luid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupPrivValue *object = (struct lsa_LookupPrivValue *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.luid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.luid");
		return -1;
	}
	object->out.luid = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.luid);
	if (object->out.luid == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_LUID_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.luid = (struct lsa_LUID *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupPrivValue_get_result(PyObject *obj, void *closure)
{
	struct lsa_LookupPrivValue *object = (struct lsa_LookupPrivValue *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_LookupPrivValue_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupPrivValue *object = (struct lsa_LookupPrivValue *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_LookupPrivValue_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_LookupPrivValue_in_get_handle,
		.set = py_lsa_LookupPrivValue_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_name"),
		.get = py_lsa_LookupPrivValue_in_get_name,
		.set = py_lsa_LookupPrivValue_in_set_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "out_luid"),
		.get = py_lsa_LookupPrivValue_out_get_luid,
		.set = py_lsa_LookupPrivValue_out_set_luid,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_LUID")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_LookupPrivValue_get_result,
		.set = py_lsa_LookupPrivValue_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_LookupPrivValue_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_LookupPrivValue, type);
}

static PyObject *py_lsa_LookupPrivValue_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(31);
}

static PyObject *py_lsa_LookupPrivValue_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupPrivValue *object = (struct lsa_LookupPrivValue *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 32) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupPrivValue_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[31];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_LookupPrivValue_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupPrivValue_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_LookupPrivValue_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupPrivValue_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_LookupPrivValue_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupPrivValue *object = (struct lsa_LookupPrivValue *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 32) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupPrivValue_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[31];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_LookupPrivValue_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupPrivValue_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupPrivValue_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupPrivValue_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupPrivValue_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupPrivValue *object = (struct lsa_LookupPrivValue *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 32) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupPrivValue_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[31];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_LookupPrivValue_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_LookupPrivValue_ndr_print(py_obj, "lsa_LookupPrivValue_in", NDR_IN);
}

static PyObject *py_lsa_LookupPrivValue_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_LookupPrivValue_ndr_print(py_obj, "lsa_LookupPrivValue_out", NDR_OUT);
}

static PyMethodDef py_lsa_LookupPrivValue_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_LookupPrivValue_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.LookupPrivValue.opnum() -> 31 (0x1f) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_LookupPrivValue_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_LookupPrivValue_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_LookupPrivValue_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_LookupPrivValue_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_LookupPrivValue_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_LookupPrivValue_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_LookupPrivValue_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.LookupPrivValue",
	.tp_getset = py_lsa_LookupPrivValue_getsetters,
	.tp_methods = py_lsa_LookupPrivValue_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_LookupPrivValue_new,
};

static bool pack_py_lsa_LookupPrivValue_args_in(PyObject *args, PyObject *kwargs, struct lsa_LookupPrivValue *r)
{
	PyObject *py_handle;
	PyObject *py_name;
	const char *kwnames[] = {
		"handle", "name", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:lsa_LookupPrivValue", discard_const_p(char *, kwnames), &py_handle, &py_name)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_name == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.name");
		return false;
	}
	r->in.name = talloc_ptrtype(r, r->in.name);
	if (r->in.name == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_String_Type, py_name, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_name)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.name = (struct lsa_String *)pytalloc_get_ptr(py_name);
	return true;
}

static PyObject *unpack_py_lsa_LookupPrivValue_args_out(struct lsa_LookupPrivValue *r)
{
	PyObject *result;
	PyObject *py_luid;
	py_luid = pytalloc_reference_ex(&lsa_LUID_Type, r->out.luid, r->out.luid);
	result = py_luid;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_LookupPrivName_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_LookupPrivName *object = (struct lsa_LookupPrivName *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_LookupPrivName_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupPrivName *object = (struct lsa_LookupPrivName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupPrivName_in_get_luid(PyObject *obj, void *closure)
{
	struct lsa_LookupPrivName *object = (struct lsa_LookupPrivName *)pytalloc_get_ptr(obj);
	PyObject *py_luid;
	py_luid = pytalloc_reference_ex(&lsa_LUID_Type, object->in.luid, object->in.luid);
	return py_luid;
}

static int py_lsa_LookupPrivName_in_set_luid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupPrivName *object = (struct lsa_LookupPrivName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.luid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.luid");
		return -1;
	}
	object->in.luid = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.luid);
	if (object->in.luid == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_LUID_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.luid = (struct lsa_LUID *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupPrivName_out_get_name(PyObject *obj, void *closure)
{
	struct lsa_LookupPrivName *object = (struct lsa_LookupPrivName *)pytalloc_get_ptr(obj);
	PyObject *py_name;
	if (*object->out.name == NULL) {
		py_name = Py_None;
		Py_INCREF(py_name);
	} else {
		py_name = pytalloc_reference_ex(&lsa_StringLarge_Type, *object->out.name, *object->out.name);
	}
	return py_name;
}

static int py_lsa_LookupPrivName_out_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupPrivName *object = (struct lsa_LookupPrivName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.name));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.name");
		return -1;
	}
	object->out.name = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.name);
	if (object->out.name == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.name = NULL;
	} else {
		*object->out.name = NULL;
		PY_CHECK_TYPE(&lsa_StringLarge_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		*object->out.name = (struct lsa_StringLarge *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_LookupPrivName_get_result(PyObject *obj, void *closure)
{
	struct lsa_LookupPrivName *object = (struct lsa_LookupPrivName *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_LookupPrivName_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupPrivName *object = (struct lsa_LookupPrivName *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_LookupPrivName_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_LookupPrivName_in_get_handle,
		.set = py_lsa_LookupPrivName_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_luid"),
		.get = py_lsa_LookupPrivName_in_get_luid,
		.set = py_lsa_LookupPrivName_in_set_luid,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_LUID")
	},
	{
		.name = discard_const_p(char, "out_name"),
		.get = py_lsa_LookupPrivName_out_get_name,
		.set = py_lsa_LookupPrivName_out_set_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_StringLarge")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_LookupPrivName_get_result,
		.set = py_lsa_LookupPrivName_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_LookupPrivName_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_LookupPrivName, type);
}

static PyObject *py_lsa_LookupPrivName_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(32);
}

static PyObject *py_lsa_LookupPrivName_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupPrivName *object = (struct lsa_LookupPrivName *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 33) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupPrivName_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[32];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_LookupPrivName_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupPrivName_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_LookupPrivName_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupPrivName_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_LookupPrivName_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupPrivName *object = (struct lsa_LookupPrivName *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 33) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupPrivName_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[32];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_LookupPrivName_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupPrivName_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupPrivName_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupPrivName_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupPrivName_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupPrivName *object = (struct lsa_LookupPrivName *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 33) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupPrivName_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[32];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_LookupPrivName_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_LookupPrivName_ndr_print(py_obj, "lsa_LookupPrivName_in", NDR_IN);
}

static PyObject *py_lsa_LookupPrivName_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_LookupPrivName_ndr_print(py_obj, "lsa_LookupPrivName_out", NDR_OUT);
}

static PyMethodDef py_lsa_LookupPrivName_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_LookupPrivName_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.LookupPrivName.opnum() -> 32 (0x20) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_LookupPrivName_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_LookupPrivName_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_LookupPrivName_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_LookupPrivName_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_LookupPrivName_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_LookupPrivName_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_LookupPrivName_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.LookupPrivName",
	.tp_getset = py_lsa_LookupPrivName_getsetters,
	.tp_methods = py_lsa_LookupPrivName_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_LookupPrivName_new,
};

static bool pack_py_lsa_LookupPrivName_args_in(PyObject *args, PyObject *kwargs, struct lsa_LookupPrivName *r)
{
	PyObject *py_handle;
	PyObject *py_luid;
	const char *kwnames[] = {
		"handle", "luid", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:lsa_LookupPrivName", discard_const_p(char *, kwnames), &py_handle, &py_luid)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_luid == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.luid");
		return false;
	}
	r->in.luid = talloc_ptrtype(r, r->in.luid);
	if (r->in.luid == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_LUID_Type, py_luid, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_luid)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.luid = (struct lsa_LUID *)pytalloc_get_ptr(py_luid);
	return true;
}

static PyObject *unpack_py_lsa_LookupPrivName_args_out(struct lsa_LookupPrivName *r)
{
	PyObject *result;
	PyObject *py_name;
	if (*r->out.name == NULL) {
		py_name = Py_None;
		Py_INCREF(py_name);
	} else {
		py_name = pytalloc_reference_ex(&lsa_StringLarge_Type, *r->out.name, *r->out.name);
	}
	result = py_name;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_LookupPrivDisplayName_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_LookupPrivDisplayName *object = (struct lsa_LookupPrivDisplayName *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_LookupPrivDisplayName_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupPrivDisplayName *object = (struct lsa_LookupPrivDisplayName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupPrivDisplayName_in_get_name(PyObject *obj, void *closure)
{
	struct lsa_LookupPrivDisplayName *object = (struct lsa_LookupPrivDisplayName *)pytalloc_get_ptr(obj);
	PyObject *py_name;
	py_name = pytalloc_reference_ex(&lsa_String_Type, object->in.name, object->in.name);
	return py_name;
}

static int py_lsa_LookupPrivDisplayName_in_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupPrivDisplayName *object = (struct lsa_LookupPrivDisplayName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.name));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.name");
		return -1;
	}
	object->in.name = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.name);
	if (object->in.name == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.name = (struct lsa_String *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupPrivDisplayName_in_get_language_id(PyObject *obj, void *closure)
{
	struct lsa_LookupPrivDisplayName *object = (struct lsa_LookupPrivDisplayName *)pytalloc_get_ptr(obj);
	PyObject *py_language_id;
	py_language_id = PyInt_FromLong((uint16_t)object->in.language_id);
	return py_language_id;
}

static int py_lsa_LookupPrivDisplayName_in_set_language_id(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupPrivDisplayName *object = (struct lsa_LookupPrivDisplayName *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.language_id");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.language_id));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.language_id = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.language_id = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupPrivDisplayName_in_get_language_id_sys(PyObject *obj, void *closure)
{
	struct lsa_LookupPrivDisplayName *object = (struct lsa_LookupPrivDisplayName *)pytalloc_get_ptr(obj);
	PyObject *py_language_id_sys;
	py_language_id_sys = PyInt_FromLong((uint16_t)object->in.language_id_sys);
	return py_language_id_sys;
}

static int py_lsa_LookupPrivDisplayName_in_set_language_id_sys(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupPrivDisplayName *object = (struct lsa_LookupPrivDisplayName *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.language_id_sys");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.language_id_sys));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.language_id_sys = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.language_id_sys = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupPrivDisplayName_out_get_disp_name(PyObject *obj, void *closure)
{
	struct lsa_LookupPrivDisplayName *object = (struct lsa_LookupPrivDisplayName *)pytalloc_get_ptr(obj);
	PyObject *py_disp_name;
	if (*object->out.disp_name == NULL) {
		py_disp_name = Py_None;
		Py_INCREF(py_disp_name);
	} else {
		py_disp_name = pytalloc_reference_ex(&lsa_StringLarge_Type, *object->out.disp_name, *object->out.disp_name);
	}
	return py_disp_name;
}

static int py_lsa_LookupPrivDisplayName_out_set_disp_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupPrivDisplayName *object = (struct lsa_LookupPrivDisplayName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.disp_name));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.disp_name");
		return -1;
	}
	object->out.disp_name = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.disp_name);
	if (object->out.disp_name == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.disp_name = NULL;
	} else {
		*object->out.disp_name = NULL;
		PY_CHECK_TYPE(&lsa_StringLarge_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		*object->out.disp_name = (struct lsa_StringLarge *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_LookupPrivDisplayName_out_get_returned_language_id(PyObject *obj, void *closure)
{
	struct lsa_LookupPrivDisplayName *object = (struct lsa_LookupPrivDisplayName *)pytalloc_get_ptr(obj);
	PyObject *py_returned_language_id;
	py_returned_language_id = PyInt_FromLong((uint16_t)*object->out.returned_language_id);
	return py_returned_language_id;
}

static int py_lsa_LookupPrivDisplayName_out_set_returned_language_id(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupPrivDisplayName *object = (struct lsa_LookupPrivDisplayName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.returned_language_id));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.returned_language_id");
		return -1;
	}
	object->out.returned_language_id = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.returned_language_id);
	if (object->out.returned_language_id == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->out.returned_language_id));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.returned_language_id = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.returned_language_id = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupPrivDisplayName_get_result(PyObject *obj, void *closure)
{
	struct lsa_LookupPrivDisplayName *object = (struct lsa_LookupPrivDisplayName *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_LookupPrivDisplayName_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupPrivDisplayName *object = (struct lsa_LookupPrivDisplayName *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_LookupPrivDisplayName_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_LookupPrivDisplayName_in_get_handle,
		.set = py_lsa_LookupPrivDisplayName_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_name"),
		.get = py_lsa_LookupPrivDisplayName_in_get_name,
		.set = py_lsa_LookupPrivDisplayName_in_set_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "in_language_id"),
		.get = py_lsa_LookupPrivDisplayName_in_get_language_id,
		.set = py_lsa_LookupPrivDisplayName_in_set_language_id,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "in_language_id_sys"),
		.get = py_lsa_LookupPrivDisplayName_in_get_language_id_sys,
		.set = py_lsa_LookupPrivDisplayName_in_set_language_id_sys,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "out_disp_name"),
		.get = py_lsa_LookupPrivDisplayName_out_get_disp_name,
		.set = py_lsa_LookupPrivDisplayName_out_set_disp_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_StringLarge")
	},
	{
		.name = discard_const_p(char, "out_returned_language_id"),
		.get = py_lsa_LookupPrivDisplayName_out_get_returned_language_id,
		.set = py_lsa_LookupPrivDisplayName_out_set_returned_language_id,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_LookupPrivDisplayName_get_result,
		.set = py_lsa_LookupPrivDisplayName_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_LookupPrivDisplayName_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_LookupPrivDisplayName, type);
}

static PyObject *py_lsa_LookupPrivDisplayName_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(33);
}

static PyObject *py_lsa_LookupPrivDisplayName_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupPrivDisplayName *object = (struct lsa_LookupPrivDisplayName *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 34) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupPrivDisplayName_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[33];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_LookupPrivDisplayName_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupPrivDisplayName_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_LookupPrivDisplayName_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupPrivDisplayName_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_LookupPrivDisplayName_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupPrivDisplayName *object = (struct lsa_LookupPrivDisplayName *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 34) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupPrivDisplayName_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[33];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_LookupPrivDisplayName_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupPrivDisplayName_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupPrivDisplayName_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupPrivDisplayName_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupPrivDisplayName_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupPrivDisplayName *object = (struct lsa_LookupPrivDisplayName *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 34) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupPrivDisplayName_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[33];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_LookupPrivDisplayName_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_LookupPrivDisplayName_ndr_print(py_obj, "lsa_LookupPrivDisplayName_in", NDR_IN);
}

static PyObject *py_lsa_LookupPrivDisplayName_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_LookupPrivDisplayName_ndr_print(py_obj, "lsa_LookupPrivDisplayName_out", NDR_OUT);
}

static PyMethodDef py_lsa_LookupPrivDisplayName_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_LookupPrivDisplayName_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.LookupPrivDisplayName.opnum() -> 33 (0x21) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_LookupPrivDisplayName_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_LookupPrivDisplayName_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_LookupPrivDisplayName_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_LookupPrivDisplayName_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_LookupPrivDisplayName_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_LookupPrivDisplayName_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_LookupPrivDisplayName_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.LookupPrivDisplayName",
	.tp_getset = py_lsa_LookupPrivDisplayName_getsetters,
	.tp_methods = py_lsa_LookupPrivDisplayName_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_LookupPrivDisplayName_new,
};

static bool pack_py_lsa_LookupPrivDisplayName_args_in(PyObject *args, PyObject *kwargs, struct lsa_LookupPrivDisplayName *r)
{
	PyObject *py_handle;
	PyObject *py_name;
	PyObject *py_language_id;
	PyObject *py_language_id_sys;
	const char *kwnames[] = {
		"handle", "name", "language_id", "language_id_sys", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOO:lsa_LookupPrivDisplayName", discard_const_p(char *, kwnames), &py_handle, &py_name, &py_language_id, &py_language_id_sys)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_name == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.name");
		return false;
	}
	r->in.name = talloc_ptrtype(r, r->in.name);
	if (r->in.name == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_String_Type, py_name, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_name)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.name = (struct lsa_String *)pytalloc_get_ptr(py_name);
	if (py_language_id == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.language_id");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.language_id));
		if (PyLong_Check(py_language_id)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_language_id);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.language_id = test_var;
		} else if (PyInt_Check(py_language_id)) {
			long test_var;
			test_var = PyInt_AsLong(py_language_id);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.language_id = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_language_id_sys == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.language_id_sys");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.language_id_sys));
		if (PyLong_Check(py_language_id_sys)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_language_id_sys);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.language_id_sys = test_var;
		} else if (PyInt_Check(py_language_id_sys)) {
			long test_var;
			test_var = PyInt_AsLong(py_language_id_sys);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.language_id_sys = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_LookupPrivDisplayName_args_out(struct lsa_LookupPrivDisplayName *r)
{
	PyObject *result;
	PyObject *py_disp_name;
	PyObject *py_returned_language_id;
	result = PyTuple_New(2);
	if (*r->out.disp_name == NULL) {
		py_disp_name = Py_None;
		Py_INCREF(py_disp_name);
	} else {
		py_disp_name = pytalloc_reference_ex(&lsa_StringLarge_Type, *r->out.disp_name, *r->out.disp_name);
	}
	PyTuple_SetItem(result, 0, py_disp_name);
	py_returned_language_id = PyInt_FromLong((uint16_t)*r->out.returned_language_id);
	PyTuple_SetItem(result, 1, py_returned_language_id);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_DeleteObject_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_DeleteObject *object = (struct lsa_DeleteObject *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_DeleteObject_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DeleteObject *object = (struct lsa_DeleteObject *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_DeleteObject_out_get_handle(PyObject *obj, void *closure)
{
	struct lsa_DeleteObject *object = (struct lsa_DeleteObject *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->out.handle, object->out.handle);
	return py_handle;
}

static int py_lsa_DeleteObject_out_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DeleteObject *object = (struct lsa_DeleteObject *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.handle");
		return -1;
	}
	object->out.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.handle);
	if (object->out.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_DeleteObject_get_result(PyObject *obj, void *closure)
{
	struct lsa_DeleteObject *object = (struct lsa_DeleteObject *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_DeleteObject_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DeleteObject *object = (struct lsa_DeleteObject *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_DeleteObject_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_DeleteObject_in_get_handle,
		.set = py_lsa_DeleteObject_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "out_handle"),
		.get = py_lsa_DeleteObject_out_get_handle,
		.set = py_lsa_DeleteObject_out_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_DeleteObject_get_result,
		.set = py_lsa_DeleteObject_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_DeleteObject_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_DeleteObject, type);
}

static PyObject *py_lsa_DeleteObject_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(34);
}

static PyObject *py_lsa_DeleteObject_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_DeleteObject *object = (struct lsa_DeleteObject *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 35) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_DeleteObject_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[34];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_DeleteObject_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_DeleteObject_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_DeleteObject_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_DeleteObject_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_DeleteObject_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_DeleteObject *object = (struct lsa_DeleteObject *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 35) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_DeleteObject_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[34];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_DeleteObject_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_DeleteObject_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_DeleteObject_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_DeleteObject_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_DeleteObject_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_DeleteObject *object = (struct lsa_DeleteObject *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 35) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_DeleteObject_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[34];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_DeleteObject_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_DeleteObject_ndr_print(py_obj, "lsa_DeleteObject_in", NDR_IN);
}

static PyObject *py_lsa_DeleteObject_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_DeleteObject_ndr_print(py_obj, "lsa_DeleteObject_out", NDR_OUT);
}

static PyMethodDef py_lsa_DeleteObject_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_DeleteObject_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.DeleteObject.opnum() -> 34 (0x22) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_DeleteObject_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_DeleteObject_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_DeleteObject_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_DeleteObject_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_DeleteObject_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_DeleteObject_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_DeleteObject_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.DeleteObject",
	.tp_getset = py_lsa_DeleteObject_getsetters,
	.tp_methods = py_lsa_DeleteObject_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_DeleteObject_new,
};

static bool pack_py_lsa_DeleteObject_args_in(PyObject *args, PyObject *kwargs, struct lsa_DeleteObject *r)
{
	PyObject *py_handle;
	const char *kwnames[] = {
		"handle", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:lsa_DeleteObject", discard_const_p(char *, kwnames), &py_handle)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	return true;
}

static PyObject *unpack_py_lsa_DeleteObject_args_out(struct lsa_DeleteObject *r)
{
	PyObject *result;
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, r->out.handle, r->out.handle);
	result = py_handle;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_EnumAccountsWithUserRight_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_EnumAccountsWithUserRight *object = (struct lsa_EnumAccountsWithUserRight *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_EnumAccountsWithUserRight_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumAccountsWithUserRight *object = (struct lsa_EnumAccountsWithUserRight *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_EnumAccountsWithUserRight_in_get_name(PyObject *obj, void *closure)
{
	struct lsa_EnumAccountsWithUserRight *object = (struct lsa_EnumAccountsWithUserRight *)pytalloc_get_ptr(obj);
	PyObject *py_name;
	if (object->in.name == NULL) {
		py_name = Py_None;
		Py_INCREF(py_name);
	} else {
		py_name = pytalloc_reference_ex(&lsa_String_Type, object->in.name, object->in.name);
	}
	return py_name;
}

static int py_lsa_EnumAccountsWithUserRight_in_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumAccountsWithUserRight *object = (struct lsa_EnumAccountsWithUserRight *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.name));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.name");
		return -1;
	}
	if (value == Py_None) {
		object->in.name = NULL;
	} else {
		object->in.name = NULL;
		PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->in.name = (struct lsa_String *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_EnumAccountsWithUserRight_out_get_sids(PyObject *obj, void *closure)
{
	struct lsa_EnumAccountsWithUserRight *object = (struct lsa_EnumAccountsWithUserRight *)pytalloc_get_ptr(obj);
	PyObject *py_sids;
	py_sids = pytalloc_reference_ex(&lsa_SidArray_Type, object->out.sids, object->out.sids);
	return py_sids;
}

static int py_lsa_EnumAccountsWithUserRight_out_set_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumAccountsWithUserRight *object = (struct lsa_EnumAccountsWithUserRight *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.sids));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.sids");
		return -1;
	}
	object->out.sids = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.sids);
	if (object->out.sids == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_SidArray_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.sids = (struct lsa_SidArray *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_EnumAccountsWithUserRight_get_result(PyObject *obj, void *closure)
{
	struct lsa_EnumAccountsWithUserRight *object = (struct lsa_EnumAccountsWithUserRight *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_EnumAccountsWithUserRight_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumAccountsWithUserRight *object = (struct lsa_EnumAccountsWithUserRight *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_EnumAccountsWithUserRight_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_EnumAccountsWithUserRight_in_get_handle,
		.set = py_lsa_EnumAccountsWithUserRight_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_name"),
		.get = py_lsa_EnumAccountsWithUserRight_in_get_name,
		.set = py_lsa_EnumAccountsWithUserRight_in_set_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "out_sids"),
		.get = py_lsa_EnumAccountsWithUserRight_out_get_sids,
		.set = py_lsa_EnumAccountsWithUserRight_out_set_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_SidArray")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_EnumAccountsWithUserRight_get_result,
		.set = py_lsa_EnumAccountsWithUserRight_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_EnumAccountsWithUserRight_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_EnumAccountsWithUserRight, type);
}

static PyObject *py_lsa_EnumAccountsWithUserRight_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(35);
}

static PyObject *py_lsa_EnumAccountsWithUserRight_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumAccountsWithUserRight *object = (struct lsa_EnumAccountsWithUserRight *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 36) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumAccountsWithUserRight_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[35];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_EnumAccountsWithUserRight_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_EnumAccountsWithUserRight_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_EnumAccountsWithUserRight_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_EnumAccountsWithUserRight_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_EnumAccountsWithUserRight_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumAccountsWithUserRight *object = (struct lsa_EnumAccountsWithUserRight *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 36) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumAccountsWithUserRight_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[35];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_EnumAccountsWithUserRight_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_EnumAccountsWithUserRight_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_EnumAccountsWithUserRight_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_EnumAccountsWithUserRight_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_EnumAccountsWithUserRight_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumAccountsWithUserRight *object = (struct lsa_EnumAccountsWithUserRight *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 36) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumAccountsWithUserRight_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[35];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_EnumAccountsWithUserRight_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_EnumAccountsWithUserRight_ndr_print(py_obj, "lsa_EnumAccountsWithUserRight_in", NDR_IN);
}

static PyObject *py_lsa_EnumAccountsWithUserRight_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_EnumAccountsWithUserRight_ndr_print(py_obj, "lsa_EnumAccountsWithUserRight_out", NDR_OUT);
}

static PyMethodDef py_lsa_EnumAccountsWithUserRight_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_EnumAccountsWithUserRight_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.EnumAccountsWithUserRight.opnum() -> 35 (0x23) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_EnumAccountsWithUserRight_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_EnumAccountsWithUserRight_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_EnumAccountsWithUserRight_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_EnumAccountsWithUserRight_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_EnumAccountsWithUserRight_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_EnumAccountsWithUserRight_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_EnumAccountsWithUserRight_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.EnumAccountsWithUserRight",
	.tp_getset = py_lsa_EnumAccountsWithUserRight_getsetters,
	.tp_methods = py_lsa_EnumAccountsWithUserRight_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_EnumAccountsWithUserRight_new,
};

static bool pack_py_lsa_EnumAccountsWithUserRight_args_in(PyObject *args, PyObject *kwargs, struct lsa_EnumAccountsWithUserRight *r)
{
	PyObject *py_handle;
	PyObject *py_name;
	const char *kwnames[] = {
		"handle", "name", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:lsa_EnumAccountsWithUserRight", discard_const_p(char *, kwnames), &py_handle, &py_name)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_name == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.name");
		return false;
	}
	if (py_name == Py_None) {
		r->in.name = NULL;
	} else {
		r->in.name = NULL;
		PY_CHECK_TYPE(&lsa_String_Type, py_name, return false;);
		if (talloc_reference(r, pytalloc_get_mem_ctx(py_name)) == NULL) {
			PyErr_NoMemory();
			return false;
		}
		r->in.name = (struct lsa_String *)pytalloc_get_ptr(py_name);
	}
	return true;
}

static PyObject *unpack_py_lsa_EnumAccountsWithUserRight_args_out(struct lsa_EnumAccountsWithUserRight *r)
{
	PyObject *result;
	PyObject *py_sids;
	py_sids = pytalloc_reference_ex(&lsa_SidArray_Type, r->out.sids, r->out.sids);
	result = py_sids;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_EnumAccountRights_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_EnumAccountRights *object = (struct lsa_EnumAccountRights *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_EnumAccountRights_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumAccountRights *object = (struct lsa_EnumAccountRights *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_EnumAccountRights_in_get_sid(PyObject *obj, void *closure)
{
	struct lsa_EnumAccountRights *object = (struct lsa_EnumAccountRights *)pytalloc_get_ptr(obj);
	PyObject *py_sid;
	py_sid = pytalloc_reference_ex(dom_sid_Type, object->in.sid, object->in.sid);
	return py_sid;
}

static int py_lsa_EnumAccountRights_in_set_sid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumAccountRights *object = (struct lsa_EnumAccountRights *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.sid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sid");
		return -1;
	}
	object->in.sid = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.sid);
	if (object->in.sid == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(dom_sid_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.sid = (struct dom_sid *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_EnumAccountRights_out_get_rights(PyObject *obj, void *closure)
{
	struct lsa_EnumAccountRights *object = (struct lsa_EnumAccountRights *)pytalloc_get_ptr(obj);
	PyObject *py_rights;
	py_rights = pytalloc_reference_ex(&lsa_RightSet_Type, object->out.rights, object->out.rights);
	return py_rights;
}

static int py_lsa_EnumAccountRights_out_set_rights(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumAccountRights *object = (struct lsa_EnumAccountRights *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.rights));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.rights");
		return -1;
	}
	object->out.rights = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.rights);
	if (object->out.rights == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_RightSet_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.rights = (struct lsa_RightSet *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_EnumAccountRights_get_result(PyObject *obj, void *closure)
{
	struct lsa_EnumAccountRights *object = (struct lsa_EnumAccountRights *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_EnumAccountRights_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumAccountRights *object = (struct lsa_EnumAccountRights *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_EnumAccountRights_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_EnumAccountRights_in_get_handle,
		.set = py_lsa_EnumAccountRights_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_sid"),
		.get = py_lsa_EnumAccountRights_in_get_sid,
		.set = py_lsa_EnumAccountRights_in_set_sid,
		.doc = discard_const_p(char, "PIDL-generated element of base type dom_sid2")
	},
	{
		.name = discard_const_p(char, "out_rights"),
		.get = py_lsa_EnumAccountRights_out_get_rights,
		.set = py_lsa_EnumAccountRights_out_set_rights,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_RightSet")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_EnumAccountRights_get_result,
		.set = py_lsa_EnumAccountRights_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_EnumAccountRights_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_EnumAccountRights, type);
}

static PyObject *py_lsa_EnumAccountRights_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(36);
}

static PyObject *py_lsa_EnumAccountRights_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumAccountRights *object = (struct lsa_EnumAccountRights *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 37) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumAccountRights_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[36];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_EnumAccountRights_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_EnumAccountRights_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_EnumAccountRights_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_EnumAccountRights_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_EnumAccountRights_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumAccountRights *object = (struct lsa_EnumAccountRights *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 37) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumAccountRights_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[36];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_EnumAccountRights_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_EnumAccountRights_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_EnumAccountRights_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_EnumAccountRights_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_EnumAccountRights_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumAccountRights *object = (struct lsa_EnumAccountRights *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 37) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumAccountRights_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[36];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_EnumAccountRights_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_EnumAccountRights_ndr_print(py_obj, "lsa_EnumAccountRights_in", NDR_IN);
}

static PyObject *py_lsa_EnumAccountRights_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_EnumAccountRights_ndr_print(py_obj, "lsa_EnumAccountRights_out", NDR_OUT);
}

static PyMethodDef py_lsa_EnumAccountRights_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_EnumAccountRights_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.EnumAccountRights.opnum() -> 36 (0x24) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_EnumAccountRights_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_EnumAccountRights_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_EnumAccountRights_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_EnumAccountRights_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_EnumAccountRights_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_EnumAccountRights_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_EnumAccountRights_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.EnumAccountRights",
	.tp_getset = py_lsa_EnumAccountRights_getsetters,
	.tp_methods = py_lsa_EnumAccountRights_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_EnumAccountRights_new,
};

static bool pack_py_lsa_EnumAccountRights_args_in(PyObject *args, PyObject *kwargs, struct lsa_EnumAccountRights *r)
{
	PyObject *py_handle;
	PyObject *py_sid;
	const char *kwnames[] = {
		"handle", "sid", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:lsa_EnumAccountRights", discard_const_p(char *, kwnames), &py_handle, &py_sid)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_sid == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sid");
		return false;
	}
	r->in.sid = talloc_ptrtype(r, r->in.sid);
	if (r->in.sid == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(dom_sid_Type, py_sid, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_sid)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.sid = (struct dom_sid *)pytalloc_get_ptr(py_sid);
	return true;
}

static PyObject *unpack_py_lsa_EnumAccountRights_args_out(struct lsa_EnumAccountRights *r)
{
	PyObject *result;
	PyObject *py_rights;
	py_rights = pytalloc_reference_ex(&lsa_RightSet_Type, r->out.rights, r->out.rights);
	result = py_rights;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_AddAccountRights_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_AddAccountRights *object = (struct lsa_AddAccountRights *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_AddAccountRights_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AddAccountRights *object = (struct lsa_AddAccountRights *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_AddAccountRights_in_get_sid(PyObject *obj, void *closure)
{
	struct lsa_AddAccountRights *object = (struct lsa_AddAccountRights *)pytalloc_get_ptr(obj);
	PyObject *py_sid;
	py_sid = pytalloc_reference_ex(dom_sid_Type, object->in.sid, object->in.sid);
	return py_sid;
}

static int py_lsa_AddAccountRights_in_set_sid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AddAccountRights *object = (struct lsa_AddAccountRights *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.sid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sid");
		return -1;
	}
	object->in.sid = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.sid);
	if (object->in.sid == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(dom_sid_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.sid = (struct dom_sid *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_AddAccountRights_in_get_rights(PyObject *obj, void *closure)
{
	struct lsa_AddAccountRights *object = (struct lsa_AddAccountRights *)pytalloc_get_ptr(obj);
	PyObject *py_rights;
	py_rights = pytalloc_reference_ex(&lsa_RightSet_Type, object->in.rights, object->in.rights);
	return py_rights;
}

static int py_lsa_AddAccountRights_in_set_rights(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AddAccountRights *object = (struct lsa_AddAccountRights *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.rights));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.rights");
		return -1;
	}
	object->in.rights = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.rights);
	if (object->in.rights == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_RightSet_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.rights = (struct lsa_RightSet *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_AddAccountRights_get_result(PyObject *obj, void *closure)
{
	struct lsa_AddAccountRights *object = (struct lsa_AddAccountRights *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_AddAccountRights_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_AddAccountRights *object = (struct lsa_AddAccountRights *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_AddAccountRights_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_AddAccountRights_in_get_handle,
		.set = py_lsa_AddAccountRights_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_sid"),
		.get = py_lsa_AddAccountRights_in_get_sid,
		.set = py_lsa_AddAccountRights_in_set_sid,
		.doc = discard_const_p(char, "PIDL-generated element of base type dom_sid2")
	},
	{
		.name = discard_const_p(char, "in_rights"),
		.get = py_lsa_AddAccountRights_in_get_rights,
		.set = py_lsa_AddAccountRights_in_set_rights,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_RightSet")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_AddAccountRights_get_result,
		.set = py_lsa_AddAccountRights_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_AddAccountRights_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_AddAccountRights, type);
}

static PyObject *py_lsa_AddAccountRights_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(37);
}

static PyObject *py_lsa_AddAccountRights_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_AddAccountRights *object = (struct lsa_AddAccountRights *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 38) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_AddAccountRights_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[37];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_AddAccountRights_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_AddAccountRights_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_AddAccountRights_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_AddAccountRights_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_AddAccountRights_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_AddAccountRights *object = (struct lsa_AddAccountRights *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 38) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_AddAccountRights_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[37];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_AddAccountRights_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_AddAccountRights_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_AddAccountRights_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_AddAccountRights_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_AddAccountRights_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_AddAccountRights *object = (struct lsa_AddAccountRights *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 38) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_AddAccountRights_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[37];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_AddAccountRights_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_AddAccountRights_ndr_print(py_obj, "lsa_AddAccountRights_in", NDR_IN);
}

static PyObject *py_lsa_AddAccountRights_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_AddAccountRights_ndr_print(py_obj, "lsa_AddAccountRights_out", NDR_OUT);
}

static PyMethodDef py_lsa_AddAccountRights_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_AddAccountRights_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.AddAccountRights.opnum() -> 37 (0x25) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_AddAccountRights_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_AddAccountRights_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_AddAccountRights_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_AddAccountRights_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_AddAccountRights_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_AddAccountRights_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_AddAccountRights_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.AddAccountRights",
	.tp_getset = py_lsa_AddAccountRights_getsetters,
	.tp_methods = py_lsa_AddAccountRights_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_AddAccountRights_new,
};

static bool pack_py_lsa_AddAccountRights_args_in(PyObject *args, PyObject *kwargs, struct lsa_AddAccountRights *r)
{
	PyObject *py_handle;
	PyObject *py_sid;
	PyObject *py_rights;
	const char *kwnames[] = {
		"handle", "sid", "rights", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_AddAccountRights", discard_const_p(char *, kwnames), &py_handle, &py_sid, &py_rights)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_sid == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sid");
		return false;
	}
	r->in.sid = talloc_ptrtype(r, r->in.sid);
	if (r->in.sid == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(dom_sid_Type, py_sid, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_sid)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.sid = (struct dom_sid *)pytalloc_get_ptr(py_sid);
	if (py_rights == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.rights");
		return false;
	}
	r->in.rights = talloc_ptrtype(r, r->in.rights);
	if (r->in.rights == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_RightSet_Type, py_rights, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_rights)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.rights = (struct lsa_RightSet *)pytalloc_get_ptr(py_rights);
	return true;
}

static PyObject *unpack_py_lsa_AddAccountRights_args_out(struct lsa_AddAccountRights *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_RemoveAccountRights_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_RemoveAccountRights *object = (struct lsa_RemoveAccountRights *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_RemoveAccountRights_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RemoveAccountRights *object = (struct lsa_RemoveAccountRights *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_RemoveAccountRights_in_get_sid(PyObject *obj, void *closure)
{
	struct lsa_RemoveAccountRights *object = (struct lsa_RemoveAccountRights *)pytalloc_get_ptr(obj);
	PyObject *py_sid;
	py_sid = pytalloc_reference_ex(dom_sid_Type, object->in.sid, object->in.sid);
	return py_sid;
}

static int py_lsa_RemoveAccountRights_in_set_sid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RemoveAccountRights *object = (struct lsa_RemoveAccountRights *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.sid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sid");
		return -1;
	}
	object->in.sid = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.sid);
	if (object->in.sid == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(dom_sid_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.sid = (struct dom_sid *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_RemoveAccountRights_in_get_remove_all(PyObject *obj, void *closure)
{
	struct lsa_RemoveAccountRights *object = (struct lsa_RemoveAccountRights *)pytalloc_get_ptr(obj);
	PyObject *py_remove_all;
	py_remove_all = PyInt_FromLong((uint16_t)object->in.remove_all);
	return py_remove_all;
}

static int py_lsa_RemoveAccountRights_in_set_remove_all(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RemoveAccountRights *object = (struct lsa_RemoveAccountRights *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.remove_all");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.remove_all));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.remove_all = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.remove_all = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_RemoveAccountRights_in_get_rights(PyObject *obj, void *closure)
{
	struct lsa_RemoveAccountRights *object = (struct lsa_RemoveAccountRights *)pytalloc_get_ptr(obj);
	PyObject *py_rights;
	py_rights = pytalloc_reference_ex(&lsa_RightSet_Type, object->in.rights, object->in.rights);
	return py_rights;
}

static int py_lsa_RemoveAccountRights_in_set_rights(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RemoveAccountRights *object = (struct lsa_RemoveAccountRights *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.rights));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.rights");
		return -1;
	}
	object->in.rights = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.rights);
	if (object->in.rights == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_RightSet_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.rights = (struct lsa_RightSet *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_RemoveAccountRights_get_result(PyObject *obj, void *closure)
{
	struct lsa_RemoveAccountRights *object = (struct lsa_RemoveAccountRights *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_RemoveAccountRights_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RemoveAccountRights *object = (struct lsa_RemoveAccountRights *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_RemoveAccountRights_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_RemoveAccountRights_in_get_handle,
		.set = py_lsa_RemoveAccountRights_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_sid"),
		.get = py_lsa_RemoveAccountRights_in_get_sid,
		.set = py_lsa_RemoveAccountRights_in_set_sid,
		.doc = discard_const_p(char, "PIDL-generated element of base type dom_sid2")
	},
	{
		.name = discard_const_p(char, "in_remove_all"),
		.get = py_lsa_RemoveAccountRights_in_get_remove_all,
		.set = py_lsa_RemoveAccountRights_in_set_remove_all,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{
		.name = discard_const_p(char, "in_rights"),
		.get = py_lsa_RemoveAccountRights_in_get_rights,
		.set = py_lsa_RemoveAccountRights_in_set_rights,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_RightSet")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_RemoveAccountRights_get_result,
		.set = py_lsa_RemoveAccountRights_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_RemoveAccountRights_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_RemoveAccountRights, type);
}

static PyObject *py_lsa_RemoveAccountRights_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(38);
}

static PyObject *py_lsa_RemoveAccountRights_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_RemoveAccountRights *object = (struct lsa_RemoveAccountRights *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 39) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_RemoveAccountRights_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[38];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_RemoveAccountRights_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_RemoveAccountRights_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_RemoveAccountRights_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_RemoveAccountRights_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_RemoveAccountRights_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_RemoveAccountRights *object = (struct lsa_RemoveAccountRights *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 39) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_RemoveAccountRights_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[38];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_RemoveAccountRights_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_RemoveAccountRights_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_RemoveAccountRights_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_RemoveAccountRights_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_RemoveAccountRights_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_RemoveAccountRights *object = (struct lsa_RemoveAccountRights *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 39) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_RemoveAccountRights_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[38];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_RemoveAccountRights_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_RemoveAccountRights_ndr_print(py_obj, "lsa_RemoveAccountRights_in", NDR_IN);
}

static PyObject *py_lsa_RemoveAccountRights_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_RemoveAccountRights_ndr_print(py_obj, "lsa_RemoveAccountRights_out", NDR_OUT);
}

static PyMethodDef py_lsa_RemoveAccountRights_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_RemoveAccountRights_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.RemoveAccountRights.opnum() -> 38 (0x26) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_RemoveAccountRights_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_RemoveAccountRights_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_RemoveAccountRights_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_RemoveAccountRights_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_RemoveAccountRights_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_RemoveAccountRights_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_RemoveAccountRights_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.RemoveAccountRights",
	.tp_getset = py_lsa_RemoveAccountRights_getsetters,
	.tp_methods = py_lsa_RemoveAccountRights_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_RemoveAccountRights_new,
};

static bool pack_py_lsa_RemoveAccountRights_args_in(PyObject *args, PyObject *kwargs, struct lsa_RemoveAccountRights *r)
{
	PyObject *py_handle;
	PyObject *py_sid;
	PyObject *py_remove_all;
	PyObject *py_rights;
	const char *kwnames[] = {
		"handle", "sid", "remove_all", "rights", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOO:lsa_RemoveAccountRights", discard_const_p(char *, kwnames), &py_handle, &py_sid, &py_remove_all, &py_rights)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_sid == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sid");
		return false;
	}
	r->in.sid = talloc_ptrtype(r, r->in.sid);
	if (r->in.sid == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(dom_sid_Type, py_sid, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_sid)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.sid = (struct dom_sid *)pytalloc_get_ptr(py_sid);
	if (py_remove_all == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.remove_all");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.remove_all));
		if (PyLong_Check(py_remove_all)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_remove_all);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.remove_all = test_var;
		} else if (PyInt_Check(py_remove_all)) {
			long test_var;
			test_var = PyInt_AsLong(py_remove_all);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.remove_all = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_rights == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.rights");
		return false;
	}
	r->in.rights = talloc_ptrtype(r, r->in.rights);
	if (r->in.rights == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_RightSet_Type, py_rights, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_rights)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.rights = (struct lsa_RightSet *)pytalloc_get_ptr(py_rights);
	return true;
}

static PyObject *unpack_py_lsa_RemoveAccountRights_args_out(struct lsa_RemoveAccountRights *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_QueryTrustedDomainInfoBySid_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_QueryTrustedDomainInfoBySid *object = (struct lsa_QueryTrustedDomainInfoBySid *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_QueryTrustedDomainInfoBySid_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryTrustedDomainInfoBySid *object = (struct lsa_QueryTrustedDomainInfoBySid *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_QueryTrustedDomainInfoBySid_in_get_dom_sid(PyObject *obj, void *closure)
{
	struct lsa_QueryTrustedDomainInfoBySid *object = (struct lsa_QueryTrustedDomainInfoBySid *)pytalloc_get_ptr(obj);
	PyObject *py_dom_sid;
	py_dom_sid = pytalloc_reference_ex(dom_sid_Type, object->in.dom_sid, object->in.dom_sid);
	return py_dom_sid;
}

static int py_lsa_QueryTrustedDomainInfoBySid_in_set_dom_sid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryTrustedDomainInfoBySid *object = (struct lsa_QueryTrustedDomainInfoBySid *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.dom_sid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.dom_sid");
		return -1;
	}
	object->in.dom_sid = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.dom_sid);
	if (object->in.dom_sid == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(dom_sid_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.dom_sid = (struct dom_sid *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_QueryTrustedDomainInfoBySid_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_QueryTrustedDomainInfoBySid *object = (struct lsa_QueryTrustedDomainInfoBySid *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_QueryTrustedDomainInfoBySid_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryTrustedDomainInfoBySid *object = (struct lsa_QueryTrustedDomainInfoBySid *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_QueryTrustedDomainInfoBySid_out_get_info(PyObject *obj, void *closure)
{
	struct lsa_QueryTrustedDomainInfoBySid *object = (struct lsa_QueryTrustedDomainInfoBySid *)pytalloc_get_ptr(obj);
	PyObject *py_info;
	if (*object->out.info == NULL) {
		py_info = Py_None;
		Py_INCREF(py_info);
	} else {
		py_info = pyrpc_import_union(&lsa_TrustedDomainInfo_Type, *object->out.info, object->in.level, *object->out.info, "union lsa_TrustedDomainInfo");
		if (py_info == NULL) {
			return NULL;
		}
	}
	return py_info;
}

static int py_lsa_QueryTrustedDomainInfoBySid_out_set_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryTrustedDomainInfoBySid *object = (struct lsa_QueryTrustedDomainInfoBySid *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.info");
		return -1;
	}
	object->out.info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.info);
	if (object->out.info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.info = NULL;
	} else {
		*object->out.info = NULL;
		{
			union lsa_TrustedDomainInfo *info_switch_2;
			info_switch_2 = (union lsa_TrustedDomainInfo *)pyrpc_export_union(&lsa_TrustedDomainInfo_Type, pytalloc_get_mem_ctx(py_obj), object->in.level, value, "union lsa_TrustedDomainInfo");
			if (info_switch_2 == NULL) {
				return -1;
			}
			*object->out.info = info_switch_2;
		}
	}
	return 0;
}

static PyObject *py_lsa_QueryTrustedDomainInfoBySid_get_result(PyObject *obj, void *closure)
{
	struct lsa_QueryTrustedDomainInfoBySid *object = (struct lsa_QueryTrustedDomainInfoBySid *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_QueryTrustedDomainInfoBySid_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryTrustedDomainInfoBySid *object = (struct lsa_QueryTrustedDomainInfoBySid *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_QueryTrustedDomainInfoBySid_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_QueryTrustedDomainInfoBySid_in_get_handle,
		.set = py_lsa_QueryTrustedDomainInfoBySid_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_dom_sid"),
		.get = py_lsa_QueryTrustedDomainInfoBySid_in_get_dom_sid,
		.set = py_lsa_QueryTrustedDomainInfoBySid_in_set_dom_sid,
		.doc = discard_const_p(char, "PIDL-generated element of base type dom_sid2")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_QueryTrustedDomainInfoBySid_in_get_level,
		.set = py_lsa_QueryTrustedDomainInfoBySid_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomInfoEnum")
	},
	{
		.name = discard_const_p(char, "out_info"),
		.get = py_lsa_QueryTrustedDomainInfoBySid_out_get_info,
		.set = py_lsa_QueryTrustedDomainInfoBySid_out_set_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustedDomainInfo")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_QueryTrustedDomainInfoBySid_get_result,
		.set = py_lsa_QueryTrustedDomainInfoBySid_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_QueryTrustedDomainInfoBySid_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_QueryTrustedDomainInfoBySid, type);
}

static PyObject *py_lsa_QueryTrustedDomainInfoBySid_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(39);
}

static PyObject *py_lsa_QueryTrustedDomainInfoBySid_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryTrustedDomainInfoBySid *object = (struct lsa_QueryTrustedDomainInfoBySid *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 40) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryTrustedDomainInfoBySid_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[39];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_QueryTrustedDomainInfoBySid_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_QueryTrustedDomainInfoBySid_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_QueryTrustedDomainInfoBySid_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_QueryTrustedDomainInfoBySid_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_QueryTrustedDomainInfoBySid_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryTrustedDomainInfoBySid *object = (struct lsa_QueryTrustedDomainInfoBySid *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 40) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryTrustedDomainInfoBySid_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[39];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_QueryTrustedDomainInfoBySid_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_QueryTrustedDomainInfoBySid_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_QueryTrustedDomainInfoBySid_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_QueryTrustedDomainInfoBySid_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_QueryTrustedDomainInfoBySid_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryTrustedDomainInfoBySid *object = (struct lsa_QueryTrustedDomainInfoBySid *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 40) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryTrustedDomainInfoBySid_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[39];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_QueryTrustedDomainInfoBySid_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_QueryTrustedDomainInfoBySid_ndr_print(py_obj, "lsa_QueryTrustedDomainInfoBySid_in", NDR_IN);
}

static PyObject *py_lsa_QueryTrustedDomainInfoBySid_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_QueryTrustedDomainInfoBySid_ndr_print(py_obj, "lsa_QueryTrustedDomainInfoBySid_out", NDR_OUT);
}

static PyMethodDef py_lsa_QueryTrustedDomainInfoBySid_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_QueryTrustedDomainInfoBySid_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.QueryTrustedDomainInfoBySid.opnum() -> 39 (0x27) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_QueryTrustedDomainInfoBySid_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_QueryTrustedDomainInfoBySid_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_QueryTrustedDomainInfoBySid_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_QueryTrustedDomainInfoBySid_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_QueryTrustedDomainInfoBySid_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_QueryTrustedDomainInfoBySid_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_QueryTrustedDomainInfoBySid_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.QueryTrustedDomainInfoBySid",
	.tp_getset = py_lsa_QueryTrustedDomainInfoBySid_getsetters,
	.tp_methods = py_lsa_QueryTrustedDomainInfoBySid_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_QueryTrustedDomainInfoBySid_new,
};

static bool pack_py_lsa_QueryTrustedDomainInfoBySid_args_in(PyObject *args, PyObject *kwargs, struct lsa_QueryTrustedDomainInfoBySid *r)
{
	PyObject *py_handle;
	PyObject *py_dom_sid;
	PyObject *py_level;
	const char *kwnames[] = {
		"handle", "dom_sid", "level", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_QueryTrustedDomainInfoBySid", discard_const_p(char *, kwnames), &py_handle, &py_dom_sid, &py_level)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_dom_sid == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.dom_sid");
		return false;
	}
	r->in.dom_sid = talloc_ptrtype(r, r->in.dom_sid);
	if (r->in.dom_sid == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(dom_sid_Type, py_dom_sid, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_dom_sid)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.dom_sid = (struct dom_sid *)pytalloc_get_ptr(py_dom_sid);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_QueryTrustedDomainInfoBySid_args_out(struct lsa_QueryTrustedDomainInfoBySid *r)
{
	PyObject *result;
	PyObject *py_info;
	if (*r->out.info == NULL) {
		py_info = Py_None;
		Py_INCREF(py_info);
	} else {
		py_info = pyrpc_import_union(&lsa_TrustedDomainInfo_Type, *r->out.info, r->in.level, *r->out.info, "union lsa_TrustedDomainInfo");
		if (py_info == NULL) {
			return NULL;
		}
	}
	result = py_info;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_SetTrustedDomainInfo_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_SetTrustedDomainInfo *object = (struct lsa_SetTrustedDomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_SetTrustedDomainInfo_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetTrustedDomainInfo *object = (struct lsa_SetTrustedDomainInfo *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_SetTrustedDomainInfo_in_get_dom_sid(PyObject *obj, void *closure)
{
	struct lsa_SetTrustedDomainInfo *object = (struct lsa_SetTrustedDomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_dom_sid;
	py_dom_sid = pytalloc_reference_ex(dom_sid_Type, object->in.dom_sid, object->in.dom_sid);
	return py_dom_sid;
}

static int py_lsa_SetTrustedDomainInfo_in_set_dom_sid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetTrustedDomainInfo *object = (struct lsa_SetTrustedDomainInfo *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.dom_sid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.dom_sid");
		return -1;
	}
	object->in.dom_sid = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.dom_sid);
	if (object->in.dom_sid == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(dom_sid_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.dom_sid = (struct dom_sid *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_SetTrustedDomainInfo_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_SetTrustedDomainInfo *object = (struct lsa_SetTrustedDomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_SetTrustedDomainInfo_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetTrustedDomainInfo *object = (struct lsa_SetTrustedDomainInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_SetTrustedDomainInfo_in_get_info(PyObject *obj, void *closure)
{
	struct lsa_SetTrustedDomainInfo *object = (struct lsa_SetTrustedDomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_info;
	py_info = pyrpc_import_union(&lsa_TrustedDomainInfo_Type, object->in.info, object->in.level, object->in.info, "union lsa_TrustedDomainInfo");
	if (py_info == NULL) {
		return NULL;
	}
	return py_info;
}

static int py_lsa_SetTrustedDomainInfo_in_set_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetTrustedDomainInfo *object = (struct lsa_SetTrustedDomainInfo *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.info");
		return -1;
	}
	object->in.info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.info);
	if (object->in.info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		union lsa_TrustedDomainInfo *info_switch_1;
		info_switch_1 = (union lsa_TrustedDomainInfo *)pyrpc_export_union(&lsa_TrustedDomainInfo_Type, pytalloc_get_mem_ctx(py_obj), object->in.level, value, "union lsa_TrustedDomainInfo");
		if (info_switch_1 == NULL) {
			return -1;
		}
		object->in.info = info_switch_1;
	}
	return 0;
}

static PyObject *py_lsa_SetTrustedDomainInfo_get_result(PyObject *obj, void *closure)
{
	struct lsa_SetTrustedDomainInfo *object = (struct lsa_SetTrustedDomainInfo *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_SetTrustedDomainInfo_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetTrustedDomainInfo *object = (struct lsa_SetTrustedDomainInfo *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_SetTrustedDomainInfo_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_SetTrustedDomainInfo_in_get_handle,
		.set = py_lsa_SetTrustedDomainInfo_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_dom_sid"),
		.get = py_lsa_SetTrustedDomainInfo_in_get_dom_sid,
		.set = py_lsa_SetTrustedDomainInfo_in_set_dom_sid,
		.doc = discard_const_p(char, "PIDL-generated element of base type dom_sid2")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_SetTrustedDomainInfo_in_get_level,
		.set = py_lsa_SetTrustedDomainInfo_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomInfoEnum")
	},
	{
		.name = discard_const_p(char, "in_info"),
		.get = py_lsa_SetTrustedDomainInfo_in_get_info,
		.set = py_lsa_SetTrustedDomainInfo_in_set_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustedDomainInfo")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_SetTrustedDomainInfo_get_result,
		.set = py_lsa_SetTrustedDomainInfo_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_SetTrustedDomainInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_SetTrustedDomainInfo, type);
}

static PyObject *py_lsa_SetTrustedDomainInfo_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(40);
}

static PyObject *py_lsa_SetTrustedDomainInfo_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetTrustedDomainInfo *object = (struct lsa_SetTrustedDomainInfo *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 41) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetTrustedDomainInfo_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[40];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_SetTrustedDomainInfo_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetTrustedDomainInfo_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_SetTrustedDomainInfo_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetTrustedDomainInfo_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_SetTrustedDomainInfo_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetTrustedDomainInfo *object = (struct lsa_SetTrustedDomainInfo *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 41) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetTrustedDomainInfo_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[40];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_SetTrustedDomainInfo_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetTrustedDomainInfo_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetTrustedDomainInfo_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetTrustedDomainInfo_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetTrustedDomainInfo_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetTrustedDomainInfo *object = (struct lsa_SetTrustedDomainInfo *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 41) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetTrustedDomainInfo_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[40];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_SetTrustedDomainInfo_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_SetTrustedDomainInfo_ndr_print(py_obj, "lsa_SetTrustedDomainInfo_in", NDR_IN);
}

static PyObject *py_lsa_SetTrustedDomainInfo_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_SetTrustedDomainInfo_ndr_print(py_obj, "lsa_SetTrustedDomainInfo_out", NDR_OUT);
}

static PyMethodDef py_lsa_SetTrustedDomainInfo_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_SetTrustedDomainInfo_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.SetTrustedDomainInfo.opnum() -> 40 (0x28) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_SetTrustedDomainInfo_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_SetTrustedDomainInfo_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_SetTrustedDomainInfo_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_SetTrustedDomainInfo_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_SetTrustedDomainInfo_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_SetTrustedDomainInfo_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_SetTrustedDomainInfo_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.SetTrustedDomainInfo",
	.tp_getset = py_lsa_SetTrustedDomainInfo_getsetters,
	.tp_methods = py_lsa_SetTrustedDomainInfo_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_SetTrustedDomainInfo_new,
};

static bool pack_py_lsa_SetTrustedDomainInfo_args_in(PyObject *args, PyObject *kwargs, struct lsa_SetTrustedDomainInfo *r)
{
	PyObject *py_handle;
	PyObject *py_dom_sid;
	PyObject *py_level;
	PyObject *py_info;
	const char *kwnames[] = {
		"handle", "dom_sid", "level", "info", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOO:lsa_SetTrustedDomainInfo", discard_const_p(char *, kwnames), &py_handle, &py_dom_sid, &py_level, &py_info)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_dom_sid == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.dom_sid");
		return false;
	}
	r->in.dom_sid = talloc_ptrtype(r, r->in.dom_sid);
	if (r->in.dom_sid == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(dom_sid_Type, py_dom_sid, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_dom_sid)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.dom_sid = (struct dom_sid *)pytalloc_get_ptr(py_dom_sid);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_info == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.info");
		return false;
	}
	r->in.info = talloc_ptrtype(r, r->in.info);
	if (r->in.info == NULL) {
		PyErr_NoMemory();
		return false;
	}
	{
		union lsa_TrustedDomainInfo *info_switch_1;
		info_switch_1 = (union lsa_TrustedDomainInfo *)pyrpc_export_union(&lsa_TrustedDomainInfo_Type, r, r->in.level, py_info, "union lsa_TrustedDomainInfo");
		if (info_switch_1 == NULL) {
			return false;
		}
		r->in.info = info_switch_1;
	}
	return true;
}

static PyObject *unpack_py_lsa_SetTrustedDomainInfo_args_out(struct lsa_SetTrustedDomainInfo *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_DeleteTrustedDomain_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_DeleteTrustedDomain *object = (struct lsa_DeleteTrustedDomain *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_DeleteTrustedDomain_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DeleteTrustedDomain *object = (struct lsa_DeleteTrustedDomain *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_DeleteTrustedDomain_in_get_dom_sid(PyObject *obj, void *closure)
{
	struct lsa_DeleteTrustedDomain *object = (struct lsa_DeleteTrustedDomain *)pytalloc_get_ptr(obj);
	PyObject *py_dom_sid;
	py_dom_sid = pytalloc_reference_ex(dom_sid_Type, object->in.dom_sid, object->in.dom_sid);
	return py_dom_sid;
}

static int py_lsa_DeleteTrustedDomain_in_set_dom_sid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DeleteTrustedDomain *object = (struct lsa_DeleteTrustedDomain *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.dom_sid));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.dom_sid");
		return -1;
	}
	object->in.dom_sid = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.dom_sid);
	if (object->in.dom_sid == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(dom_sid_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.dom_sid = (struct dom_sid *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_DeleteTrustedDomain_get_result(PyObject *obj, void *closure)
{
	struct lsa_DeleteTrustedDomain *object = (struct lsa_DeleteTrustedDomain *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_DeleteTrustedDomain_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_DeleteTrustedDomain *object = (struct lsa_DeleteTrustedDomain *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_DeleteTrustedDomain_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_DeleteTrustedDomain_in_get_handle,
		.set = py_lsa_DeleteTrustedDomain_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_dom_sid"),
		.get = py_lsa_DeleteTrustedDomain_in_get_dom_sid,
		.set = py_lsa_DeleteTrustedDomain_in_set_dom_sid,
		.doc = discard_const_p(char, "PIDL-generated element of base type dom_sid2")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_DeleteTrustedDomain_get_result,
		.set = py_lsa_DeleteTrustedDomain_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_DeleteTrustedDomain_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_DeleteTrustedDomain, type);
}

static PyObject *py_lsa_DeleteTrustedDomain_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(41);
}

static PyObject *py_lsa_DeleteTrustedDomain_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_DeleteTrustedDomain *object = (struct lsa_DeleteTrustedDomain *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 42) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_DeleteTrustedDomain_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[41];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_DeleteTrustedDomain_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_DeleteTrustedDomain_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_DeleteTrustedDomain_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_DeleteTrustedDomain_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_DeleteTrustedDomain_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_DeleteTrustedDomain *object = (struct lsa_DeleteTrustedDomain *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 42) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_DeleteTrustedDomain_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[41];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_DeleteTrustedDomain_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_DeleteTrustedDomain_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_DeleteTrustedDomain_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_DeleteTrustedDomain_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_DeleteTrustedDomain_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_DeleteTrustedDomain *object = (struct lsa_DeleteTrustedDomain *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 42) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_DeleteTrustedDomain_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[41];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_DeleteTrustedDomain_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_DeleteTrustedDomain_ndr_print(py_obj, "lsa_DeleteTrustedDomain_in", NDR_IN);
}

static PyObject *py_lsa_DeleteTrustedDomain_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_DeleteTrustedDomain_ndr_print(py_obj, "lsa_DeleteTrustedDomain_out", NDR_OUT);
}

static PyMethodDef py_lsa_DeleteTrustedDomain_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_DeleteTrustedDomain_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.DeleteTrustedDomain.opnum() -> 41 (0x29) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_DeleteTrustedDomain_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_DeleteTrustedDomain_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_DeleteTrustedDomain_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_DeleteTrustedDomain_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_DeleteTrustedDomain_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_DeleteTrustedDomain_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_DeleteTrustedDomain_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.DeleteTrustedDomain",
	.tp_getset = py_lsa_DeleteTrustedDomain_getsetters,
	.tp_methods = py_lsa_DeleteTrustedDomain_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_DeleteTrustedDomain_new,
};

static bool pack_py_lsa_DeleteTrustedDomain_args_in(PyObject *args, PyObject *kwargs, struct lsa_DeleteTrustedDomain *r)
{
	PyObject *py_handle;
	PyObject *py_dom_sid;
	const char *kwnames[] = {
		"handle", "dom_sid", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:lsa_DeleteTrustedDomain", discard_const_p(char *, kwnames), &py_handle, &py_dom_sid)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_dom_sid == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.dom_sid");
		return false;
	}
	r->in.dom_sid = talloc_ptrtype(r, r->in.dom_sid);
	if (r->in.dom_sid == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(dom_sid_Type, py_dom_sid, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_dom_sid)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.dom_sid = (struct dom_sid *)pytalloc_get_ptr(py_dom_sid);
	return true;
}

static PyObject *unpack_py_lsa_DeleteTrustedDomain_args_out(struct lsa_DeleteTrustedDomain *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_StorePrivateData_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_StorePrivateData *object = (struct lsa_StorePrivateData *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_StorePrivateData_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_StorePrivateData *object = (struct lsa_StorePrivateData *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_StorePrivateData_in_get_name(PyObject *obj, void *closure)
{
	struct lsa_StorePrivateData *object = (struct lsa_StorePrivateData *)pytalloc_get_ptr(obj);
	PyObject *py_name;
	py_name = pytalloc_reference_ex(&lsa_String_Type, object->in.name, object->in.name);
	return py_name;
}

static int py_lsa_StorePrivateData_in_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_StorePrivateData *object = (struct lsa_StorePrivateData *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.name));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.name");
		return -1;
	}
	object->in.name = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.name);
	if (object->in.name == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.name = (struct lsa_String *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_StorePrivateData_in_get_val(PyObject *obj, void *closure)
{
	struct lsa_StorePrivateData *object = (struct lsa_StorePrivateData *)pytalloc_get_ptr(obj);
	PyObject *py_val;
	if (object->in.val == NULL) {
		py_val = Py_None;
		Py_INCREF(py_val);
	} else {
		py_val = pytalloc_reference_ex(&lsa_DATA_BUF_Type, object->in.val, object->in.val);
	}
	return py_val;
}

static int py_lsa_StorePrivateData_in_set_val(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_StorePrivateData *object = (struct lsa_StorePrivateData *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.val));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.val");
		return -1;
	}
	if (value == Py_None) {
		object->in.val = NULL;
	} else {
		object->in.val = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->in.val = (struct lsa_DATA_BUF *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_StorePrivateData_get_result(PyObject *obj, void *closure)
{
	struct lsa_StorePrivateData *object = (struct lsa_StorePrivateData *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_StorePrivateData_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_StorePrivateData *object = (struct lsa_StorePrivateData *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_StorePrivateData_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_StorePrivateData_in_get_handle,
		.set = py_lsa_StorePrivateData_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_name"),
		.get = py_lsa_StorePrivateData_in_get_name,
		.set = py_lsa_StorePrivateData_in_set_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "in_val"),
		.get = py_lsa_StorePrivateData_in_get_val,
		.set = py_lsa_StorePrivateData_in_set_val,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DATA_BUF")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_StorePrivateData_get_result,
		.set = py_lsa_StorePrivateData_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_StorePrivateData_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_StorePrivateData, type);
}

static PyObject *py_lsa_StorePrivateData_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(42);
}

static PyObject *py_lsa_StorePrivateData_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_StorePrivateData *object = (struct lsa_StorePrivateData *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 43) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_StorePrivateData_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[42];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_StorePrivateData_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_StorePrivateData_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_StorePrivateData_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_StorePrivateData_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_StorePrivateData_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_StorePrivateData *object = (struct lsa_StorePrivateData *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 43) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_StorePrivateData_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[42];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_StorePrivateData_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_StorePrivateData_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_StorePrivateData_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_StorePrivateData_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_StorePrivateData_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_StorePrivateData *object = (struct lsa_StorePrivateData *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 43) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_StorePrivateData_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[42];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_StorePrivateData_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_StorePrivateData_ndr_print(py_obj, "lsa_StorePrivateData_in", NDR_IN);
}

static PyObject *py_lsa_StorePrivateData_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_StorePrivateData_ndr_print(py_obj, "lsa_StorePrivateData_out", NDR_OUT);
}

static PyMethodDef py_lsa_StorePrivateData_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_StorePrivateData_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.StorePrivateData.opnum() -> 42 (0x2a) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_StorePrivateData_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_StorePrivateData_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_StorePrivateData_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_StorePrivateData_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_StorePrivateData_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_StorePrivateData_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_StorePrivateData_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.StorePrivateData",
	.tp_getset = py_lsa_StorePrivateData_getsetters,
	.tp_methods = py_lsa_StorePrivateData_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_StorePrivateData_new,
};

static bool pack_py_lsa_StorePrivateData_args_in(PyObject *args, PyObject *kwargs, struct lsa_StorePrivateData *r)
{
	PyObject *py_handle;
	PyObject *py_name;
	PyObject *py_val;
	const char *kwnames[] = {
		"handle", "name", "val", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_StorePrivateData", discard_const_p(char *, kwnames), &py_handle, &py_name, &py_val)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_name == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.name");
		return false;
	}
	r->in.name = talloc_ptrtype(r, r->in.name);
	if (r->in.name == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_String_Type, py_name, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_name)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.name = (struct lsa_String *)pytalloc_get_ptr(py_name);
	if (py_val == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.val");
		return false;
	}
	if (py_val == Py_None) {
		r->in.val = NULL;
	} else {
		r->in.val = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_Type, py_val, return false;);
		if (talloc_reference(r, pytalloc_get_mem_ctx(py_val)) == NULL) {
			PyErr_NoMemory();
			return false;
		}
		r->in.val = (struct lsa_DATA_BUF *)pytalloc_get_ptr(py_val);
	}
	return true;
}

static PyObject *unpack_py_lsa_StorePrivateData_args_out(struct lsa_StorePrivateData *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_RetrievePrivateData_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_RetrievePrivateData *object = (struct lsa_RetrievePrivateData *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_RetrievePrivateData_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RetrievePrivateData *object = (struct lsa_RetrievePrivateData *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_RetrievePrivateData_in_get_name(PyObject *obj, void *closure)
{
	struct lsa_RetrievePrivateData *object = (struct lsa_RetrievePrivateData *)pytalloc_get_ptr(obj);
	PyObject *py_name;
	py_name = pytalloc_reference_ex(&lsa_String_Type, object->in.name, object->in.name);
	return py_name;
}

static int py_lsa_RetrievePrivateData_in_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RetrievePrivateData *object = (struct lsa_RetrievePrivateData *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.name));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.name");
		return -1;
	}
	object->in.name = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.name);
	if (object->in.name == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.name = (struct lsa_String *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_RetrievePrivateData_in_get_val(PyObject *obj, void *closure)
{
	struct lsa_RetrievePrivateData *object = (struct lsa_RetrievePrivateData *)pytalloc_get_ptr(obj);
	PyObject *py_val;
	if (*object->in.val == NULL) {
		py_val = Py_None;
		Py_INCREF(py_val);
	} else {
		py_val = pytalloc_reference_ex(&lsa_DATA_BUF_Type, *object->in.val, *object->in.val);
	}
	return py_val;
}

static int py_lsa_RetrievePrivateData_in_set_val(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RetrievePrivateData *object = (struct lsa_RetrievePrivateData *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.val));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.val");
		return -1;
	}
	object->in.val = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.val);
	if (object->in.val == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->in.val = NULL;
	} else {
		*object->in.val = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		*object->in.val = (struct lsa_DATA_BUF *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_RetrievePrivateData_out_get_val(PyObject *obj, void *closure)
{
	struct lsa_RetrievePrivateData *object = (struct lsa_RetrievePrivateData *)pytalloc_get_ptr(obj);
	PyObject *py_val;
	if (*object->out.val == NULL) {
		py_val = Py_None;
		Py_INCREF(py_val);
	} else {
		py_val = pytalloc_reference_ex(&lsa_DATA_BUF_Type, *object->out.val, *object->out.val);
	}
	return py_val;
}

static int py_lsa_RetrievePrivateData_out_set_val(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RetrievePrivateData *object = (struct lsa_RetrievePrivateData *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.val));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.val");
		return -1;
	}
	object->out.val = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.val);
	if (object->out.val == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.val = NULL;
	} else {
		*object->out.val = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		*object->out.val = (struct lsa_DATA_BUF *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_RetrievePrivateData_get_result(PyObject *obj, void *closure)
{
	struct lsa_RetrievePrivateData *object = (struct lsa_RetrievePrivateData *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_RetrievePrivateData_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_RetrievePrivateData *object = (struct lsa_RetrievePrivateData *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_RetrievePrivateData_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_RetrievePrivateData_in_get_handle,
		.set = py_lsa_RetrievePrivateData_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_name"),
		.get = py_lsa_RetrievePrivateData_in_get_name,
		.set = py_lsa_RetrievePrivateData_in_set_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "in_val"),
		.get = py_lsa_RetrievePrivateData_in_get_val,
		.set = py_lsa_RetrievePrivateData_in_set_val,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DATA_BUF")
	},
	{
		.name = discard_const_p(char, "out_val"),
		.get = py_lsa_RetrievePrivateData_out_get_val,
		.set = py_lsa_RetrievePrivateData_out_set_val,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DATA_BUF")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_RetrievePrivateData_get_result,
		.set = py_lsa_RetrievePrivateData_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_RetrievePrivateData_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_RetrievePrivateData, type);
}

static PyObject *py_lsa_RetrievePrivateData_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(43);
}

static PyObject *py_lsa_RetrievePrivateData_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_RetrievePrivateData *object = (struct lsa_RetrievePrivateData *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 44) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_RetrievePrivateData_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[43];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_RetrievePrivateData_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_RetrievePrivateData_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_RetrievePrivateData_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_RetrievePrivateData_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_RetrievePrivateData_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_RetrievePrivateData *object = (struct lsa_RetrievePrivateData *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 44) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_RetrievePrivateData_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[43];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_RetrievePrivateData_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_RetrievePrivateData_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_RetrievePrivateData_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_RetrievePrivateData_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_RetrievePrivateData_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_RetrievePrivateData *object = (struct lsa_RetrievePrivateData *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 44) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_RetrievePrivateData_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[43];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_RetrievePrivateData_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_RetrievePrivateData_ndr_print(py_obj, "lsa_RetrievePrivateData_in", NDR_IN);
}

static PyObject *py_lsa_RetrievePrivateData_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_RetrievePrivateData_ndr_print(py_obj, "lsa_RetrievePrivateData_out", NDR_OUT);
}

static PyMethodDef py_lsa_RetrievePrivateData_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_RetrievePrivateData_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.RetrievePrivateData.opnum() -> 43 (0x2b) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_RetrievePrivateData_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_RetrievePrivateData_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_RetrievePrivateData_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_RetrievePrivateData_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_RetrievePrivateData_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_RetrievePrivateData_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_RetrievePrivateData_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.RetrievePrivateData",
	.tp_getset = py_lsa_RetrievePrivateData_getsetters,
	.tp_methods = py_lsa_RetrievePrivateData_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_RetrievePrivateData_new,
};

static bool pack_py_lsa_RetrievePrivateData_args_in(PyObject *args, PyObject *kwargs, struct lsa_RetrievePrivateData *r)
{
	PyObject *py_handle;
	PyObject *py_name;
	PyObject *py_val;
	const char *kwnames[] = {
		"handle", "name", "val", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_RetrievePrivateData", discard_const_p(char *, kwnames), &py_handle, &py_name, &py_val)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_name == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.name");
		return false;
	}
	r->in.name = talloc_ptrtype(r, r->in.name);
	if (r->in.name == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_String_Type, py_name, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_name)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.name = (struct lsa_String *)pytalloc_get_ptr(py_name);
	if (py_val == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.val");
		return false;
	}
	r->in.val = talloc_ptrtype(r, r->in.val);
	if (r->in.val == NULL) {
		PyErr_NoMemory();
		return false;
	}
	if (py_val == Py_None) {
		*r->in.val = NULL;
	} else {
		*r->in.val = NULL;
		PY_CHECK_TYPE(&lsa_DATA_BUF_Type, py_val, return false;);
		if (talloc_reference(r, pytalloc_get_mem_ctx(py_val)) == NULL) {
			PyErr_NoMemory();
			return false;
		}
		*r->in.val = (struct lsa_DATA_BUF *)pytalloc_get_ptr(py_val);
	}
	return true;
}

static PyObject *unpack_py_lsa_RetrievePrivateData_args_out(struct lsa_RetrievePrivateData *r)
{
	PyObject *result;
	PyObject *py_val;
	if (*r->out.val == NULL) {
		py_val = Py_None;
		Py_INCREF(py_val);
	} else {
		py_val = pytalloc_reference_ex(&lsa_DATA_BUF_Type, *r->out.val, *r->out.val);
	}
	result = py_val;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_OpenPolicy2_in_get_system_name(PyObject *obj, void *closure)
{
	struct lsa_OpenPolicy2 *object = (struct lsa_OpenPolicy2 *)pytalloc_get_ptr(obj);
	PyObject *py_system_name;
	if (object->in.system_name == NULL) {
		py_system_name = Py_None;
		Py_INCREF(py_system_name);
	} else {
		if (object->in.system_name == NULL) {
			py_system_name = Py_None;
			Py_INCREF(py_system_name);
		} else {
			py_system_name = PyUnicode_Decode(object->in.system_name, strlen(object->in.system_name), "utf-8", "ignore");
		}
	}
	return py_system_name;
}

static int py_lsa_OpenPolicy2_in_set_system_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenPolicy2 *object = (struct lsa_OpenPolicy2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.system_name");
		return -1;
	}
	if (value == Py_None) {
		object->in.system_name = NULL;
	} else {
		object->in.system_name = NULL;
		{
			const char *test_str;
			const char *talloc_str;
			PyObject *unicode = NULL;
			if (PyUnicode_Check(value)) {
				unicode = PyUnicode_AsEncodedString(value, "utf-8", "ignore");
				if (unicode == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				test_str = PyBytes_AS_STRING(unicode);
			} else if (PyBytes_Check(value)) {
				test_str = PyBytes_AS_STRING(value);
			} else {
				PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
				return -1;
			}
			talloc_str = talloc_strdup(pytalloc_get_mem_ctx(py_obj), test_str);
			if (unicode != NULL) {
				Py_DECREF(unicode);
			}
			if (talloc_str == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->in.system_name = talloc_str;
		}
	}
	return 0;
}

static PyObject *py_lsa_OpenPolicy2_in_get_attr(PyObject *obj, void *closure)
{
	struct lsa_OpenPolicy2 *object = (struct lsa_OpenPolicy2 *)pytalloc_get_ptr(obj);
	PyObject *py_attr;
	py_attr = pytalloc_reference_ex(&lsa_ObjectAttribute_Type, object->in.attr, object->in.attr);
	return py_attr;
}

static int py_lsa_OpenPolicy2_in_set_attr(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenPolicy2 *object = (struct lsa_OpenPolicy2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.attr));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.attr");
		return -1;
	}
	object->in.attr = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.attr);
	if (object->in.attr == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_ObjectAttribute_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.attr = (struct lsa_ObjectAttribute *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_OpenPolicy2_in_get_access_mask(PyObject *obj, void *closure)
{
	struct lsa_OpenPolicy2 *object = (struct lsa_OpenPolicy2 *)pytalloc_get_ptr(obj);
	PyObject *py_access_mask;
	py_access_mask = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.access_mask);
	return py_access_mask;
}

static int py_lsa_OpenPolicy2_in_set_access_mask(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenPolicy2 *object = (struct lsa_OpenPolicy2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.access_mask");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.access_mask));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_OpenPolicy2_out_get_handle(PyObject *obj, void *closure)
{
	struct lsa_OpenPolicy2 *object = (struct lsa_OpenPolicy2 *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->out.handle, object->out.handle);
	return py_handle;
}

static int py_lsa_OpenPolicy2_out_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenPolicy2 *object = (struct lsa_OpenPolicy2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.handle");
		return -1;
	}
	object->out.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.handle);
	if (object->out.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_OpenPolicy2_get_result(PyObject *obj, void *closure)
{
	struct lsa_OpenPolicy2 *object = (struct lsa_OpenPolicy2 *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_OpenPolicy2_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenPolicy2 *object = (struct lsa_OpenPolicy2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_OpenPolicy2_getsetters[] = {
	{
		.name = discard_const_p(char, "in_system_name"),
		.get = py_lsa_OpenPolicy2_in_get_system_name,
		.set = py_lsa_OpenPolicy2_in_set_system_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "in_attr"),
		.get = py_lsa_OpenPolicy2_in_get_attr,
		.set = py_lsa_OpenPolicy2_in_set_attr,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ObjectAttribute")
	},
	{
		.name = discard_const_p(char, "in_access_mask"),
		.get = py_lsa_OpenPolicy2_in_get_access_mask,
		.set = py_lsa_OpenPolicy2_in_set_access_mask,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_PolicyAccessMask")
	},
	{
		.name = discard_const_p(char, "out_handle"),
		.get = py_lsa_OpenPolicy2_out_get_handle,
		.set = py_lsa_OpenPolicy2_out_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_OpenPolicy2_get_result,
		.set = py_lsa_OpenPolicy2_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_OpenPolicy2_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_OpenPolicy2, type);
}

static PyObject *py_lsa_OpenPolicy2_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(44);
}

static PyObject *py_lsa_OpenPolicy2_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenPolicy2 *object = (struct lsa_OpenPolicy2 *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 45) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenPolicy2_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[44];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_OpenPolicy2_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_OpenPolicy2_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_OpenPolicy2_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_OpenPolicy2_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_OpenPolicy2_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenPolicy2 *object = (struct lsa_OpenPolicy2 *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 45) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenPolicy2_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[44];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_OpenPolicy2_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_OpenPolicy2_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_OpenPolicy2_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_OpenPolicy2_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_OpenPolicy2_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenPolicy2 *object = (struct lsa_OpenPolicy2 *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 45) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenPolicy2_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[44];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_OpenPolicy2_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_OpenPolicy2_ndr_print(py_obj, "lsa_OpenPolicy2_in", NDR_IN);
}

static PyObject *py_lsa_OpenPolicy2_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_OpenPolicy2_ndr_print(py_obj, "lsa_OpenPolicy2_out", NDR_OUT);
}

static PyMethodDef py_lsa_OpenPolicy2_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_OpenPolicy2_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.OpenPolicy2.opnum() -> 44 (0x2c) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_OpenPolicy2_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_OpenPolicy2_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_OpenPolicy2_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_OpenPolicy2_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_OpenPolicy2_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_OpenPolicy2_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_OpenPolicy2_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.OpenPolicy2",
	.tp_getset = py_lsa_OpenPolicy2_getsetters,
	.tp_methods = py_lsa_OpenPolicy2_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_OpenPolicy2_new,
};

static bool pack_py_lsa_OpenPolicy2_args_in(PyObject *args, PyObject *kwargs, struct lsa_OpenPolicy2 *r)
{
	PyObject *py_system_name;
	PyObject *py_attr;
	PyObject *py_access_mask;
	const char *kwnames[] = {
		"system_name", "attr", "access_mask", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_OpenPolicy2", discard_const_p(char *, kwnames), &py_system_name, &py_attr, &py_access_mask)) {
		return false;
	}

	if (py_system_name == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.system_name");
		return false;
	}
	if (py_system_name == Py_None) {
		r->in.system_name = NULL;
	} else {
		r->in.system_name = NULL;
		{
			const char *test_str;
			const char *talloc_str;
			PyObject *unicode = NULL;
			if (PyUnicode_Check(py_system_name)) {
				unicode = PyUnicode_AsEncodedString(py_system_name, "utf-8", "ignore");
				if (unicode == NULL) {
					PyErr_NoMemory();
					return false;
				}
				test_str = PyBytes_AS_STRING(unicode);
			} else if (PyBytes_Check(py_system_name)) {
				test_str = PyBytes_AS_STRING(py_system_name);
			} else {
				PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(py_system_name)->tp_name);
				return false;
			}
			talloc_str = talloc_strdup(r, test_str);
			if (unicode != NULL) {
				Py_DECREF(unicode);
			}
			if (talloc_str == NULL) {
				PyErr_NoMemory();
				return false;
			}
			r->in.system_name = talloc_str;
		}
	}
	if (py_attr == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.attr");
		return false;
	}
	r->in.attr = talloc_ptrtype(r, r->in.attr);
	if (r->in.attr == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_ObjectAttribute_Type, py_attr, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_attr)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.attr = (struct lsa_ObjectAttribute *)pytalloc_get_ptr(py_attr);
	if (py_access_mask == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.access_mask");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.access_mask));
		if (PyLong_Check(py_access_mask)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_access_mask);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else if (PyInt_Check(py_access_mask)) {
			long test_var;
			test_var = PyInt_AsLong(py_access_mask);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_OpenPolicy2_args_out(struct lsa_OpenPolicy2 *r)
{
	PyObject *result;
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, r->out.handle, r->out.handle);
	result = py_handle;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_GetUserName_in_get_system_name(PyObject *obj, void *closure)
{
	struct lsa_GetUserName *object = (struct lsa_GetUserName *)pytalloc_get_ptr(obj);
	PyObject *py_system_name;
	if (object->in.system_name == NULL) {
		py_system_name = Py_None;
		Py_INCREF(py_system_name);
	} else {
		if (object->in.system_name == NULL) {
			py_system_name = Py_None;
			Py_INCREF(py_system_name);
		} else {
			py_system_name = PyUnicode_Decode(object->in.system_name, strlen(object->in.system_name), "utf-8", "ignore");
		}
	}
	return py_system_name;
}

static int py_lsa_GetUserName_in_set_system_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_GetUserName *object = (struct lsa_GetUserName *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.system_name");
		return -1;
	}
	if (value == Py_None) {
		object->in.system_name = NULL;
	} else {
		object->in.system_name = NULL;
		{
			const char *test_str;
			const char *talloc_str;
			PyObject *unicode = NULL;
			if (PyUnicode_Check(value)) {
				unicode = PyUnicode_AsEncodedString(value, "utf-8", "ignore");
				if (unicode == NULL) {
					PyErr_NoMemory();
					return -1;
				}
				test_str = PyBytes_AS_STRING(unicode);
			} else if (PyBytes_Check(value)) {
				test_str = PyBytes_AS_STRING(value);
			} else {
				PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
				return -1;
			}
			talloc_str = talloc_strdup(pytalloc_get_mem_ctx(py_obj), test_str);
			if (unicode != NULL) {
				Py_DECREF(unicode);
			}
			if (talloc_str == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->in.system_name = talloc_str;
		}
	}
	return 0;
}

static PyObject *py_lsa_GetUserName_in_get_account_name(PyObject *obj, void *closure)
{
	struct lsa_GetUserName *object = (struct lsa_GetUserName *)pytalloc_get_ptr(obj);
	PyObject *py_account_name;
	if (*object->in.account_name == NULL) {
		py_account_name = Py_None;
		Py_INCREF(py_account_name);
	} else {
		py_account_name = pytalloc_reference_ex(&lsa_String_Type, *object->in.account_name, *object->in.account_name);
	}
	return py_account_name;
}

static int py_lsa_GetUserName_in_set_account_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_GetUserName *object = (struct lsa_GetUserName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.account_name));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.account_name");
		return -1;
	}
	object->in.account_name = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.account_name);
	if (object->in.account_name == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->in.account_name = NULL;
	} else {
		*object->in.account_name = NULL;
		PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		*object->in.account_name = (struct lsa_String *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_GetUserName_out_get_account_name(PyObject *obj, void *closure)
{
	struct lsa_GetUserName *object = (struct lsa_GetUserName *)pytalloc_get_ptr(obj);
	PyObject *py_account_name;
	if (*object->out.account_name == NULL) {
		py_account_name = Py_None;
		Py_INCREF(py_account_name);
	} else {
		py_account_name = pytalloc_reference_ex(&lsa_String_Type, *object->out.account_name, *object->out.account_name);
	}
	return py_account_name;
}

static int py_lsa_GetUserName_out_set_account_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_GetUserName *object = (struct lsa_GetUserName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.account_name));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.account_name");
		return -1;
	}
	object->out.account_name = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.account_name);
	if (object->out.account_name == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.account_name = NULL;
	} else {
		*object->out.account_name = NULL;
		PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		*object->out.account_name = (struct lsa_String *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_GetUserName_in_get_authority_name(PyObject *obj, void *closure)
{
	struct lsa_GetUserName *object = (struct lsa_GetUserName *)pytalloc_get_ptr(obj);
	PyObject *py_authority_name;
	if (object->in.authority_name == NULL) {
		py_authority_name = Py_None;
		Py_INCREF(py_authority_name);
	} else {
		if (*object->in.authority_name == NULL) {
			py_authority_name = Py_None;
			Py_INCREF(py_authority_name);
		} else {
			py_authority_name = pytalloc_reference_ex(&lsa_String_Type, *object->in.authority_name, *object->in.authority_name);
		}
	}
	return py_authority_name;
}

static int py_lsa_GetUserName_in_set_authority_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_GetUserName *object = (struct lsa_GetUserName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.authority_name));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.authority_name");
		return -1;
	}
	if (value == Py_None) {
		object->in.authority_name = NULL;
	} else {
		object->in.authority_name = NULL;
		if (value == Py_None) {
			*object->in.authority_name = NULL;
		} else {
			*object->in.authority_name = NULL;
			PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
			if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			*object->in.authority_name = (struct lsa_String *)pytalloc_get_ptr(value);
		}
	}
	return 0;
}

static PyObject *py_lsa_GetUserName_out_get_authority_name(PyObject *obj, void *closure)
{
	struct lsa_GetUserName *object = (struct lsa_GetUserName *)pytalloc_get_ptr(obj);
	PyObject *py_authority_name;
	if (object->out.authority_name == NULL) {
		py_authority_name = Py_None;
		Py_INCREF(py_authority_name);
	} else {
		if (*object->out.authority_name == NULL) {
			py_authority_name = Py_None;
			Py_INCREF(py_authority_name);
		} else {
			py_authority_name = pytalloc_reference_ex(&lsa_String_Type, *object->out.authority_name, *object->out.authority_name);
		}
	}
	return py_authority_name;
}

static int py_lsa_GetUserName_out_set_authority_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_GetUserName *object = (struct lsa_GetUserName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.authority_name));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.authority_name");
		return -1;
	}
	if (value == Py_None) {
		object->out.authority_name = NULL;
	} else {
		object->out.authority_name = NULL;
		if (value == Py_None) {
			*object->out.authority_name = NULL;
		} else {
			*object->out.authority_name = NULL;
			PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
			if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			*object->out.authority_name = (struct lsa_String *)pytalloc_get_ptr(value);
		}
	}
	return 0;
}

static PyObject *py_lsa_GetUserName_get_result(PyObject *obj, void *closure)
{
	struct lsa_GetUserName *object = (struct lsa_GetUserName *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_GetUserName_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_GetUserName *object = (struct lsa_GetUserName *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_GetUserName_getsetters[] = {
	{
		.name = discard_const_p(char, "in_system_name"),
		.get = py_lsa_GetUserName_in_get_system_name,
		.set = py_lsa_GetUserName_in_set_system_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "in_account_name"),
		.get = py_lsa_GetUserName_in_get_account_name,
		.set = py_lsa_GetUserName_in_set_account_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "out_account_name"),
		.get = py_lsa_GetUserName_out_get_account_name,
		.set = py_lsa_GetUserName_out_set_account_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "in_authority_name"),
		.get = py_lsa_GetUserName_in_get_authority_name,
		.set = py_lsa_GetUserName_in_set_authority_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "out_authority_name"),
		.get = py_lsa_GetUserName_out_get_authority_name,
		.set = py_lsa_GetUserName_out_set_authority_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_GetUserName_get_result,
		.set = py_lsa_GetUserName_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_GetUserName_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_GetUserName, type);
}

static PyObject *py_lsa_GetUserName_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(45);
}

static PyObject *py_lsa_GetUserName_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_GetUserName *object = (struct lsa_GetUserName *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 46) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_GetUserName_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[45];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_GetUserName_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_GetUserName_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_GetUserName_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_GetUserName_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_GetUserName_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_GetUserName *object = (struct lsa_GetUserName *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 46) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_GetUserName_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[45];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_GetUserName_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_GetUserName_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_GetUserName_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_GetUserName_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_GetUserName_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_GetUserName *object = (struct lsa_GetUserName *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 46) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_GetUserName_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[45];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_GetUserName_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_GetUserName_ndr_print(py_obj, "lsa_GetUserName_in", NDR_IN);
}

static PyObject *py_lsa_GetUserName_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_GetUserName_ndr_print(py_obj, "lsa_GetUserName_out", NDR_OUT);
}

static PyMethodDef py_lsa_GetUserName_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_GetUserName_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.GetUserName.opnum() -> 45 (0x2d) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_GetUserName_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_GetUserName_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_GetUserName_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_GetUserName_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_GetUserName_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_GetUserName_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_GetUserName_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.GetUserName",
	.tp_getset = py_lsa_GetUserName_getsetters,
	.tp_methods = py_lsa_GetUserName_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_GetUserName_new,
};

static bool pack_py_lsa_GetUserName_args_in(PyObject *args, PyObject *kwargs, struct lsa_GetUserName *r)
{
	PyObject *py_system_name;
	PyObject *py_account_name;
	PyObject *py_authority_name;
	const char *kwnames[] = {
		"system_name", "account_name", "authority_name", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_GetUserName", discard_const_p(char *, kwnames), &py_system_name, &py_account_name, &py_authority_name)) {
		return false;
	}

	if (py_system_name == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.system_name");
		return false;
	}
	if (py_system_name == Py_None) {
		r->in.system_name = NULL;
	} else {
		r->in.system_name = NULL;
		{
			const char *test_str;
			const char *talloc_str;
			PyObject *unicode = NULL;
			if (PyUnicode_Check(py_system_name)) {
				unicode = PyUnicode_AsEncodedString(py_system_name, "utf-8", "ignore");
				if (unicode == NULL) {
					PyErr_NoMemory();
					return false;
				}
				test_str = PyBytes_AS_STRING(unicode);
			} else if (PyBytes_Check(py_system_name)) {
				test_str = PyBytes_AS_STRING(py_system_name);
			} else {
				PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(py_system_name)->tp_name);
				return false;
			}
			talloc_str = talloc_strdup(r, test_str);
			if (unicode != NULL) {
				Py_DECREF(unicode);
			}
			if (talloc_str == NULL) {
				PyErr_NoMemory();
				return false;
			}
			r->in.system_name = talloc_str;
		}
	}
	if (py_account_name == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.account_name");
		return false;
	}
	r->in.account_name = talloc_ptrtype(r, r->in.account_name);
	if (r->in.account_name == NULL) {
		PyErr_NoMemory();
		return false;
	}
	if (py_account_name == Py_None) {
		*r->in.account_name = NULL;
	} else {
		*r->in.account_name = NULL;
		PY_CHECK_TYPE(&lsa_String_Type, py_account_name, return false;);
		if (talloc_reference(r, pytalloc_get_mem_ctx(py_account_name)) == NULL) {
			PyErr_NoMemory();
			return false;
		}
		*r->in.account_name = (struct lsa_String *)pytalloc_get_ptr(py_account_name);
	}
	if (py_authority_name == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.authority_name");
		return false;
	}
	if (py_authority_name == Py_None) {
		r->in.authority_name = NULL;
	} else {
		r->in.authority_name = NULL;
		if (py_authority_name == Py_None) {
			*r->in.authority_name = NULL;
		} else {
			*r->in.authority_name = NULL;
			PY_CHECK_TYPE(&lsa_String_Type, py_authority_name, return false;);
			if (talloc_reference(r, pytalloc_get_mem_ctx(py_authority_name)) == NULL) {
				PyErr_NoMemory();
				return false;
			}
			*r->in.authority_name = (struct lsa_String *)pytalloc_get_ptr(py_authority_name);
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_GetUserName_args_out(struct lsa_GetUserName *r)
{
	PyObject *result;
	PyObject *py_account_name;
	PyObject *py_authority_name;
	result = PyTuple_New(2);
	if (*r->out.account_name == NULL) {
		py_account_name = Py_None;
		Py_INCREF(py_account_name);
	} else {
		py_account_name = pytalloc_reference_ex(&lsa_String_Type, *r->out.account_name, *r->out.account_name);
	}
	PyTuple_SetItem(result, 0, py_account_name);
	if (r->out.authority_name == NULL) {
		py_authority_name = Py_None;
		Py_INCREF(py_authority_name);
	} else {
		if (*r->out.authority_name == NULL) {
			py_authority_name = Py_None;
			Py_INCREF(py_authority_name);
		} else {
			py_authority_name = pytalloc_reference_ex(&lsa_String_Type, *r->out.authority_name, *r->out.authority_name);
		}
	}
	PyTuple_SetItem(result, 1, py_authority_name);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_QueryInfoPolicy2_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_QueryInfoPolicy2 *object = (struct lsa_QueryInfoPolicy2 *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_QueryInfoPolicy2_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryInfoPolicy2 *object = (struct lsa_QueryInfoPolicy2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_QueryInfoPolicy2_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_QueryInfoPolicy2 *object = (struct lsa_QueryInfoPolicy2 *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_QueryInfoPolicy2_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryInfoPolicy2 *object = (struct lsa_QueryInfoPolicy2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_QueryInfoPolicy2_out_get_info(PyObject *obj, void *closure)
{
	struct lsa_QueryInfoPolicy2 *object = (struct lsa_QueryInfoPolicy2 *)pytalloc_get_ptr(obj);
	PyObject *py_info;
	if (*object->out.info == NULL) {
		py_info = Py_None;
		Py_INCREF(py_info);
	} else {
		py_info = pyrpc_import_union(&lsa_PolicyInformation_Type, *object->out.info, object->in.level, *object->out.info, "union lsa_PolicyInformation");
		if (py_info == NULL) {
			return NULL;
		}
	}
	return py_info;
}

static int py_lsa_QueryInfoPolicy2_out_set_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryInfoPolicy2 *object = (struct lsa_QueryInfoPolicy2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.info");
		return -1;
	}
	object->out.info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.info);
	if (object->out.info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.info = NULL;
	} else {
		*object->out.info = NULL;
		{
			union lsa_PolicyInformation *info_switch_2;
			info_switch_2 = (union lsa_PolicyInformation *)pyrpc_export_union(&lsa_PolicyInformation_Type, pytalloc_get_mem_ctx(py_obj), object->in.level, value, "union lsa_PolicyInformation");
			if (info_switch_2 == NULL) {
				return -1;
			}
			*object->out.info = info_switch_2;
		}
	}
	return 0;
}

static PyObject *py_lsa_QueryInfoPolicy2_get_result(PyObject *obj, void *closure)
{
	struct lsa_QueryInfoPolicy2 *object = (struct lsa_QueryInfoPolicy2 *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_QueryInfoPolicy2_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryInfoPolicy2 *object = (struct lsa_QueryInfoPolicy2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_QueryInfoPolicy2_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_QueryInfoPolicy2_in_get_handle,
		.set = py_lsa_QueryInfoPolicy2_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_QueryInfoPolicy2_in_get_level,
		.set = py_lsa_QueryInfoPolicy2_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_PolicyInfo")
	},
	{
		.name = discard_const_p(char, "out_info"),
		.get = py_lsa_QueryInfoPolicy2_out_get_info,
		.set = py_lsa_QueryInfoPolicy2_out_set_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_PolicyInformation")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_QueryInfoPolicy2_get_result,
		.set = py_lsa_QueryInfoPolicy2_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_QueryInfoPolicy2_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_QueryInfoPolicy2, type);
}

static PyObject *py_lsa_QueryInfoPolicy2_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(46);
}

static PyObject *py_lsa_QueryInfoPolicy2_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryInfoPolicy2 *object = (struct lsa_QueryInfoPolicy2 *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 47) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryInfoPolicy2_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[46];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_QueryInfoPolicy2_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_QueryInfoPolicy2_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_QueryInfoPolicy2_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_QueryInfoPolicy2_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_QueryInfoPolicy2_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryInfoPolicy2 *object = (struct lsa_QueryInfoPolicy2 *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 47) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryInfoPolicy2_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[46];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_QueryInfoPolicy2_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_QueryInfoPolicy2_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_QueryInfoPolicy2_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_QueryInfoPolicy2_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_QueryInfoPolicy2_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryInfoPolicy2 *object = (struct lsa_QueryInfoPolicy2 *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 47) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryInfoPolicy2_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[46];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_QueryInfoPolicy2_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_QueryInfoPolicy2_ndr_print(py_obj, "lsa_QueryInfoPolicy2_in", NDR_IN);
}

static PyObject *py_lsa_QueryInfoPolicy2_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_QueryInfoPolicy2_ndr_print(py_obj, "lsa_QueryInfoPolicy2_out", NDR_OUT);
}

static PyMethodDef py_lsa_QueryInfoPolicy2_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_QueryInfoPolicy2_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.QueryInfoPolicy2.opnum() -> 46 (0x2e) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_QueryInfoPolicy2_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_QueryInfoPolicy2_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_QueryInfoPolicy2_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_QueryInfoPolicy2_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_QueryInfoPolicy2_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_QueryInfoPolicy2_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_QueryInfoPolicy2_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.QueryInfoPolicy2",
	.tp_getset = py_lsa_QueryInfoPolicy2_getsetters,
	.tp_methods = py_lsa_QueryInfoPolicy2_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_QueryInfoPolicy2_new,
};

static bool pack_py_lsa_QueryInfoPolicy2_args_in(PyObject *args, PyObject *kwargs, struct lsa_QueryInfoPolicy2 *r)
{
	PyObject *py_handle;
	PyObject *py_level;
	const char *kwnames[] = {
		"handle", "level", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:lsa_QueryInfoPolicy2", discard_const_p(char *, kwnames), &py_handle, &py_level)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_QueryInfoPolicy2_args_out(struct lsa_QueryInfoPolicy2 *r)
{
	PyObject *result;
	PyObject *py_info;
	if (*r->out.info == NULL) {
		py_info = Py_None;
		Py_INCREF(py_info);
	} else {
		py_info = pyrpc_import_union(&lsa_PolicyInformation_Type, *r->out.info, r->in.level, *r->out.info, "union lsa_PolicyInformation");
		if (py_info == NULL) {
			return NULL;
		}
	}
	result = py_info;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_SetInfoPolicy2_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_SetInfoPolicy2 *object = (struct lsa_SetInfoPolicy2 *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_SetInfoPolicy2_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetInfoPolicy2 *object = (struct lsa_SetInfoPolicy2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_SetInfoPolicy2_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_SetInfoPolicy2 *object = (struct lsa_SetInfoPolicy2 *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_SetInfoPolicy2_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetInfoPolicy2 *object = (struct lsa_SetInfoPolicy2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_SetInfoPolicy2_in_get_info(PyObject *obj, void *closure)
{
	struct lsa_SetInfoPolicy2 *object = (struct lsa_SetInfoPolicy2 *)pytalloc_get_ptr(obj);
	PyObject *py_info;
	py_info = pyrpc_import_union(&lsa_PolicyInformation_Type, object->in.info, object->in.level, object->in.info, "union lsa_PolicyInformation");
	if (py_info == NULL) {
		return NULL;
	}
	return py_info;
}

static int py_lsa_SetInfoPolicy2_in_set_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetInfoPolicy2 *object = (struct lsa_SetInfoPolicy2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.info");
		return -1;
	}
	object->in.info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.info);
	if (object->in.info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		union lsa_PolicyInformation *info_switch_1;
		info_switch_1 = (union lsa_PolicyInformation *)pyrpc_export_union(&lsa_PolicyInformation_Type, pytalloc_get_mem_ctx(py_obj), object->in.level, value, "union lsa_PolicyInformation");
		if (info_switch_1 == NULL) {
			return -1;
		}
		object->in.info = info_switch_1;
	}
	return 0;
}

static PyObject *py_lsa_SetInfoPolicy2_get_result(PyObject *obj, void *closure)
{
	struct lsa_SetInfoPolicy2 *object = (struct lsa_SetInfoPolicy2 *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_SetInfoPolicy2_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetInfoPolicy2 *object = (struct lsa_SetInfoPolicy2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_SetInfoPolicy2_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_SetInfoPolicy2_in_get_handle,
		.set = py_lsa_SetInfoPolicy2_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_SetInfoPolicy2_in_get_level,
		.set = py_lsa_SetInfoPolicy2_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_PolicyInfo")
	},
	{
		.name = discard_const_p(char, "in_info"),
		.get = py_lsa_SetInfoPolicy2_in_get_info,
		.set = py_lsa_SetInfoPolicy2_in_set_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_PolicyInformation")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_SetInfoPolicy2_get_result,
		.set = py_lsa_SetInfoPolicy2_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_SetInfoPolicy2_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_SetInfoPolicy2, type);
}

static PyObject *py_lsa_SetInfoPolicy2_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(47);
}

static PyObject *py_lsa_SetInfoPolicy2_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetInfoPolicy2 *object = (struct lsa_SetInfoPolicy2 *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 48) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetInfoPolicy2_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[47];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_SetInfoPolicy2_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetInfoPolicy2_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_SetInfoPolicy2_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetInfoPolicy2_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_SetInfoPolicy2_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetInfoPolicy2 *object = (struct lsa_SetInfoPolicy2 *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 48) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetInfoPolicy2_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[47];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_SetInfoPolicy2_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetInfoPolicy2_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetInfoPolicy2_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetInfoPolicy2_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetInfoPolicy2_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetInfoPolicy2 *object = (struct lsa_SetInfoPolicy2 *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 48) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetInfoPolicy2_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[47];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_SetInfoPolicy2_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_SetInfoPolicy2_ndr_print(py_obj, "lsa_SetInfoPolicy2_in", NDR_IN);
}

static PyObject *py_lsa_SetInfoPolicy2_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_SetInfoPolicy2_ndr_print(py_obj, "lsa_SetInfoPolicy2_out", NDR_OUT);
}

static PyMethodDef py_lsa_SetInfoPolicy2_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_SetInfoPolicy2_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.SetInfoPolicy2.opnum() -> 47 (0x2f) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_SetInfoPolicy2_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_SetInfoPolicy2_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_SetInfoPolicy2_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_SetInfoPolicy2_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_SetInfoPolicy2_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_SetInfoPolicy2_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_SetInfoPolicy2_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.SetInfoPolicy2",
	.tp_getset = py_lsa_SetInfoPolicy2_getsetters,
	.tp_methods = py_lsa_SetInfoPolicy2_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_SetInfoPolicy2_new,
};

static bool pack_py_lsa_SetInfoPolicy2_args_in(PyObject *args, PyObject *kwargs, struct lsa_SetInfoPolicy2 *r)
{
	PyObject *py_handle;
	PyObject *py_level;
	PyObject *py_info;
	const char *kwnames[] = {
		"handle", "level", "info", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_SetInfoPolicy2", discard_const_p(char *, kwnames), &py_handle, &py_level, &py_info)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_info == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.info");
		return false;
	}
	r->in.info = talloc_ptrtype(r, r->in.info);
	if (r->in.info == NULL) {
		PyErr_NoMemory();
		return false;
	}
	{
		union lsa_PolicyInformation *info_switch_1;
		info_switch_1 = (union lsa_PolicyInformation *)pyrpc_export_union(&lsa_PolicyInformation_Type, r, r->in.level, py_info, "union lsa_PolicyInformation");
		if (info_switch_1 == NULL) {
			return false;
		}
		r->in.info = info_switch_1;
	}
	return true;
}

static PyObject *unpack_py_lsa_SetInfoPolicy2_args_out(struct lsa_SetInfoPolicy2 *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_QueryTrustedDomainInfoByName_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_QueryTrustedDomainInfoByName *object = (struct lsa_QueryTrustedDomainInfoByName *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_QueryTrustedDomainInfoByName_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryTrustedDomainInfoByName *object = (struct lsa_QueryTrustedDomainInfoByName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_QueryTrustedDomainInfoByName_in_get_trusted_domain(PyObject *obj, void *closure)
{
	struct lsa_QueryTrustedDomainInfoByName *object = (struct lsa_QueryTrustedDomainInfoByName *)pytalloc_get_ptr(obj);
	PyObject *py_trusted_domain;
	py_trusted_domain = pytalloc_reference_ex(&lsa_String_Type, object->in.trusted_domain, object->in.trusted_domain);
	return py_trusted_domain;
}

static int py_lsa_QueryTrustedDomainInfoByName_in_set_trusted_domain(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryTrustedDomainInfoByName *object = (struct lsa_QueryTrustedDomainInfoByName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.trusted_domain));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.trusted_domain");
		return -1;
	}
	object->in.trusted_domain = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.trusted_domain);
	if (object->in.trusted_domain == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.trusted_domain = (struct lsa_String *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_QueryTrustedDomainInfoByName_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_QueryTrustedDomainInfoByName *object = (struct lsa_QueryTrustedDomainInfoByName *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_QueryTrustedDomainInfoByName_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryTrustedDomainInfoByName *object = (struct lsa_QueryTrustedDomainInfoByName *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_QueryTrustedDomainInfoByName_out_get_info(PyObject *obj, void *closure)
{
	struct lsa_QueryTrustedDomainInfoByName *object = (struct lsa_QueryTrustedDomainInfoByName *)pytalloc_get_ptr(obj);
	PyObject *py_info;
	if (*object->out.info == NULL) {
		py_info = Py_None;
		Py_INCREF(py_info);
	} else {
		py_info = pyrpc_import_union(&lsa_TrustedDomainInfo_Type, *object->out.info, object->in.level, *object->out.info, "union lsa_TrustedDomainInfo");
		if (py_info == NULL) {
			return NULL;
		}
	}
	return py_info;
}

static int py_lsa_QueryTrustedDomainInfoByName_out_set_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryTrustedDomainInfoByName *object = (struct lsa_QueryTrustedDomainInfoByName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.info");
		return -1;
	}
	object->out.info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.info);
	if (object->out.info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.info = NULL;
	} else {
		*object->out.info = NULL;
		{
			union lsa_TrustedDomainInfo *info_switch_2;
			info_switch_2 = (union lsa_TrustedDomainInfo *)pyrpc_export_union(&lsa_TrustedDomainInfo_Type, pytalloc_get_mem_ctx(py_obj), object->in.level, value, "union lsa_TrustedDomainInfo");
			if (info_switch_2 == NULL) {
				return -1;
			}
			*object->out.info = info_switch_2;
		}
	}
	return 0;
}

static PyObject *py_lsa_QueryTrustedDomainInfoByName_get_result(PyObject *obj, void *closure)
{
	struct lsa_QueryTrustedDomainInfoByName *object = (struct lsa_QueryTrustedDomainInfoByName *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_QueryTrustedDomainInfoByName_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryTrustedDomainInfoByName *object = (struct lsa_QueryTrustedDomainInfoByName *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_QueryTrustedDomainInfoByName_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_QueryTrustedDomainInfoByName_in_get_handle,
		.set = py_lsa_QueryTrustedDomainInfoByName_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_trusted_domain"),
		.get = py_lsa_QueryTrustedDomainInfoByName_in_get_trusted_domain,
		.set = py_lsa_QueryTrustedDomainInfoByName_in_set_trusted_domain,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_QueryTrustedDomainInfoByName_in_get_level,
		.set = py_lsa_QueryTrustedDomainInfoByName_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomInfoEnum")
	},
	{
		.name = discard_const_p(char, "out_info"),
		.get = py_lsa_QueryTrustedDomainInfoByName_out_get_info,
		.set = py_lsa_QueryTrustedDomainInfoByName_out_set_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustedDomainInfo")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_QueryTrustedDomainInfoByName_get_result,
		.set = py_lsa_QueryTrustedDomainInfoByName_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_QueryTrustedDomainInfoByName_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_QueryTrustedDomainInfoByName, type);
}

static PyObject *py_lsa_QueryTrustedDomainInfoByName_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(48);
}

static PyObject *py_lsa_QueryTrustedDomainInfoByName_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryTrustedDomainInfoByName *object = (struct lsa_QueryTrustedDomainInfoByName *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 49) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryTrustedDomainInfoByName_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[48];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_QueryTrustedDomainInfoByName_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_QueryTrustedDomainInfoByName_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_QueryTrustedDomainInfoByName_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_QueryTrustedDomainInfoByName_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_QueryTrustedDomainInfoByName_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryTrustedDomainInfoByName *object = (struct lsa_QueryTrustedDomainInfoByName *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 49) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryTrustedDomainInfoByName_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[48];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_QueryTrustedDomainInfoByName_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_QueryTrustedDomainInfoByName_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_QueryTrustedDomainInfoByName_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_QueryTrustedDomainInfoByName_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_QueryTrustedDomainInfoByName_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryTrustedDomainInfoByName *object = (struct lsa_QueryTrustedDomainInfoByName *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 49) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryTrustedDomainInfoByName_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[48];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_QueryTrustedDomainInfoByName_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_QueryTrustedDomainInfoByName_ndr_print(py_obj, "lsa_QueryTrustedDomainInfoByName_in", NDR_IN);
}

static PyObject *py_lsa_QueryTrustedDomainInfoByName_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_QueryTrustedDomainInfoByName_ndr_print(py_obj, "lsa_QueryTrustedDomainInfoByName_out", NDR_OUT);
}

static PyMethodDef py_lsa_QueryTrustedDomainInfoByName_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_QueryTrustedDomainInfoByName_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.QueryTrustedDomainInfoByName.opnum() -> 48 (0x30) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_QueryTrustedDomainInfoByName_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_QueryTrustedDomainInfoByName_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_QueryTrustedDomainInfoByName_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_QueryTrustedDomainInfoByName_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_QueryTrustedDomainInfoByName_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_QueryTrustedDomainInfoByName_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_QueryTrustedDomainInfoByName_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.QueryTrustedDomainInfoByName",
	.tp_getset = py_lsa_QueryTrustedDomainInfoByName_getsetters,
	.tp_methods = py_lsa_QueryTrustedDomainInfoByName_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_QueryTrustedDomainInfoByName_new,
};

static bool pack_py_lsa_QueryTrustedDomainInfoByName_args_in(PyObject *args, PyObject *kwargs, struct lsa_QueryTrustedDomainInfoByName *r)
{
	PyObject *py_handle;
	PyObject *py_trusted_domain;
	PyObject *py_level;
	const char *kwnames[] = {
		"handle", "trusted_domain", "level", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_QueryTrustedDomainInfoByName", discard_const_p(char *, kwnames), &py_handle, &py_trusted_domain, &py_level)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_trusted_domain == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.trusted_domain");
		return false;
	}
	r->in.trusted_domain = talloc_ptrtype(r, r->in.trusted_domain);
	if (r->in.trusted_domain == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_String_Type, py_trusted_domain, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_trusted_domain)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.trusted_domain = (struct lsa_String *)pytalloc_get_ptr(py_trusted_domain);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_QueryTrustedDomainInfoByName_args_out(struct lsa_QueryTrustedDomainInfoByName *r)
{
	PyObject *result;
	PyObject *py_info;
	if (*r->out.info == NULL) {
		py_info = Py_None;
		Py_INCREF(py_info);
	} else {
		py_info = pyrpc_import_union(&lsa_TrustedDomainInfo_Type, *r->out.info, r->in.level, *r->out.info, "union lsa_TrustedDomainInfo");
		if (py_info == NULL) {
			return NULL;
		}
	}
	result = py_info;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_SetTrustedDomainInfoByName_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_SetTrustedDomainInfoByName *object = (struct lsa_SetTrustedDomainInfoByName *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_SetTrustedDomainInfoByName_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetTrustedDomainInfoByName *object = (struct lsa_SetTrustedDomainInfoByName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_SetTrustedDomainInfoByName_in_get_trusted_domain(PyObject *obj, void *closure)
{
	struct lsa_SetTrustedDomainInfoByName *object = (struct lsa_SetTrustedDomainInfoByName *)pytalloc_get_ptr(obj);
	PyObject *py_trusted_domain;
	py_trusted_domain = pytalloc_reference_ex(&lsa_String_Type, object->in.trusted_domain, object->in.trusted_domain);
	return py_trusted_domain;
}

static int py_lsa_SetTrustedDomainInfoByName_in_set_trusted_domain(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetTrustedDomainInfoByName *object = (struct lsa_SetTrustedDomainInfoByName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.trusted_domain));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.trusted_domain");
		return -1;
	}
	object->in.trusted_domain = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.trusted_domain);
	if (object->in.trusted_domain == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.trusted_domain = (struct lsa_String *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_SetTrustedDomainInfoByName_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_SetTrustedDomainInfoByName *object = (struct lsa_SetTrustedDomainInfoByName *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_SetTrustedDomainInfoByName_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetTrustedDomainInfoByName *object = (struct lsa_SetTrustedDomainInfoByName *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_SetTrustedDomainInfoByName_in_get_info(PyObject *obj, void *closure)
{
	struct lsa_SetTrustedDomainInfoByName *object = (struct lsa_SetTrustedDomainInfoByName *)pytalloc_get_ptr(obj);
	PyObject *py_info;
	py_info = pyrpc_import_union(&lsa_TrustedDomainInfo_Type, object->in.info, object->in.level, object->in.info, "union lsa_TrustedDomainInfo");
	if (py_info == NULL) {
		return NULL;
	}
	return py_info;
}

static int py_lsa_SetTrustedDomainInfoByName_in_set_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetTrustedDomainInfoByName *object = (struct lsa_SetTrustedDomainInfoByName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.info");
		return -1;
	}
	object->in.info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.info);
	if (object->in.info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		union lsa_TrustedDomainInfo *info_switch_1;
		info_switch_1 = (union lsa_TrustedDomainInfo *)pyrpc_export_union(&lsa_TrustedDomainInfo_Type, pytalloc_get_mem_ctx(py_obj), object->in.level, value, "union lsa_TrustedDomainInfo");
		if (info_switch_1 == NULL) {
			return -1;
		}
		object->in.info = info_switch_1;
	}
	return 0;
}

static PyObject *py_lsa_SetTrustedDomainInfoByName_get_result(PyObject *obj, void *closure)
{
	struct lsa_SetTrustedDomainInfoByName *object = (struct lsa_SetTrustedDomainInfoByName *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_SetTrustedDomainInfoByName_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetTrustedDomainInfoByName *object = (struct lsa_SetTrustedDomainInfoByName *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_SetTrustedDomainInfoByName_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_SetTrustedDomainInfoByName_in_get_handle,
		.set = py_lsa_SetTrustedDomainInfoByName_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_trusted_domain"),
		.get = py_lsa_SetTrustedDomainInfoByName_in_get_trusted_domain,
		.set = py_lsa_SetTrustedDomainInfoByName_in_set_trusted_domain,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_SetTrustedDomainInfoByName_in_get_level,
		.set = py_lsa_SetTrustedDomainInfoByName_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomInfoEnum")
	},
	{
		.name = discard_const_p(char, "in_info"),
		.get = py_lsa_SetTrustedDomainInfoByName_in_get_info,
		.set = py_lsa_SetTrustedDomainInfoByName_in_set_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustedDomainInfo")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_SetTrustedDomainInfoByName_get_result,
		.set = py_lsa_SetTrustedDomainInfoByName_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_SetTrustedDomainInfoByName_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_SetTrustedDomainInfoByName, type);
}

static PyObject *py_lsa_SetTrustedDomainInfoByName_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(49);
}

static PyObject *py_lsa_SetTrustedDomainInfoByName_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetTrustedDomainInfoByName *object = (struct lsa_SetTrustedDomainInfoByName *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 50) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetTrustedDomainInfoByName_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[49];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_SetTrustedDomainInfoByName_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetTrustedDomainInfoByName_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_SetTrustedDomainInfoByName_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetTrustedDomainInfoByName_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_SetTrustedDomainInfoByName_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetTrustedDomainInfoByName *object = (struct lsa_SetTrustedDomainInfoByName *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 50) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetTrustedDomainInfoByName_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[49];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_SetTrustedDomainInfoByName_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetTrustedDomainInfoByName_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetTrustedDomainInfoByName_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetTrustedDomainInfoByName_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetTrustedDomainInfoByName_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetTrustedDomainInfoByName *object = (struct lsa_SetTrustedDomainInfoByName *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 50) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetTrustedDomainInfoByName_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[49];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_SetTrustedDomainInfoByName_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_SetTrustedDomainInfoByName_ndr_print(py_obj, "lsa_SetTrustedDomainInfoByName_in", NDR_IN);
}

static PyObject *py_lsa_SetTrustedDomainInfoByName_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_SetTrustedDomainInfoByName_ndr_print(py_obj, "lsa_SetTrustedDomainInfoByName_out", NDR_OUT);
}

static PyMethodDef py_lsa_SetTrustedDomainInfoByName_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_SetTrustedDomainInfoByName_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.SetTrustedDomainInfoByName.opnum() -> 49 (0x31) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_SetTrustedDomainInfoByName_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_SetTrustedDomainInfoByName_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_SetTrustedDomainInfoByName_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_SetTrustedDomainInfoByName_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_SetTrustedDomainInfoByName_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_SetTrustedDomainInfoByName_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_SetTrustedDomainInfoByName_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.SetTrustedDomainInfoByName",
	.tp_getset = py_lsa_SetTrustedDomainInfoByName_getsetters,
	.tp_methods = py_lsa_SetTrustedDomainInfoByName_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_SetTrustedDomainInfoByName_new,
};

static bool pack_py_lsa_SetTrustedDomainInfoByName_args_in(PyObject *args, PyObject *kwargs, struct lsa_SetTrustedDomainInfoByName *r)
{
	PyObject *py_handle;
	PyObject *py_trusted_domain;
	PyObject *py_level;
	PyObject *py_info;
	const char *kwnames[] = {
		"handle", "trusted_domain", "level", "info", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOO:lsa_SetTrustedDomainInfoByName", discard_const_p(char *, kwnames), &py_handle, &py_trusted_domain, &py_level, &py_info)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_trusted_domain == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.trusted_domain");
		return false;
	}
	r->in.trusted_domain = talloc_ptrtype(r, r->in.trusted_domain);
	if (r->in.trusted_domain == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_String_Type, py_trusted_domain, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_trusted_domain)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.trusted_domain = (struct lsa_String *)pytalloc_get_ptr(py_trusted_domain);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_info == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.info");
		return false;
	}
	r->in.info = talloc_ptrtype(r, r->in.info);
	if (r->in.info == NULL) {
		PyErr_NoMemory();
		return false;
	}
	{
		union lsa_TrustedDomainInfo *info_switch_1;
		info_switch_1 = (union lsa_TrustedDomainInfo *)pyrpc_export_union(&lsa_TrustedDomainInfo_Type, r, r->in.level, py_info, "union lsa_TrustedDomainInfo");
		if (info_switch_1 == NULL) {
			return false;
		}
		r->in.info = info_switch_1;
	}
	return true;
}

static PyObject *unpack_py_lsa_SetTrustedDomainInfoByName_args_out(struct lsa_SetTrustedDomainInfoByName *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_EnumTrustedDomainsEx_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_EnumTrustedDomainsEx *object = (struct lsa_EnumTrustedDomainsEx *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_EnumTrustedDomainsEx_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumTrustedDomainsEx *object = (struct lsa_EnumTrustedDomainsEx *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_EnumTrustedDomainsEx_in_get_resume_handle(PyObject *obj, void *closure)
{
	struct lsa_EnumTrustedDomainsEx *object = (struct lsa_EnumTrustedDomainsEx *)pytalloc_get_ptr(obj);
	PyObject *py_resume_handle;
	py_resume_handle = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->in.resume_handle);
	return py_resume_handle;
}

static int py_lsa_EnumTrustedDomainsEx_in_set_resume_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumTrustedDomainsEx *object = (struct lsa_EnumTrustedDomainsEx *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.resume_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.resume_handle");
		return -1;
	}
	object->in.resume_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.resume_handle);
	if (object->in.resume_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->in.resume_handle));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.resume_handle = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.resume_handle = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_EnumTrustedDomainsEx_out_get_resume_handle(PyObject *obj, void *closure)
{
	struct lsa_EnumTrustedDomainsEx *object = (struct lsa_EnumTrustedDomainsEx *)pytalloc_get_ptr(obj);
	PyObject *py_resume_handle;
	py_resume_handle = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->out.resume_handle);
	return py_resume_handle;
}

static int py_lsa_EnumTrustedDomainsEx_out_set_resume_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumTrustedDomainsEx *object = (struct lsa_EnumTrustedDomainsEx *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.resume_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.resume_handle");
		return -1;
	}
	object->out.resume_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.resume_handle);
	if (object->out.resume_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->out.resume_handle));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.resume_handle = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.resume_handle = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_EnumTrustedDomainsEx_out_get_domains(PyObject *obj, void *closure)
{
	struct lsa_EnumTrustedDomainsEx *object = (struct lsa_EnumTrustedDomainsEx *)pytalloc_get_ptr(obj);
	PyObject *py_domains;
	py_domains = pytalloc_reference_ex(&lsa_DomainListEx_Type, object->out.domains, object->out.domains);
	return py_domains;
}

static int py_lsa_EnumTrustedDomainsEx_out_set_domains(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumTrustedDomainsEx *object = (struct lsa_EnumTrustedDomainsEx *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.domains));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.domains");
		return -1;
	}
	object->out.domains = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.domains);
	if (object->out.domains == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_DomainListEx_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.domains = (struct lsa_DomainListEx *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_EnumTrustedDomainsEx_in_get_max_size(PyObject *obj, void *closure)
{
	struct lsa_EnumTrustedDomainsEx *object = (struct lsa_EnumTrustedDomainsEx *)pytalloc_get_ptr(obj);
	PyObject *py_max_size;
	py_max_size = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.max_size);
	return py_max_size;
}

static int py_lsa_EnumTrustedDomainsEx_in_set_max_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumTrustedDomainsEx *object = (struct lsa_EnumTrustedDomainsEx *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.max_size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.max_size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.max_size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.max_size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_EnumTrustedDomainsEx_get_result(PyObject *obj, void *closure)
{
	struct lsa_EnumTrustedDomainsEx *object = (struct lsa_EnumTrustedDomainsEx *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_EnumTrustedDomainsEx_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_EnumTrustedDomainsEx *object = (struct lsa_EnumTrustedDomainsEx *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_EnumTrustedDomainsEx_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_EnumTrustedDomainsEx_in_get_handle,
		.set = py_lsa_EnumTrustedDomainsEx_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_resume_handle"),
		.get = py_lsa_EnumTrustedDomainsEx_in_get_resume_handle,
		.set = py_lsa_EnumTrustedDomainsEx_in_set_resume_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "out_resume_handle"),
		.get = py_lsa_EnumTrustedDomainsEx_out_get_resume_handle,
		.set = py_lsa_EnumTrustedDomainsEx_out_set_resume_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "out_domains"),
		.get = py_lsa_EnumTrustedDomainsEx_out_get_domains,
		.set = py_lsa_EnumTrustedDomainsEx_out_set_domains,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DomainListEx")
	},
	{
		.name = discard_const_p(char, "in_max_size"),
		.get = py_lsa_EnumTrustedDomainsEx_in_get_max_size,
		.set = py_lsa_EnumTrustedDomainsEx_in_set_max_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_EnumTrustedDomainsEx_get_result,
		.set = py_lsa_EnumTrustedDomainsEx_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_EnumTrustedDomainsEx_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_EnumTrustedDomainsEx, type);
}

static PyObject *py_lsa_EnumTrustedDomainsEx_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(50);
}

static PyObject *py_lsa_EnumTrustedDomainsEx_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumTrustedDomainsEx *object = (struct lsa_EnumTrustedDomainsEx *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 51) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumTrustedDomainsEx_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[50];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_EnumTrustedDomainsEx_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_EnumTrustedDomainsEx_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_EnumTrustedDomainsEx_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_EnumTrustedDomainsEx_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_EnumTrustedDomainsEx_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumTrustedDomainsEx *object = (struct lsa_EnumTrustedDomainsEx *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 51) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumTrustedDomainsEx_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[50];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_EnumTrustedDomainsEx_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_EnumTrustedDomainsEx_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_EnumTrustedDomainsEx_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_EnumTrustedDomainsEx_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_EnumTrustedDomainsEx_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_EnumTrustedDomainsEx *object = (struct lsa_EnumTrustedDomainsEx *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 51) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_EnumTrustedDomainsEx_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[50];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_EnumTrustedDomainsEx_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_EnumTrustedDomainsEx_ndr_print(py_obj, "lsa_EnumTrustedDomainsEx_in", NDR_IN);
}

static PyObject *py_lsa_EnumTrustedDomainsEx_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_EnumTrustedDomainsEx_ndr_print(py_obj, "lsa_EnumTrustedDomainsEx_out", NDR_OUT);
}

static PyMethodDef py_lsa_EnumTrustedDomainsEx_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_EnumTrustedDomainsEx_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.EnumTrustedDomainsEx.opnum() -> 50 (0x32) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_EnumTrustedDomainsEx_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_EnumTrustedDomainsEx_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_EnumTrustedDomainsEx_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_EnumTrustedDomainsEx_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_EnumTrustedDomainsEx_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_EnumTrustedDomainsEx_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_EnumTrustedDomainsEx_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.EnumTrustedDomainsEx",
	.tp_getset = py_lsa_EnumTrustedDomainsEx_getsetters,
	.tp_methods = py_lsa_EnumTrustedDomainsEx_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_EnumTrustedDomainsEx_new,
};

static bool pack_py_lsa_EnumTrustedDomainsEx_args_in(PyObject *args, PyObject *kwargs, struct lsa_EnumTrustedDomainsEx *r)
{
	PyObject *py_handle;
	PyObject *py_resume_handle;
	PyObject *py_max_size;
	const char *kwnames[] = {
		"handle", "resume_handle", "max_size", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_EnumTrustedDomainsEx", discard_const_p(char *, kwnames), &py_handle, &py_resume_handle, &py_max_size)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_resume_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.resume_handle");
		return false;
	}
	r->in.resume_handle = talloc_ptrtype(r, r->in.resume_handle);
	if (r->in.resume_handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*r->in.resume_handle));
		if (PyLong_Check(py_resume_handle)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_resume_handle);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.resume_handle = test_var;
		} else if (PyInt_Check(py_resume_handle)) {
			long test_var;
			test_var = PyInt_AsLong(py_resume_handle);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.resume_handle = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_max_size == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.max_size");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.max_size));
		if (PyLong_Check(py_max_size)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_max_size);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.max_size = test_var;
		} else if (PyInt_Check(py_max_size)) {
			long test_var;
			test_var = PyInt_AsLong(py_max_size);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.max_size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_EnumTrustedDomainsEx_args_out(struct lsa_EnumTrustedDomainsEx *r)
{
	PyObject *result;
	PyObject *py_resume_handle;
	PyObject *py_domains;
	result = PyTuple_New(2);
	py_resume_handle = ndr_PyLong_FromUnsignedLongLong((uint32_t)*r->out.resume_handle);
	PyTuple_SetItem(result, 0, py_resume_handle);
	py_domains = pytalloc_reference_ex(&lsa_DomainListEx_Type, r->out.domains, r->out.domains);
	PyTuple_SetItem(result, 1, py_domains);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_CreateTrustedDomainEx_in_get_policy_handle(PyObject *obj, void *closure)
{
	struct lsa_CreateTrustedDomainEx *object = (struct lsa_CreateTrustedDomainEx *)pytalloc_get_ptr(obj);
	PyObject *py_policy_handle;
	py_policy_handle = pytalloc_reference_ex(policy_handle_Type, object->in.policy_handle, object->in.policy_handle);
	return py_policy_handle;
}

static int py_lsa_CreateTrustedDomainEx_in_set_policy_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateTrustedDomainEx *object = (struct lsa_CreateTrustedDomainEx *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.policy_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.policy_handle");
		return -1;
	}
	object->in.policy_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.policy_handle);
	if (object->in.policy_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.policy_handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CreateTrustedDomainEx_in_get_info(PyObject *obj, void *closure)
{
	struct lsa_CreateTrustedDomainEx *object = (struct lsa_CreateTrustedDomainEx *)pytalloc_get_ptr(obj);
	PyObject *py_info;
	py_info = pytalloc_reference_ex(&lsa_TrustDomainInfoInfoEx_Type, object->in.info, object->in.info);
	return py_info;
}

static int py_lsa_CreateTrustedDomainEx_in_set_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateTrustedDomainEx *object = (struct lsa_CreateTrustedDomainEx *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.info");
		return -1;
	}
	object->in.info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.info);
	if (object->in.info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoInfoEx_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.info = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CreateTrustedDomainEx_in_get_auth_info(PyObject *obj, void *closure)
{
	struct lsa_CreateTrustedDomainEx *object = (struct lsa_CreateTrustedDomainEx *)pytalloc_get_ptr(obj);
	PyObject *py_auth_info;
	py_auth_info = pytalloc_reference_ex(&lsa_TrustDomainInfoAuthInfo_Type, object->in.auth_info, object->in.auth_info);
	return py_auth_info;
}

static int py_lsa_CreateTrustedDomainEx_in_set_auth_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateTrustedDomainEx *object = (struct lsa_CreateTrustedDomainEx *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.auth_info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.auth_info");
		return -1;
	}
	object->in.auth_info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.auth_info);
	if (object->in.auth_info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoAuthInfo_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.auth_info = (struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CreateTrustedDomainEx_in_get_access_mask(PyObject *obj, void *closure)
{
	struct lsa_CreateTrustedDomainEx *object = (struct lsa_CreateTrustedDomainEx *)pytalloc_get_ptr(obj);
	PyObject *py_access_mask;
	py_access_mask = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.access_mask);
	return py_access_mask;
}

static int py_lsa_CreateTrustedDomainEx_in_set_access_mask(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateTrustedDomainEx *object = (struct lsa_CreateTrustedDomainEx *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.access_mask");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.access_mask));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_CreateTrustedDomainEx_out_get_trustdom_handle(PyObject *obj, void *closure)
{
	struct lsa_CreateTrustedDomainEx *object = (struct lsa_CreateTrustedDomainEx *)pytalloc_get_ptr(obj);
	PyObject *py_trustdom_handle;
	py_trustdom_handle = pytalloc_reference_ex(policy_handle_Type, object->out.trustdom_handle, object->out.trustdom_handle);
	return py_trustdom_handle;
}

static int py_lsa_CreateTrustedDomainEx_out_set_trustdom_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateTrustedDomainEx *object = (struct lsa_CreateTrustedDomainEx *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.trustdom_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.trustdom_handle");
		return -1;
	}
	object->out.trustdom_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.trustdom_handle);
	if (object->out.trustdom_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.trustdom_handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CreateTrustedDomainEx_get_result(PyObject *obj, void *closure)
{
	struct lsa_CreateTrustedDomainEx *object = (struct lsa_CreateTrustedDomainEx *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_CreateTrustedDomainEx_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateTrustedDomainEx *object = (struct lsa_CreateTrustedDomainEx *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_CreateTrustedDomainEx_getsetters[] = {
	{
		.name = discard_const_p(char, "in_policy_handle"),
		.get = py_lsa_CreateTrustedDomainEx_in_get_policy_handle,
		.set = py_lsa_CreateTrustedDomainEx_in_set_policy_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_info"),
		.get = py_lsa_CreateTrustedDomainEx_in_get_info,
		.set = py_lsa_CreateTrustedDomainEx_in_set_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoInfoEx")
	},
	{
		.name = discard_const_p(char, "in_auth_info"),
		.get = py_lsa_CreateTrustedDomainEx_in_get_auth_info,
		.set = py_lsa_CreateTrustedDomainEx_in_set_auth_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoAuthInfo")
	},
	{
		.name = discard_const_p(char, "in_access_mask"),
		.get = py_lsa_CreateTrustedDomainEx_in_get_access_mask,
		.set = py_lsa_CreateTrustedDomainEx_in_set_access_mask,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustedAccessMask")
	},
	{
		.name = discard_const_p(char, "out_trustdom_handle"),
		.get = py_lsa_CreateTrustedDomainEx_out_get_trustdom_handle,
		.set = py_lsa_CreateTrustedDomainEx_out_set_trustdom_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_CreateTrustedDomainEx_get_result,
		.set = py_lsa_CreateTrustedDomainEx_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_CreateTrustedDomainEx_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_CreateTrustedDomainEx, type);
}

static PyObject *py_lsa_CreateTrustedDomainEx_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(51);
}

static PyObject *py_lsa_CreateTrustedDomainEx_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CreateTrustedDomainEx *object = (struct lsa_CreateTrustedDomainEx *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 52) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CreateTrustedDomainEx_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[51];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_CreateTrustedDomainEx_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_CreateTrustedDomainEx_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_CreateTrustedDomainEx_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_CreateTrustedDomainEx_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_CreateTrustedDomainEx_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CreateTrustedDomainEx *object = (struct lsa_CreateTrustedDomainEx *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 52) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CreateTrustedDomainEx_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[51];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_CreateTrustedDomainEx_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_CreateTrustedDomainEx_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_CreateTrustedDomainEx_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_CreateTrustedDomainEx_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_CreateTrustedDomainEx_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CreateTrustedDomainEx *object = (struct lsa_CreateTrustedDomainEx *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 52) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CreateTrustedDomainEx_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[51];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_CreateTrustedDomainEx_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_CreateTrustedDomainEx_ndr_print(py_obj, "lsa_CreateTrustedDomainEx_in", NDR_IN);
}

static PyObject *py_lsa_CreateTrustedDomainEx_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_CreateTrustedDomainEx_ndr_print(py_obj, "lsa_CreateTrustedDomainEx_out", NDR_OUT);
}

static PyMethodDef py_lsa_CreateTrustedDomainEx_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_CreateTrustedDomainEx_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.CreateTrustedDomainEx.opnum() -> 51 (0x33) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_CreateTrustedDomainEx_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_CreateTrustedDomainEx_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_CreateTrustedDomainEx_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_CreateTrustedDomainEx_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_CreateTrustedDomainEx_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_CreateTrustedDomainEx_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_CreateTrustedDomainEx_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.CreateTrustedDomainEx",
	.tp_getset = py_lsa_CreateTrustedDomainEx_getsetters,
	.tp_methods = py_lsa_CreateTrustedDomainEx_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_CreateTrustedDomainEx_new,
};

static bool pack_py_lsa_CreateTrustedDomainEx_args_in(PyObject *args, PyObject *kwargs, struct lsa_CreateTrustedDomainEx *r)
{
	PyObject *py_policy_handle;
	PyObject *py_info;
	PyObject *py_auth_info;
	PyObject *py_access_mask;
	const char *kwnames[] = {
		"policy_handle", "info", "auth_info", "access_mask", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOO:lsa_CreateTrustedDomainEx", discard_const_p(char *, kwnames), &py_policy_handle, &py_info, &py_auth_info, &py_access_mask)) {
		return false;
	}

	if (py_policy_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.policy_handle");
		return false;
	}
	r->in.policy_handle = talloc_ptrtype(r, r->in.policy_handle);
	if (r->in.policy_handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_policy_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_policy_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.policy_handle = (struct policy_handle *)pytalloc_get_ptr(py_policy_handle);
	if (py_info == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.info");
		return false;
	}
	r->in.info = talloc_ptrtype(r, r->in.info);
	if (r->in.info == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoInfoEx_Type, py_info, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_info)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.info = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(py_info);
	if (py_auth_info == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.auth_info");
		return false;
	}
	r->in.auth_info = talloc_ptrtype(r, r->in.auth_info);
	if (r->in.auth_info == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoAuthInfo_Type, py_auth_info, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_auth_info)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.auth_info = (struct lsa_TrustDomainInfoAuthInfo *)pytalloc_get_ptr(py_auth_info);
	if (py_access_mask == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.access_mask");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.access_mask));
		if (PyLong_Check(py_access_mask)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_access_mask);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else if (PyInt_Check(py_access_mask)) {
			long test_var;
			test_var = PyInt_AsLong(py_access_mask);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_CreateTrustedDomainEx_args_out(struct lsa_CreateTrustedDomainEx *r)
{
	PyObject *result;
	PyObject *py_trustdom_handle;
	py_trustdom_handle = pytalloc_reference_ex(policy_handle_Type, r->out.trustdom_handle, r->out.trustdom_handle);
	result = py_trustdom_handle;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_CloseTrustedDomainEx_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_CloseTrustedDomainEx *object = (struct lsa_CloseTrustedDomainEx *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_CloseTrustedDomainEx_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CloseTrustedDomainEx *object = (struct lsa_CloseTrustedDomainEx *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CloseTrustedDomainEx_out_get_handle(PyObject *obj, void *closure)
{
	struct lsa_CloseTrustedDomainEx *object = (struct lsa_CloseTrustedDomainEx *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->out.handle, object->out.handle);
	return py_handle;
}

static int py_lsa_CloseTrustedDomainEx_out_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CloseTrustedDomainEx *object = (struct lsa_CloseTrustedDomainEx *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.handle");
		return -1;
	}
	object->out.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.handle);
	if (object->out.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CloseTrustedDomainEx_get_result(PyObject *obj, void *closure)
{
	struct lsa_CloseTrustedDomainEx *object = (struct lsa_CloseTrustedDomainEx *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_CloseTrustedDomainEx_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CloseTrustedDomainEx *object = (struct lsa_CloseTrustedDomainEx *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_CloseTrustedDomainEx_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_CloseTrustedDomainEx_in_get_handle,
		.set = py_lsa_CloseTrustedDomainEx_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "out_handle"),
		.get = py_lsa_CloseTrustedDomainEx_out_get_handle,
		.set = py_lsa_CloseTrustedDomainEx_out_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_CloseTrustedDomainEx_get_result,
		.set = py_lsa_CloseTrustedDomainEx_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_CloseTrustedDomainEx_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_CloseTrustedDomainEx, type);
}

static PyObject *py_lsa_CloseTrustedDomainEx_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(52);
}

static PyObject *py_lsa_CloseTrustedDomainEx_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CloseTrustedDomainEx *object = (struct lsa_CloseTrustedDomainEx *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 53) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CloseTrustedDomainEx_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[52];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_CloseTrustedDomainEx_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_CloseTrustedDomainEx_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_CloseTrustedDomainEx_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_CloseTrustedDomainEx_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_CloseTrustedDomainEx_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CloseTrustedDomainEx *object = (struct lsa_CloseTrustedDomainEx *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 53) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CloseTrustedDomainEx_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[52];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_CloseTrustedDomainEx_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_CloseTrustedDomainEx_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_CloseTrustedDomainEx_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_CloseTrustedDomainEx_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_CloseTrustedDomainEx_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CloseTrustedDomainEx *object = (struct lsa_CloseTrustedDomainEx *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 53) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CloseTrustedDomainEx_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[52];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_CloseTrustedDomainEx_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_CloseTrustedDomainEx_ndr_print(py_obj, "lsa_CloseTrustedDomainEx_in", NDR_IN);
}

static PyObject *py_lsa_CloseTrustedDomainEx_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_CloseTrustedDomainEx_ndr_print(py_obj, "lsa_CloseTrustedDomainEx_out", NDR_OUT);
}

static PyMethodDef py_lsa_CloseTrustedDomainEx_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_CloseTrustedDomainEx_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.CloseTrustedDomainEx.opnum() -> 52 (0x34) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_CloseTrustedDomainEx_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_CloseTrustedDomainEx_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_CloseTrustedDomainEx_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_CloseTrustedDomainEx_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_CloseTrustedDomainEx_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_CloseTrustedDomainEx_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_CloseTrustedDomainEx_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.CloseTrustedDomainEx",
	.tp_getset = py_lsa_CloseTrustedDomainEx_getsetters,
	.tp_methods = py_lsa_CloseTrustedDomainEx_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_CloseTrustedDomainEx_new,
};

static bool pack_py_lsa_CloseTrustedDomainEx_args_in(PyObject *args, PyObject *kwargs, struct lsa_CloseTrustedDomainEx *r)
{
	PyObject *py_handle;
	const char *kwnames[] = {
		"handle", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:lsa_CloseTrustedDomainEx", discard_const_p(char *, kwnames), &py_handle)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	return true;
}

static PyObject *unpack_py_lsa_CloseTrustedDomainEx_args_out(struct lsa_CloseTrustedDomainEx *r)
{
	PyObject *result;
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, r->out.handle, r->out.handle);
	result = py_handle;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_QueryDomainInformationPolicy_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_QueryDomainInformationPolicy *object = (struct lsa_QueryDomainInformationPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_QueryDomainInformationPolicy_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryDomainInformationPolicy *object = (struct lsa_QueryDomainInformationPolicy *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_QueryDomainInformationPolicy_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_QueryDomainInformationPolicy *object = (struct lsa_QueryDomainInformationPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_QueryDomainInformationPolicy_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryDomainInformationPolicy *object = (struct lsa_QueryDomainInformationPolicy *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_QueryDomainInformationPolicy_out_get_info(PyObject *obj, void *closure)
{
	struct lsa_QueryDomainInformationPolicy *object = (struct lsa_QueryDomainInformationPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_info;
	if (*object->out.info == NULL) {
		py_info = Py_None;
		Py_INCREF(py_info);
	} else {
		py_info = pyrpc_import_union(&lsa_DomainInformationPolicy_Type, *object->out.info, object->in.level, *object->out.info, "union lsa_DomainInformationPolicy");
		if (py_info == NULL) {
			return NULL;
		}
	}
	return py_info;
}

static int py_lsa_QueryDomainInformationPolicy_out_set_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryDomainInformationPolicy *object = (struct lsa_QueryDomainInformationPolicy *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.info");
		return -1;
	}
	object->out.info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.info);
	if (object->out.info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.info = NULL;
	} else {
		*object->out.info = NULL;
		{
			union lsa_DomainInformationPolicy *info_switch_2;
			info_switch_2 = (union lsa_DomainInformationPolicy *)pyrpc_export_union(&lsa_DomainInformationPolicy_Type, pytalloc_get_mem_ctx(py_obj), object->in.level, value, "union lsa_DomainInformationPolicy");
			if (info_switch_2 == NULL) {
				return -1;
			}
			*object->out.info = info_switch_2;
		}
	}
	return 0;
}

static PyObject *py_lsa_QueryDomainInformationPolicy_get_result(PyObject *obj, void *closure)
{
	struct lsa_QueryDomainInformationPolicy *object = (struct lsa_QueryDomainInformationPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_QueryDomainInformationPolicy_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_QueryDomainInformationPolicy *object = (struct lsa_QueryDomainInformationPolicy *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_QueryDomainInformationPolicy_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_QueryDomainInformationPolicy_in_get_handle,
		.set = py_lsa_QueryDomainInformationPolicy_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_QueryDomainInformationPolicy_in_get_level,
		.set = py_lsa_QueryDomainInformationPolicy_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "out_info"),
		.get = py_lsa_QueryDomainInformationPolicy_out_get_info,
		.set = py_lsa_QueryDomainInformationPolicy_out_set_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DomainInformationPolicy")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_QueryDomainInformationPolicy_get_result,
		.set = py_lsa_QueryDomainInformationPolicy_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_QueryDomainInformationPolicy_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_QueryDomainInformationPolicy, type);
}

static PyObject *py_lsa_QueryDomainInformationPolicy_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(53);
}

static PyObject *py_lsa_QueryDomainInformationPolicy_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryDomainInformationPolicy *object = (struct lsa_QueryDomainInformationPolicy *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 54) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryDomainInformationPolicy_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[53];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_QueryDomainInformationPolicy_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_QueryDomainInformationPolicy_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_QueryDomainInformationPolicy_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_QueryDomainInformationPolicy_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_QueryDomainInformationPolicy_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryDomainInformationPolicy *object = (struct lsa_QueryDomainInformationPolicy *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 54) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryDomainInformationPolicy_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[53];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_QueryDomainInformationPolicy_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_QueryDomainInformationPolicy_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_QueryDomainInformationPolicy_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_QueryDomainInformationPolicy_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_QueryDomainInformationPolicy_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_QueryDomainInformationPolicy *object = (struct lsa_QueryDomainInformationPolicy *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 54) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_QueryDomainInformationPolicy_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[53];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_QueryDomainInformationPolicy_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_QueryDomainInformationPolicy_ndr_print(py_obj, "lsa_QueryDomainInformationPolicy_in", NDR_IN);
}

static PyObject *py_lsa_QueryDomainInformationPolicy_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_QueryDomainInformationPolicy_ndr_print(py_obj, "lsa_QueryDomainInformationPolicy_out", NDR_OUT);
}

static PyMethodDef py_lsa_QueryDomainInformationPolicy_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_QueryDomainInformationPolicy_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.QueryDomainInformationPolicy.opnum() -> 53 (0x35) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_QueryDomainInformationPolicy_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_QueryDomainInformationPolicy_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_QueryDomainInformationPolicy_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_QueryDomainInformationPolicy_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_QueryDomainInformationPolicy_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_QueryDomainInformationPolicy_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_QueryDomainInformationPolicy_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.QueryDomainInformationPolicy",
	.tp_getset = py_lsa_QueryDomainInformationPolicy_getsetters,
	.tp_methods = py_lsa_QueryDomainInformationPolicy_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_QueryDomainInformationPolicy_new,
};

static bool pack_py_lsa_QueryDomainInformationPolicy_args_in(PyObject *args, PyObject *kwargs, struct lsa_QueryDomainInformationPolicy *r)
{
	PyObject *py_handle;
	PyObject *py_level;
	const char *kwnames[] = {
		"handle", "level", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:lsa_QueryDomainInformationPolicy", discard_const_p(char *, kwnames), &py_handle, &py_level)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_QueryDomainInformationPolicy_args_out(struct lsa_QueryDomainInformationPolicy *r)
{
	PyObject *result;
	PyObject *py_info;
	if (*r->out.info == NULL) {
		py_info = Py_None;
		Py_INCREF(py_info);
	} else {
		py_info = pyrpc_import_union(&lsa_DomainInformationPolicy_Type, *r->out.info, r->in.level, *r->out.info, "union lsa_DomainInformationPolicy");
		if (py_info == NULL) {
			return NULL;
		}
	}
	result = py_info;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_SetDomainInformationPolicy_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_SetDomainInformationPolicy *object = (struct lsa_SetDomainInformationPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_SetDomainInformationPolicy_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetDomainInformationPolicy *object = (struct lsa_SetDomainInformationPolicy *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_SetDomainInformationPolicy_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_SetDomainInformationPolicy *object = (struct lsa_SetDomainInformationPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_SetDomainInformationPolicy_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetDomainInformationPolicy *object = (struct lsa_SetDomainInformationPolicy *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_SetDomainInformationPolicy_in_get_info(PyObject *obj, void *closure)
{
	struct lsa_SetDomainInformationPolicy *object = (struct lsa_SetDomainInformationPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_info;
	if (object->in.info == NULL) {
		py_info = Py_None;
		Py_INCREF(py_info);
	} else {
		py_info = pyrpc_import_union(&lsa_DomainInformationPolicy_Type, object->in.info, object->in.level, object->in.info, "union lsa_DomainInformationPolicy");
		if (py_info == NULL) {
			return NULL;
		}
	}
	return py_info;
}

static int py_lsa_SetDomainInformationPolicy_in_set_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetDomainInformationPolicy *object = (struct lsa_SetDomainInformationPolicy *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.info");
		return -1;
	}
	if (value == Py_None) {
		object->in.info = NULL;
	} else {
		object->in.info = NULL;
		{
			union lsa_DomainInformationPolicy *info_switch_1;
			info_switch_1 = (union lsa_DomainInformationPolicy *)pyrpc_export_union(&lsa_DomainInformationPolicy_Type, pytalloc_get_mem_ctx(py_obj), object->in.level, value, "union lsa_DomainInformationPolicy");
			if (info_switch_1 == NULL) {
				return -1;
			}
			object->in.info = info_switch_1;
		}
	}
	return 0;
}

static PyObject *py_lsa_SetDomainInformationPolicy_get_result(PyObject *obj, void *closure)
{
	struct lsa_SetDomainInformationPolicy *object = (struct lsa_SetDomainInformationPolicy *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_SetDomainInformationPolicy_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_SetDomainInformationPolicy *object = (struct lsa_SetDomainInformationPolicy *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_SetDomainInformationPolicy_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_SetDomainInformationPolicy_in_get_handle,
		.set = py_lsa_SetDomainInformationPolicy_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_SetDomainInformationPolicy_in_get_level,
		.set = py_lsa_SetDomainInformationPolicy_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "in_info"),
		.get = py_lsa_SetDomainInformationPolicy_in_get_info,
		.set = py_lsa_SetDomainInformationPolicy_in_set_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_DomainInformationPolicy")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_SetDomainInformationPolicy_get_result,
		.set = py_lsa_SetDomainInformationPolicy_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_SetDomainInformationPolicy_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_SetDomainInformationPolicy, type);
}

static PyObject *py_lsa_SetDomainInformationPolicy_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(54);
}

static PyObject *py_lsa_SetDomainInformationPolicy_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetDomainInformationPolicy *object = (struct lsa_SetDomainInformationPolicy *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 55) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetDomainInformationPolicy_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[54];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_SetDomainInformationPolicy_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetDomainInformationPolicy_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_SetDomainInformationPolicy_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_SetDomainInformationPolicy_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_SetDomainInformationPolicy_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetDomainInformationPolicy *object = (struct lsa_SetDomainInformationPolicy *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 55) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetDomainInformationPolicy_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[54];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_SetDomainInformationPolicy_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetDomainInformationPolicy_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetDomainInformationPolicy_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_SetDomainInformationPolicy_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_SetDomainInformationPolicy_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_SetDomainInformationPolicy *object = (struct lsa_SetDomainInformationPolicy *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 55) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_SetDomainInformationPolicy_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[54];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_SetDomainInformationPolicy_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_SetDomainInformationPolicy_ndr_print(py_obj, "lsa_SetDomainInformationPolicy_in", NDR_IN);
}

static PyObject *py_lsa_SetDomainInformationPolicy_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_SetDomainInformationPolicy_ndr_print(py_obj, "lsa_SetDomainInformationPolicy_out", NDR_OUT);
}

static PyMethodDef py_lsa_SetDomainInformationPolicy_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_SetDomainInformationPolicy_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.SetDomainInformationPolicy.opnum() -> 54 (0x36) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_SetDomainInformationPolicy_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_SetDomainInformationPolicy_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_SetDomainInformationPolicy_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_SetDomainInformationPolicy_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_SetDomainInformationPolicy_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_SetDomainInformationPolicy_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_SetDomainInformationPolicy_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.SetDomainInformationPolicy",
	.tp_getset = py_lsa_SetDomainInformationPolicy_getsetters,
	.tp_methods = py_lsa_SetDomainInformationPolicy_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_SetDomainInformationPolicy_new,
};

static bool pack_py_lsa_SetDomainInformationPolicy_args_in(PyObject *args, PyObject *kwargs, struct lsa_SetDomainInformationPolicy *r)
{
	PyObject *py_handle;
	PyObject *py_level;
	PyObject *py_info;
	const char *kwnames[] = {
		"handle", "level", "info", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_SetDomainInformationPolicy", discard_const_p(char *, kwnames), &py_handle, &py_level, &py_info)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_info == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.info");
		return false;
	}
	if (py_info == Py_None) {
		r->in.info = NULL;
	} else {
		r->in.info = NULL;
		{
			union lsa_DomainInformationPolicy *info_switch_1;
			info_switch_1 = (union lsa_DomainInformationPolicy *)pyrpc_export_union(&lsa_DomainInformationPolicy_Type, r, r->in.level, py_info, "union lsa_DomainInformationPolicy");
			if (info_switch_1 == NULL) {
				return false;
			}
			r->in.info = info_switch_1;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_SetDomainInformationPolicy_args_out(struct lsa_SetDomainInformationPolicy *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_OpenTrustedDomainByName_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_OpenTrustedDomainByName *object = (struct lsa_OpenTrustedDomainByName *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_OpenTrustedDomainByName_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenTrustedDomainByName *object = (struct lsa_OpenTrustedDomainByName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_OpenTrustedDomainByName_in_get_name(PyObject *obj, void *closure)
{
	struct lsa_OpenTrustedDomainByName *object = (struct lsa_OpenTrustedDomainByName *)pytalloc_get_ptr(obj);
	PyObject *py_name;
	py_name = pytalloc_reference_ex(&lsa_String_Type, pytalloc_get_mem_ctx(obj), &object->in.name);
	return py_name;
}

static int py_lsa_OpenTrustedDomainByName_in_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenTrustedDomainByName *object = (struct lsa_OpenTrustedDomainByName *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.name");
		return -1;
	}
	PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.name = *(struct lsa_String *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_OpenTrustedDomainByName_in_get_access_mask(PyObject *obj, void *closure)
{
	struct lsa_OpenTrustedDomainByName *object = (struct lsa_OpenTrustedDomainByName *)pytalloc_get_ptr(obj);
	PyObject *py_access_mask;
	py_access_mask = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.access_mask);
	return py_access_mask;
}

static int py_lsa_OpenTrustedDomainByName_in_set_access_mask(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenTrustedDomainByName *object = (struct lsa_OpenTrustedDomainByName *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.access_mask");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.access_mask));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_OpenTrustedDomainByName_out_get_trustdom_handle(PyObject *obj, void *closure)
{
	struct lsa_OpenTrustedDomainByName *object = (struct lsa_OpenTrustedDomainByName *)pytalloc_get_ptr(obj);
	PyObject *py_trustdom_handle;
	py_trustdom_handle = pytalloc_reference_ex(policy_handle_Type, object->out.trustdom_handle, object->out.trustdom_handle);
	return py_trustdom_handle;
}

static int py_lsa_OpenTrustedDomainByName_out_set_trustdom_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenTrustedDomainByName *object = (struct lsa_OpenTrustedDomainByName *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.trustdom_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.trustdom_handle");
		return -1;
	}
	object->out.trustdom_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.trustdom_handle);
	if (object->out.trustdom_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.trustdom_handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_OpenTrustedDomainByName_get_result(PyObject *obj, void *closure)
{
	struct lsa_OpenTrustedDomainByName *object = (struct lsa_OpenTrustedDomainByName *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_OpenTrustedDomainByName_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_OpenTrustedDomainByName *object = (struct lsa_OpenTrustedDomainByName *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_OpenTrustedDomainByName_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_OpenTrustedDomainByName_in_get_handle,
		.set = py_lsa_OpenTrustedDomainByName_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_name"),
		.get = py_lsa_OpenTrustedDomainByName_in_get_name,
		.set = py_lsa_OpenTrustedDomainByName_in_set_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "in_access_mask"),
		.get = py_lsa_OpenTrustedDomainByName_in_get_access_mask,
		.set = py_lsa_OpenTrustedDomainByName_in_set_access_mask,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustedAccessMask")
	},
	{
		.name = discard_const_p(char, "out_trustdom_handle"),
		.get = py_lsa_OpenTrustedDomainByName_out_get_trustdom_handle,
		.set = py_lsa_OpenTrustedDomainByName_out_set_trustdom_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_OpenTrustedDomainByName_get_result,
		.set = py_lsa_OpenTrustedDomainByName_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_OpenTrustedDomainByName_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_OpenTrustedDomainByName, type);
}

static PyObject *py_lsa_OpenTrustedDomainByName_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(55);
}

static PyObject *py_lsa_OpenTrustedDomainByName_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenTrustedDomainByName *object = (struct lsa_OpenTrustedDomainByName *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 56) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenTrustedDomainByName_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[55];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_OpenTrustedDomainByName_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_OpenTrustedDomainByName_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_OpenTrustedDomainByName_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_OpenTrustedDomainByName_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_OpenTrustedDomainByName_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenTrustedDomainByName *object = (struct lsa_OpenTrustedDomainByName *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 56) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenTrustedDomainByName_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[55];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_OpenTrustedDomainByName_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_OpenTrustedDomainByName_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_OpenTrustedDomainByName_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_OpenTrustedDomainByName_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_OpenTrustedDomainByName_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_OpenTrustedDomainByName *object = (struct lsa_OpenTrustedDomainByName *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 56) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_OpenTrustedDomainByName_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[55];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_OpenTrustedDomainByName_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_OpenTrustedDomainByName_ndr_print(py_obj, "lsa_OpenTrustedDomainByName_in", NDR_IN);
}

static PyObject *py_lsa_OpenTrustedDomainByName_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_OpenTrustedDomainByName_ndr_print(py_obj, "lsa_OpenTrustedDomainByName_out", NDR_OUT);
}

static PyMethodDef py_lsa_OpenTrustedDomainByName_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_OpenTrustedDomainByName_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.OpenTrustedDomainByName.opnum() -> 55 (0x37) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_OpenTrustedDomainByName_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_OpenTrustedDomainByName_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_OpenTrustedDomainByName_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_OpenTrustedDomainByName_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_OpenTrustedDomainByName_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_OpenTrustedDomainByName_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_OpenTrustedDomainByName_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.OpenTrustedDomainByName",
	.tp_getset = py_lsa_OpenTrustedDomainByName_getsetters,
	.tp_methods = py_lsa_OpenTrustedDomainByName_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_OpenTrustedDomainByName_new,
};

static bool pack_py_lsa_OpenTrustedDomainByName_args_in(PyObject *args, PyObject *kwargs, struct lsa_OpenTrustedDomainByName *r)
{
	PyObject *py_handle;
	PyObject *py_name;
	PyObject *py_access_mask;
	const char *kwnames[] = {
		"handle", "name", "access_mask", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_OpenTrustedDomainByName", discard_const_p(char *, kwnames), &py_handle, &py_name, &py_access_mask)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_name == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.name");
		return false;
	}
	PY_CHECK_TYPE(&lsa_String_Type, py_name, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_name)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.name = *(struct lsa_String *)pytalloc_get_ptr(py_name);
	if (py_access_mask == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.access_mask");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.access_mask));
		if (PyLong_Check(py_access_mask)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_access_mask);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else if (PyInt_Check(py_access_mask)) {
			long test_var;
			test_var = PyInt_AsLong(py_access_mask);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_OpenTrustedDomainByName_args_out(struct lsa_OpenTrustedDomainByName *r)
{
	PyObject *result;
	PyObject *py_trustdom_handle;
	py_trustdom_handle = pytalloc_reference_ex(policy_handle_Type, r->out.trustdom_handle, r->out.trustdom_handle);
	result = py_trustdom_handle;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_LookupSids2_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_LookupSids2_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupSids2_in_get_sids(PyObject *obj, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(obj);
	PyObject *py_sids;
	py_sids = pytalloc_reference_ex(&lsa_SidArray_Type, object->in.sids, object->in.sids);
	return py_sids;
}

static int py_lsa_LookupSids2_in_set_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.sids));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sids");
		return -1;
	}
	object->in.sids = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.sids);
	if (object->in.sids == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_SidArray_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.sids = (struct lsa_SidArray *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupSids2_out_get_domains(PyObject *obj, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(obj);
	PyObject *py_domains;
	if (*object->out.domains == NULL) {
		py_domains = Py_None;
		Py_INCREF(py_domains);
	} else {
		py_domains = pytalloc_reference_ex(&lsa_RefDomainList_Type, *object->out.domains, *object->out.domains);
	}
	return py_domains;
}

static int py_lsa_LookupSids2_out_set_domains(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.domains));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.domains");
		return -1;
	}
	object->out.domains = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.domains);
	if (object->out.domains == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.domains = NULL;
	} else {
		*object->out.domains = NULL;
		PY_CHECK_TYPE(&lsa_RefDomainList_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		*object->out.domains = (struct lsa_RefDomainList *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_LookupSids2_in_get_names(PyObject *obj, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(obj);
	PyObject *py_names;
	py_names = pytalloc_reference_ex(&lsa_TransNameArray2_Type, object->in.names, object->in.names);
	return py_names;
}

static int py_lsa_LookupSids2_in_set_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.names));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.names");
		return -1;
	}
	object->in.names = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.names);
	if (object->in.names == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TransNameArray2_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.names = (struct lsa_TransNameArray2 *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupSids2_out_get_names(PyObject *obj, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(obj);
	PyObject *py_names;
	py_names = pytalloc_reference_ex(&lsa_TransNameArray2_Type, object->out.names, object->out.names);
	return py_names;
}

static int py_lsa_LookupSids2_out_set_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.names));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.names");
		return -1;
	}
	object->out.names = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.names);
	if (object->out.names == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TransNameArray2_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.names = (struct lsa_TransNameArray2 *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupSids2_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_LookupSids2_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupSids2_in_get_count(PyObject *obj, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->in.count);
	return py_count;
}

static int py_lsa_LookupSids2_in_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.count));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.count");
		return -1;
	}
	object->in.count = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.count);
	if (object->in.count == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->in.count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupSids2_out_get_count(PyObject *obj, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->out.count);
	return py_count;
}

static int py_lsa_LookupSids2_out_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.count));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.count");
		return -1;
	}
	object->out.count = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.count);
	if (object->out.count == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->out.count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupSids2_in_get_lookup_options(PyObject *obj, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(obj);
	PyObject *py_lookup_options;
	py_lookup_options = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.lookup_options);
	return py_lookup_options;
}

static int py_lsa_LookupSids2_in_set_lookup_options(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.lookup_options");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.lookup_options));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.lookup_options = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.lookup_options = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupSids2_in_get_client_revision(PyObject *obj, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(obj);
	PyObject *py_client_revision;
	py_client_revision = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.client_revision);
	return py_client_revision;
}

static int py_lsa_LookupSids2_in_set_client_revision(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.client_revision");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.client_revision));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.client_revision = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.client_revision = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupSids2_get_result(PyObject *obj, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_LookupSids2_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_LookupSids2_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_LookupSids2_in_get_handle,
		.set = py_lsa_LookupSids2_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_sids"),
		.get = py_lsa_LookupSids2_in_get_sids,
		.set = py_lsa_LookupSids2_in_set_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_SidArray")
	},
	{
		.name = discard_const_p(char, "out_domains"),
		.get = py_lsa_LookupSids2_out_get_domains,
		.set = py_lsa_LookupSids2_out_set_domains,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_RefDomainList")
	},
	{
		.name = discard_const_p(char, "in_names"),
		.get = py_lsa_LookupSids2_in_get_names,
		.set = py_lsa_LookupSids2_in_set_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TransNameArray2")
	},
	{
		.name = discard_const_p(char, "out_names"),
		.get = py_lsa_LookupSids2_out_get_names,
		.set = py_lsa_LookupSids2_out_set_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TransNameArray2")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_LookupSids2_in_get_level,
		.set = py_lsa_LookupSids2_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_LookupNamesLevel")
	},
	{
		.name = discard_const_p(char, "in_count"),
		.get = py_lsa_LookupSids2_in_get_count,
		.set = py_lsa_LookupSids2_in_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "out_count"),
		.get = py_lsa_LookupSids2_out_get_count,
		.set = py_lsa_LookupSids2_out_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "in_lookup_options"),
		.get = py_lsa_LookupSids2_in_get_lookup_options,
		.set = py_lsa_LookupSids2_in_set_lookup_options,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_LookupOptions")
	},
	{
		.name = discard_const_p(char, "in_client_revision"),
		.get = py_lsa_LookupSids2_in_get_client_revision,
		.set = py_lsa_LookupSids2_in_set_client_revision,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ClientRevision")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_LookupSids2_get_result,
		.set = py_lsa_LookupSids2_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_LookupSids2_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_LookupSids2, type);
}

static PyObject *py_lsa_LookupSids2_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(57);
}

static PyObject *py_lsa_LookupSids2_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 58) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupSids2_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[57];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_LookupSids2_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupSids2_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_LookupSids2_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupSids2_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_LookupSids2_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 58) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupSids2_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[57];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_LookupSids2_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupSids2_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupSids2_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupSids2_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupSids2_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupSids2 *object = (struct lsa_LookupSids2 *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 58) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupSids2_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[57];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_LookupSids2_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_LookupSids2_ndr_print(py_obj, "lsa_LookupSids2_in", NDR_IN);
}

static PyObject *py_lsa_LookupSids2_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_LookupSids2_ndr_print(py_obj, "lsa_LookupSids2_out", NDR_OUT);
}

static PyMethodDef py_lsa_LookupSids2_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_LookupSids2_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.LookupSids2.opnum() -> 57 (0x39) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_LookupSids2_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_LookupSids2_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_LookupSids2_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_LookupSids2_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_LookupSids2_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_LookupSids2_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_LookupSids2_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.LookupSids2",
	.tp_getset = py_lsa_LookupSids2_getsetters,
	.tp_methods = py_lsa_LookupSids2_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_LookupSids2_new,
};

static bool pack_py_lsa_LookupSids2_args_in(PyObject *args, PyObject *kwargs, struct lsa_LookupSids2 *r)
{
	PyObject *py_handle;
	PyObject *py_sids;
	PyObject *py_names;
	PyObject *py_level;
	PyObject *py_count;
	PyObject *py_lookup_options;
	PyObject *py_client_revision;
	const char *kwnames[] = {
		"handle", "sids", "names", "level", "count", "lookup_options", "client_revision", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOOOOO:lsa_LookupSids2", discard_const_p(char *, kwnames), &py_handle, &py_sids, &py_names, &py_level, &py_count, &py_lookup_options, &py_client_revision)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_sids == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sids");
		return false;
	}
	r->in.sids = talloc_ptrtype(r, r->in.sids);
	if (r->in.sids == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_SidArray_Type, py_sids, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_sids)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.sids = (struct lsa_SidArray *)pytalloc_get_ptr(py_sids);
	if (py_names == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.names");
		return false;
	}
	r->in.names = talloc_ptrtype(r, r->in.names);
	if (r->in.names == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_TransNameArray2_Type, py_names, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_names)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.names = (struct lsa_TransNameArray2 *)pytalloc_get_ptr(py_names);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_count == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.count");
		return false;
	}
	r->in.count = talloc_ptrtype(r, r->in.count);
	if (r->in.count == NULL) {
		PyErr_NoMemory();
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*r->in.count));
		if (PyLong_Check(py_count)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_count);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.count = test_var;
		} else if (PyInt_Check(py_count)) {
			long test_var;
			test_var = PyInt_AsLong(py_count);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_lookup_options == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.lookup_options");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.lookup_options));
		if (PyLong_Check(py_lookup_options)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_lookup_options);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.lookup_options = test_var;
		} else if (PyInt_Check(py_lookup_options)) {
			long test_var;
			test_var = PyInt_AsLong(py_lookup_options);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.lookup_options = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_client_revision == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.client_revision");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.client_revision));
		if (PyLong_Check(py_client_revision)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_client_revision);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.client_revision = test_var;
		} else if (PyInt_Check(py_client_revision)) {
			long test_var;
			test_var = PyInt_AsLong(py_client_revision);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.client_revision = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_LookupSids2_args_out(struct lsa_LookupSids2 *r)
{
	PyObject *result;
	PyObject *py_domains;
	PyObject *py_names;
	PyObject *py_count;
	result = PyTuple_New(3);
	if (*r->out.domains == NULL) {
		py_domains = Py_None;
		Py_INCREF(py_domains);
	} else {
		py_domains = pytalloc_reference_ex(&lsa_RefDomainList_Type, *r->out.domains, *r->out.domains);
	}
	PyTuple_SetItem(result, 0, py_domains);
	py_names = pytalloc_reference_ex(&lsa_TransNameArray2_Type, r->out.names, r->out.names);
	PyTuple_SetItem(result, 1, py_names);
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*r->out.count);
	PyTuple_SetItem(result, 2, py_count);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_LookupNames2_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_LookupNames2_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupNames2_in_get_num_names(PyObject *obj, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(obj);
	PyObject *py_num_names;
	py_num_names = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.num_names);
	return py_num_names;
}

static int py_lsa_LookupNames2_in_set_num_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.num_names");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.num_names));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.num_names = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.num_names = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames2_in_get_names(PyObject *obj, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(obj);
	PyObject *py_names;
	py_names = PyList_New(object->in.num_names);
	if (py_names == NULL) {
		return NULL;
	}
	{
		int names_cntr_0;
		for (names_cntr_0 = 0; names_cntr_0 < (object->in.num_names); names_cntr_0++) {
			PyObject *py_names_0;
			py_names_0 = pytalloc_reference_ex(&lsa_String_Type, object->in.names, &object->in.names[names_cntr_0]);
			PyList_SetItem(py_names, names_cntr_0, py_names_0);
		}
	}
	return py_names;
}

static int py_lsa_LookupNames2_in_set_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.names");
		return -1;
	}
	PY_CHECK_TYPE(&PyList_Type, value, return -1;);
	{
		int names_cntr_0;
		object->in.names = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.names, PyList_GET_SIZE(value));
		if (!object->in.names) { return -1;; }
		talloc_set_name_const(object->in.names, "ARRAY: object->in.names");
		for (names_cntr_0 = 0; names_cntr_0 < PyList_GET_SIZE(value); names_cntr_0++) {
			if (PyList_GET_ITEM(value, names_cntr_0) == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.names[names_cntr_0]");
				return -1;
			}
			PY_CHECK_TYPE(&lsa_String_Type, PyList_GET_ITEM(value, names_cntr_0), return -1;);
			if (talloc_reference(object->in.names, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, names_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->in.names[names_cntr_0] = *(struct lsa_String *)pytalloc_get_ptr(PyList_GET_ITEM(value, names_cntr_0));
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames2_out_get_domains(PyObject *obj, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(obj);
	PyObject *py_domains;
	if (*object->out.domains == NULL) {
		py_domains = Py_None;
		Py_INCREF(py_domains);
	} else {
		py_domains = pytalloc_reference_ex(&lsa_RefDomainList_Type, *object->out.domains, *object->out.domains);
	}
	return py_domains;
}

static int py_lsa_LookupNames2_out_set_domains(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.domains));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.domains");
		return -1;
	}
	object->out.domains = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.domains);
	if (object->out.domains == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.domains = NULL;
	} else {
		*object->out.domains = NULL;
		PY_CHECK_TYPE(&lsa_RefDomainList_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		*object->out.domains = (struct lsa_RefDomainList *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_LookupNames2_in_get_sids(PyObject *obj, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(obj);
	PyObject *py_sids;
	py_sids = pytalloc_reference_ex(&lsa_TransSidArray2_Type, object->in.sids, object->in.sids);
	return py_sids;
}

static int py_lsa_LookupNames2_in_set_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.sids));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sids");
		return -1;
	}
	object->in.sids = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.sids);
	if (object->in.sids == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TransSidArray2_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.sids = (struct lsa_TransSidArray2 *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupNames2_out_get_sids(PyObject *obj, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(obj);
	PyObject *py_sids;
	py_sids = pytalloc_reference_ex(&lsa_TransSidArray2_Type, object->out.sids, object->out.sids);
	return py_sids;
}

static int py_lsa_LookupNames2_out_set_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.sids));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.sids");
		return -1;
	}
	object->out.sids = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.sids);
	if (object->out.sids == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TransSidArray2_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.sids = (struct lsa_TransSidArray2 *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupNames2_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_LookupNames2_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames2_in_get_count(PyObject *obj, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->in.count);
	return py_count;
}

static int py_lsa_LookupNames2_in_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.count));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.count");
		return -1;
	}
	object->in.count = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.count);
	if (object->in.count == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->in.count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames2_out_get_count(PyObject *obj, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->out.count);
	return py_count;
}

static int py_lsa_LookupNames2_out_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.count));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.count");
		return -1;
	}
	object->out.count = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.count);
	if (object->out.count == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->out.count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames2_in_get_lookup_options(PyObject *obj, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(obj);
	PyObject *py_lookup_options;
	py_lookup_options = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.lookup_options);
	return py_lookup_options;
}

static int py_lsa_LookupNames2_in_set_lookup_options(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.lookup_options");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.lookup_options));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.lookup_options = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.lookup_options = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames2_in_get_client_revision(PyObject *obj, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(obj);
	PyObject *py_client_revision;
	py_client_revision = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.client_revision);
	return py_client_revision;
}

static int py_lsa_LookupNames2_in_set_client_revision(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.client_revision");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.client_revision));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.client_revision = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.client_revision = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames2_get_result(PyObject *obj, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_LookupNames2_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_LookupNames2_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_LookupNames2_in_get_handle,
		.set = py_lsa_LookupNames2_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_num_names"),
		.get = py_lsa_LookupNames2_in_get_num_names,
		.set = py_lsa_LookupNames2_in_set_num_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "in_names"),
		.get = py_lsa_LookupNames2_in_get_names,
		.set = py_lsa_LookupNames2_in_set_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "out_domains"),
		.get = py_lsa_LookupNames2_out_get_domains,
		.set = py_lsa_LookupNames2_out_set_domains,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_RefDomainList")
	},
	{
		.name = discard_const_p(char, "in_sids"),
		.get = py_lsa_LookupNames2_in_get_sids,
		.set = py_lsa_LookupNames2_in_set_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TransSidArray2")
	},
	{
		.name = discard_const_p(char, "out_sids"),
		.get = py_lsa_LookupNames2_out_get_sids,
		.set = py_lsa_LookupNames2_out_set_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TransSidArray2")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_LookupNames2_in_get_level,
		.set = py_lsa_LookupNames2_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_LookupNamesLevel")
	},
	{
		.name = discard_const_p(char, "in_count"),
		.get = py_lsa_LookupNames2_in_get_count,
		.set = py_lsa_LookupNames2_in_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "out_count"),
		.get = py_lsa_LookupNames2_out_get_count,
		.set = py_lsa_LookupNames2_out_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "in_lookup_options"),
		.get = py_lsa_LookupNames2_in_get_lookup_options,
		.set = py_lsa_LookupNames2_in_set_lookup_options,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_LookupOptions")
	},
	{
		.name = discard_const_p(char, "in_client_revision"),
		.get = py_lsa_LookupNames2_in_get_client_revision,
		.set = py_lsa_LookupNames2_in_set_client_revision,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ClientRevision")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_LookupNames2_get_result,
		.set = py_lsa_LookupNames2_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_LookupNames2_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_LookupNames2, type);
}

static PyObject *py_lsa_LookupNames2_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(58);
}

static PyObject *py_lsa_LookupNames2_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 59) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupNames2_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[58];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_LookupNames2_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupNames2_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_LookupNames2_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupNames2_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_LookupNames2_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 59) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupNames2_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[58];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_LookupNames2_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupNames2_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupNames2_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupNames2_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupNames2_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupNames2 *object = (struct lsa_LookupNames2 *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 59) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupNames2_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[58];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_LookupNames2_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_LookupNames2_ndr_print(py_obj, "lsa_LookupNames2_in", NDR_IN);
}

static PyObject *py_lsa_LookupNames2_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_LookupNames2_ndr_print(py_obj, "lsa_LookupNames2_out", NDR_OUT);
}

static PyMethodDef py_lsa_LookupNames2_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_LookupNames2_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.LookupNames2.opnum() -> 58 (0x3a) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_LookupNames2_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_LookupNames2_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_LookupNames2_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_LookupNames2_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_LookupNames2_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_LookupNames2_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_LookupNames2_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.LookupNames2",
	.tp_getset = py_lsa_LookupNames2_getsetters,
	.tp_methods = py_lsa_LookupNames2_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_LookupNames2_new,
};

static bool pack_py_lsa_LookupNames2_args_in(PyObject *args, PyObject *kwargs, struct lsa_LookupNames2 *r)
{
	PyObject *py_handle;
	PyObject *py_names;
	PyObject *py_sids;
	PyObject *py_level;
	PyObject *py_count;
	PyObject *py_lookup_options;
	PyObject *py_client_revision;
	const char *kwnames[] = {
		"handle", "names", "sids", "level", "count", "lookup_options", "client_revision", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOOOOO:lsa_LookupNames2", discard_const_p(char *, kwnames), &py_handle, &py_names, &py_sids, &py_level, &py_count, &py_lookup_options, &py_client_revision)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	PY_CHECK_TYPE(&PyList_Type, py_names, return false;);
	r->in.num_names = PyList_GET_SIZE(py_names);
	if (py_names == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.names");
		return false;
	}
	PY_CHECK_TYPE(&PyList_Type, py_names, return false;);
	{
		int names_cntr_0;
		r->in.names = talloc_array_ptrtype(r, r->in.names, PyList_GET_SIZE(py_names));
		if (!r->in.names) { return false;; }
		talloc_set_name_const(r->in.names, "ARRAY: r->in.names");
		for (names_cntr_0 = 0; names_cntr_0 < PyList_GET_SIZE(py_names); names_cntr_0++) {
			if (PyList_GET_ITEM(py_names, names_cntr_0) == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.names[names_cntr_0]");
				return false;
			}
			PY_CHECK_TYPE(&lsa_String_Type, PyList_GET_ITEM(py_names, names_cntr_0), return false;);
			if (talloc_reference(r->in.names, pytalloc_get_mem_ctx(PyList_GET_ITEM(py_names, names_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return false;
			}
			r->in.names[names_cntr_0] = *(struct lsa_String *)pytalloc_get_ptr(PyList_GET_ITEM(py_names, names_cntr_0));
		}
	}
	if (py_sids == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sids");
		return false;
	}
	r->in.sids = talloc_ptrtype(r, r->in.sids);
	if (r->in.sids == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_TransSidArray2_Type, py_sids, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_sids)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.sids = (struct lsa_TransSidArray2 *)pytalloc_get_ptr(py_sids);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_count == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.count");
		return false;
	}
	r->in.count = talloc_ptrtype(r, r->in.count);
	if (r->in.count == NULL) {
		PyErr_NoMemory();
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*r->in.count));
		if (PyLong_Check(py_count)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_count);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.count = test_var;
		} else if (PyInt_Check(py_count)) {
			long test_var;
			test_var = PyInt_AsLong(py_count);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_lookup_options == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.lookup_options");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.lookup_options));
		if (PyLong_Check(py_lookup_options)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_lookup_options);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.lookup_options = test_var;
		} else if (PyInt_Check(py_lookup_options)) {
			long test_var;
			test_var = PyInt_AsLong(py_lookup_options);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.lookup_options = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_client_revision == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.client_revision");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.client_revision));
		if (PyLong_Check(py_client_revision)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_client_revision);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.client_revision = test_var;
		} else if (PyInt_Check(py_client_revision)) {
			long test_var;
			test_var = PyInt_AsLong(py_client_revision);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.client_revision = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_LookupNames2_args_out(struct lsa_LookupNames2 *r)
{
	PyObject *result;
	PyObject *py_domains;
	PyObject *py_sids;
	PyObject *py_count;
	result = PyTuple_New(3);
	if (*r->out.domains == NULL) {
		py_domains = Py_None;
		Py_INCREF(py_domains);
	} else {
		py_domains = pytalloc_reference_ex(&lsa_RefDomainList_Type, *r->out.domains, *r->out.domains);
	}
	PyTuple_SetItem(result, 0, py_domains);
	py_sids = pytalloc_reference_ex(&lsa_TransSidArray2_Type, r->out.sids, r->out.sids);
	PyTuple_SetItem(result, 1, py_sids);
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*r->out.count);
	PyTuple_SetItem(result, 2, py_count);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_CreateTrustedDomainEx2_in_get_policy_handle(PyObject *obj, void *closure)
{
	struct lsa_CreateTrustedDomainEx2 *object = (struct lsa_CreateTrustedDomainEx2 *)pytalloc_get_ptr(obj);
	PyObject *py_policy_handle;
	py_policy_handle = pytalloc_reference_ex(policy_handle_Type, object->in.policy_handle, object->in.policy_handle);
	return py_policy_handle;
}

static int py_lsa_CreateTrustedDomainEx2_in_set_policy_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateTrustedDomainEx2 *object = (struct lsa_CreateTrustedDomainEx2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.policy_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.policy_handle");
		return -1;
	}
	object->in.policy_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.policy_handle);
	if (object->in.policy_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.policy_handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CreateTrustedDomainEx2_in_get_info(PyObject *obj, void *closure)
{
	struct lsa_CreateTrustedDomainEx2 *object = (struct lsa_CreateTrustedDomainEx2 *)pytalloc_get_ptr(obj);
	PyObject *py_info;
	py_info = pytalloc_reference_ex(&lsa_TrustDomainInfoInfoEx_Type, object->in.info, object->in.info);
	return py_info;
}

static int py_lsa_CreateTrustedDomainEx2_in_set_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateTrustedDomainEx2 *object = (struct lsa_CreateTrustedDomainEx2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.info");
		return -1;
	}
	object->in.info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.info);
	if (object->in.info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoInfoEx_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.info = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CreateTrustedDomainEx2_in_get_auth_info_internal(PyObject *obj, void *closure)
{
	struct lsa_CreateTrustedDomainEx2 *object = (struct lsa_CreateTrustedDomainEx2 *)pytalloc_get_ptr(obj);
	PyObject *py_auth_info_internal;
	py_auth_info_internal = pytalloc_reference_ex(&lsa_TrustDomainInfoAuthInfoInternal_Type, object->in.auth_info_internal, object->in.auth_info_internal);
	return py_auth_info_internal;
}

static int py_lsa_CreateTrustedDomainEx2_in_set_auth_info_internal(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateTrustedDomainEx2 *object = (struct lsa_CreateTrustedDomainEx2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.auth_info_internal));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.auth_info_internal");
		return -1;
	}
	object->in.auth_info_internal = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.auth_info_internal);
	if (object->in.auth_info_internal == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoAuthInfoInternal_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.auth_info_internal = (struct lsa_TrustDomainInfoAuthInfoInternal *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CreateTrustedDomainEx2_in_get_access_mask(PyObject *obj, void *closure)
{
	struct lsa_CreateTrustedDomainEx2 *object = (struct lsa_CreateTrustedDomainEx2 *)pytalloc_get_ptr(obj);
	PyObject *py_access_mask;
	py_access_mask = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.access_mask);
	return py_access_mask;
}

static int py_lsa_CreateTrustedDomainEx2_in_set_access_mask(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateTrustedDomainEx2 *object = (struct lsa_CreateTrustedDomainEx2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.access_mask");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.access_mask));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_CreateTrustedDomainEx2_out_get_trustdom_handle(PyObject *obj, void *closure)
{
	struct lsa_CreateTrustedDomainEx2 *object = (struct lsa_CreateTrustedDomainEx2 *)pytalloc_get_ptr(obj);
	PyObject *py_trustdom_handle;
	py_trustdom_handle = pytalloc_reference_ex(policy_handle_Type, object->out.trustdom_handle, object->out.trustdom_handle);
	return py_trustdom_handle;
}

static int py_lsa_CreateTrustedDomainEx2_out_set_trustdom_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateTrustedDomainEx2 *object = (struct lsa_CreateTrustedDomainEx2 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.trustdom_handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.trustdom_handle");
		return -1;
	}
	object->out.trustdom_handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.trustdom_handle);
	if (object->out.trustdom_handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.trustdom_handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_CreateTrustedDomainEx2_get_result(PyObject *obj, void *closure)
{
	struct lsa_CreateTrustedDomainEx2 *object = (struct lsa_CreateTrustedDomainEx2 *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_CreateTrustedDomainEx2_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_CreateTrustedDomainEx2 *object = (struct lsa_CreateTrustedDomainEx2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_CreateTrustedDomainEx2_getsetters[] = {
	{
		.name = discard_const_p(char, "in_policy_handle"),
		.get = py_lsa_CreateTrustedDomainEx2_in_get_policy_handle,
		.set = py_lsa_CreateTrustedDomainEx2_in_set_policy_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_info"),
		.get = py_lsa_CreateTrustedDomainEx2_in_get_info,
		.set = py_lsa_CreateTrustedDomainEx2_in_set_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoInfoEx")
	},
	{
		.name = discard_const_p(char, "in_auth_info_internal"),
		.get = py_lsa_CreateTrustedDomainEx2_in_get_auth_info_internal,
		.set = py_lsa_CreateTrustedDomainEx2_in_set_auth_info_internal,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustDomainInfoAuthInfoInternal")
	},
	{
		.name = discard_const_p(char, "in_access_mask"),
		.get = py_lsa_CreateTrustedDomainEx2_in_get_access_mask,
		.set = py_lsa_CreateTrustedDomainEx2_in_set_access_mask,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TrustedAccessMask")
	},
	{
		.name = discard_const_p(char, "out_trustdom_handle"),
		.get = py_lsa_CreateTrustedDomainEx2_out_get_trustdom_handle,
		.set = py_lsa_CreateTrustedDomainEx2_out_set_trustdom_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_CreateTrustedDomainEx2_get_result,
		.set = py_lsa_CreateTrustedDomainEx2_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_CreateTrustedDomainEx2_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_CreateTrustedDomainEx2, type);
}

static PyObject *py_lsa_CreateTrustedDomainEx2_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(59);
}

static PyObject *py_lsa_CreateTrustedDomainEx2_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CreateTrustedDomainEx2 *object = (struct lsa_CreateTrustedDomainEx2 *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 60) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CreateTrustedDomainEx2_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[59];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_CreateTrustedDomainEx2_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_CreateTrustedDomainEx2_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_CreateTrustedDomainEx2_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_CreateTrustedDomainEx2_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_CreateTrustedDomainEx2_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CreateTrustedDomainEx2 *object = (struct lsa_CreateTrustedDomainEx2 *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 60) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CreateTrustedDomainEx2_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[59];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_CreateTrustedDomainEx2_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_CreateTrustedDomainEx2_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_CreateTrustedDomainEx2_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_CreateTrustedDomainEx2_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_CreateTrustedDomainEx2_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_CreateTrustedDomainEx2 *object = (struct lsa_CreateTrustedDomainEx2 *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 60) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_CreateTrustedDomainEx2_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[59];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_CreateTrustedDomainEx2_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_CreateTrustedDomainEx2_ndr_print(py_obj, "lsa_CreateTrustedDomainEx2_in", NDR_IN);
}

static PyObject *py_lsa_CreateTrustedDomainEx2_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_CreateTrustedDomainEx2_ndr_print(py_obj, "lsa_CreateTrustedDomainEx2_out", NDR_OUT);
}

static PyMethodDef py_lsa_CreateTrustedDomainEx2_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_CreateTrustedDomainEx2_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.CreateTrustedDomainEx2.opnum() -> 59 (0x3b) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_CreateTrustedDomainEx2_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_CreateTrustedDomainEx2_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_CreateTrustedDomainEx2_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_CreateTrustedDomainEx2_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_CreateTrustedDomainEx2_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_CreateTrustedDomainEx2_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_CreateTrustedDomainEx2_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.CreateTrustedDomainEx2",
	.tp_getset = py_lsa_CreateTrustedDomainEx2_getsetters,
	.tp_methods = py_lsa_CreateTrustedDomainEx2_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_CreateTrustedDomainEx2_new,
};

static bool pack_py_lsa_CreateTrustedDomainEx2_args_in(PyObject *args, PyObject *kwargs, struct lsa_CreateTrustedDomainEx2 *r)
{
	PyObject *py_policy_handle;
	PyObject *py_info;
	PyObject *py_auth_info_internal;
	PyObject *py_access_mask;
	const char *kwnames[] = {
		"policy_handle", "info", "auth_info_internal", "access_mask", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOO:lsa_CreateTrustedDomainEx2", discard_const_p(char *, kwnames), &py_policy_handle, &py_info, &py_auth_info_internal, &py_access_mask)) {
		return false;
	}

	if (py_policy_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.policy_handle");
		return false;
	}
	r->in.policy_handle = talloc_ptrtype(r, r->in.policy_handle);
	if (r->in.policy_handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_policy_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_policy_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.policy_handle = (struct policy_handle *)pytalloc_get_ptr(py_policy_handle);
	if (py_info == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.info");
		return false;
	}
	r->in.info = talloc_ptrtype(r, r->in.info);
	if (r->in.info == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoInfoEx_Type, py_info, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_info)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.info = (struct lsa_TrustDomainInfoInfoEx *)pytalloc_get_ptr(py_info);
	if (py_auth_info_internal == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.auth_info_internal");
		return false;
	}
	r->in.auth_info_internal = talloc_ptrtype(r, r->in.auth_info_internal);
	if (r->in.auth_info_internal == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_TrustDomainInfoAuthInfoInternal_Type, py_auth_info_internal, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_auth_info_internal)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.auth_info_internal = (struct lsa_TrustDomainInfoAuthInfoInternal *)pytalloc_get_ptr(py_auth_info_internal);
	if (py_access_mask == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.access_mask");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.access_mask));
		if (PyLong_Check(py_access_mask)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_access_mask);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else if (PyInt_Check(py_access_mask)) {
			long test_var;
			test_var = PyInt_AsLong(py_access_mask);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.access_mask = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_CreateTrustedDomainEx2_args_out(struct lsa_CreateTrustedDomainEx2 *r)
{
	PyObject *result;
	PyObject *py_trustdom_handle;
	py_trustdom_handle = pytalloc_reference_ex(policy_handle_Type, r->out.trustdom_handle, r->out.trustdom_handle);
	result = py_trustdom_handle;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_LookupNames3_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_LookupNames3_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupNames3_in_get_num_names(PyObject *obj, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(obj);
	PyObject *py_num_names;
	py_num_names = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.num_names);
	return py_num_names;
}

static int py_lsa_LookupNames3_in_set_num_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.num_names");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.num_names));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.num_names = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.num_names = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames3_in_get_names(PyObject *obj, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(obj);
	PyObject *py_names;
	py_names = PyList_New(object->in.num_names);
	if (py_names == NULL) {
		return NULL;
	}
	{
		int names_cntr_0;
		for (names_cntr_0 = 0; names_cntr_0 < (object->in.num_names); names_cntr_0++) {
			PyObject *py_names_0;
			py_names_0 = pytalloc_reference_ex(&lsa_String_Type, object->in.names, &object->in.names[names_cntr_0]);
			PyList_SetItem(py_names, names_cntr_0, py_names_0);
		}
	}
	return py_names;
}

static int py_lsa_LookupNames3_in_set_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.names");
		return -1;
	}
	PY_CHECK_TYPE(&PyList_Type, value, return -1;);
	{
		int names_cntr_0;
		object->in.names = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.names, PyList_GET_SIZE(value));
		if (!object->in.names) { return -1;; }
		talloc_set_name_const(object->in.names, "ARRAY: object->in.names");
		for (names_cntr_0 = 0; names_cntr_0 < PyList_GET_SIZE(value); names_cntr_0++) {
			if (PyList_GET_ITEM(value, names_cntr_0) == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.names[names_cntr_0]");
				return -1;
			}
			PY_CHECK_TYPE(&lsa_String_Type, PyList_GET_ITEM(value, names_cntr_0), return -1;);
			if (talloc_reference(object->in.names, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, names_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->in.names[names_cntr_0] = *(struct lsa_String *)pytalloc_get_ptr(PyList_GET_ITEM(value, names_cntr_0));
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames3_out_get_domains(PyObject *obj, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(obj);
	PyObject *py_domains;
	if (*object->out.domains == NULL) {
		py_domains = Py_None;
		Py_INCREF(py_domains);
	} else {
		py_domains = pytalloc_reference_ex(&lsa_RefDomainList_Type, *object->out.domains, *object->out.domains);
	}
	return py_domains;
}

static int py_lsa_LookupNames3_out_set_domains(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.domains));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.domains");
		return -1;
	}
	object->out.domains = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.domains);
	if (object->out.domains == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.domains = NULL;
	} else {
		*object->out.domains = NULL;
		PY_CHECK_TYPE(&lsa_RefDomainList_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		*object->out.domains = (struct lsa_RefDomainList *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_LookupNames3_in_get_sids(PyObject *obj, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(obj);
	PyObject *py_sids;
	py_sids = pytalloc_reference_ex(&lsa_TransSidArray3_Type, object->in.sids, object->in.sids);
	return py_sids;
}

static int py_lsa_LookupNames3_in_set_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.sids));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sids");
		return -1;
	}
	object->in.sids = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.sids);
	if (object->in.sids == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TransSidArray3_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.sids = (struct lsa_TransSidArray3 *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupNames3_out_get_sids(PyObject *obj, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(obj);
	PyObject *py_sids;
	py_sids = pytalloc_reference_ex(&lsa_TransSidArray3_Type, object->out.sids, object->out.sids);
	return py_sids;
}

static int py_lsa_LookupNames3_out_set_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.sids));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.sids");
		return -1;
	}
	object->out.sids = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.sids);
	if (object->out.sids == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TransSidArray3_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.sids = (struct lsa_TransSidArray3 *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupNames3_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_LookupNames3_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames3_in_get_count(PyObject *obj, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->in.count);
	return py_count;
}

static int py_lsa_LookupNames3_in_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.count));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.count");
		return -1;
	}
	object->in.count = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.count);
	if (object->in.count == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->in.count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames3_out_get_count(PyObject *obj, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->out.count);
	return py_count;
}

static int py_lsa_LookupNames3_out_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.count));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.count");
		return -1;
	}
	object->out.count = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.count);
	if (object->out.count == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->out.count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames3_in_get_lookup_options(PyObject *obj, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(obj);
	PyObject *py_lookup_options;
	py_lookup_options = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.lookup_options);
	return py_lookup_options;
}

static int py_lsa_LookupNames3_in_set_lookup_options(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.lookup_options");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.lookup_options));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.lookup_options = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.lookup_options = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames3_in_get_client_revision(PyObject *obj, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(obj);
	PyObject *py_client_revision;
	py_client_revision = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.client_revision);
	return py_client_revision;
}

static int py_lsa_LookupNames3_in_set_client_revision(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.client_revision");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.client_revision));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.client_revision = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.client_revision = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames3_get_result(PyObject *obj, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_LookupNames3_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_LookupNames3_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_LookupNames3_in_get_handle,
		.set = py_lsa_LookupNames3_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_num_names"),
		.get = py_lsa_LookupNames3_in_get_num_names,
		.set = py_lsa_LookupNames3_in_set_num_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "in_names"),
		.get = py_lsa_LookupNames3_in_get_names,
		.set = py_lsa_LookupNames3_in_set_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "out_domains"),
		.get = py_lsa_LookupNames3_out_get_domains,
		.set = py_lsa_LookupNames3_out_set_domains,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_RefDomainList")
	},
	{
		.name = discard_const_p(char, "in_sids"),
		.get = py_lsa_LookupNames3_in_get_sids,
		.set = py_lsa_LookupNames3_in_set_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TransSidArray3")
	},
	{
		.name = discard_const_p(char, "out_sids"),
		.get = py_lsa_LookupNames3_out_get_sids,
		.set = py_lsa_LookupNames3_out_set_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TransSidArray3")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_LookupNames3_in_get_level,
		.set = py_lsa_LookupNames3_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_LookupNamesLevel")
	},
	{
		.name = discard_const_p(char, "in_count"),
		.get = py_lsa_LookupNames3_in_get_count,
		.set = py_lsa_LookupNames3_in_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "out_count"),
		.get = py_lsa_LookupNames3_out_get_count,
		.set = py_lsa_LookupNames3_out_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "in_lookup_options"),
		.get = py_lsa_LookupNames3_in_get_lookup_options,
		.set = py_lsa_LookupNames3_in_set_lookup_options,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_LookupOptions")
	},
	{
		.name = discard_const_p(char, "in_client_revision"),
		.get = py_lsa_LookupNames3_in_get_client_revision,
		.set = py_lsa_LookupNames3_in_set_client_revision,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ClientRevision")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_LookupNames3_get_result,
		.set = py_lsa_LookupNames3_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_LookupNames3_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_LookupNames3, type);
}

static PyObject *py_lsa_LookupNames3_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(68);
}

static PyObject *py_lsa_LookupNames3_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 69) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupNames3_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[68];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_LookupNames3_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupNames3_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_LookupNames3_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupNames3_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_LookupNames3_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 69) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupNames3_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[68];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_LookupNames3_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupNames3_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupNames3_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupNames3_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupNames3_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupNames3 *object = (struct lsa_LookupNames3 *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 69) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupNames3_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[68];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_LookupNames3_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_LookupNames3_ndr_print(py_obj, "lsa_LookupNames3_in", NDR_IN);
}

static PyObject *py_lsa_LookupNames3_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_LookupNames3_ndr_print(py_obj, "lsa_LookupNames3_out", NDR_OUT);
}

static PyMethodDef py_lsa_LookupNames3_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_LookupNames3_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.LookupNames3.opnum() -> 68 (0x44) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_LookupNames3_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_LookupNames3_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_LookupNames3_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_LookupNames3_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_LookupNames3_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_LookupNames3_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_LookupNames3_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.LookupNames3",
	.tp_getset = py_lsa_LookupNames3_getsetters,
	.tp_methods = py_lsa_LookupNames3_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_LookupNames3_new,
};

static bool pack_py_lsa_LookupNames3_args_in(PyObject *args, PyObject *kwargs, struct lsa_LookupNames3 *r)
{
	PyObject *py_handle;
	PyObject *py_names;
	PyObject *py_sids;
	PyObject *py_level;
	PyObject *py_count;
	PyObject *py_lookup_options;
	PyObject *py_client_revision;
	const char *kwnames[] = {
		"handle", "names", "sids", "level", "count", "lookup_options", "client_revision", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOOOOO:lsa_LookupNames3", discard_const_p(char *, kwnames), &py_handle, &py_names, &py_sids, &py_level, &py_count, &py_lookup_options, &py_client_revision)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	PY_CHECK_TYPE(&PyList_Type, py_names, return false;);
	r->in.num_names = PyList_GET_SIZE(py_names);
	if (py_names == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.names");
		return false;
	}
	PY_CHECK_TYPE(&PyList_Type, py_names, return false;);
	{
		int names_cntr_0;
		r->in.names = talloc_array_ptrtype(r, r->in.names, PyList_GET_SIZE(py_names));
		if (!r->in.names) { return false;; }
		talloc_set_name_const(r->in.names, "ARRAY: r->in.names");
		for (names_cntr_0 = 0; names_cntr_0 < PyList_GET_SIZE(py_names); names_cntr_0++) {
			if (PyList_GET_ITEM(py_names, names_cntr_0) == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.names[names_cntr_0]");
				return false;
			}
			PY_CHECK_TYPE(&lsa_String_Type, PyList_GET_ITEM(py_names, names_cntr_0), return false;);
			if (talloc_reference(r->in.names, pytalloc_get_mem_ctx(PyList_GET_ITEM(py_names, names_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return false;
			}
			r->in.names[names_cntr_0] = *(struct lsa_String *)pytalloc_get_ptr(PyList_GET_ITEM(py_names, names_cntr_0));
		}
	}
	if (py_sids == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sids");
		return false;
	}
	r->in.sids = talloc_ptrtype(r, r->in.sids);
	if (r->in.sids == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_TransSidArray3_Type, py_sids, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_sids)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.sids = (struct lsa_TransSidArray3 *)pytalloc_get_ptr(py_sids);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_count == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.count");
		return false;
	}
	r->in.count = talloc_ptrtype(r, r->in.count);
	if (r->in.count == NULL) {
		PyErr_NoMemory();
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*r->in.count));
		if (PyLong_Check(py_count)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_count);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.count = test_var;
		} else if (PyInt_Check(py_count)) {
			long test_var;
			test_var = PyInt_AsLong(py_count);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_lookup_options == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.lookup_options");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.lookup_options));
		if (PyLong_Check(py_lookup_options)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_lookup_options);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.lookup_options = test_var;
		} else if (PyInt_Check(py_lookup_options)) {
			long test_var;
			test_var = PyInt_AsLong(py_lookup_options);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.lookup_options = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_client_revision == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.client_revision");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.client_revision));
		if (PyLong_Check(py_client_revision)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_client_revision);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.client_revision = test_var;
		} else if (PyInt_Check(py_client_revision)) {
			long test_var;
			test_var = PyInt_AsLong(py_client_revision);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.client_revision = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_LookupNames3_args_out(struct lsa_LookupNames3 *r)
{
	PyObject *result;
	PyObject *py_domains;
	PyObject *py_sids;
	PyObject *py_count;
	result = PyTuple_New(3);
	if (*r->out.domains == NULL) {
		py_domains = Py_None;
		Py_INCREF(py_domains);
	} else {
		py_domains = pytalloc_reference_ex(&lsa_RefDomainList_Type, *r->out.domains, *r->out.domains);
	}
	PyTuple_SetItem(result, 0, py_domains);
	py_sids = pytalloc_reference_ex(&lsa_TransSidArray3_Type, r->out.sids, r->out.sids);
	PyTuple_SetItem(result, 1, py_sids);
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*r->out.count);
	PyTuple_SetItem(result, 2, py_count);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_lsaRQueryForestTrustInformation_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_lsaRQueryForestTrustInformation *object = (struct lsa_lsaRQueryForestTrustInformation *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_lsaRQueryForestTrustInformation_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_lsaRQueryForestTrustInformation *object = (struct lsa_lsaRQueryForestTrustInformation *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_lsaRQueryForestTrustInformation_in_get_trusted_domain_name(PyObject *obj, void *closure)
{
	struct lsa_lsaRQueryForestTrustInformation *object = (struct lsa_lsaRQueryForestTrustInformation *)pytalloc_get_ptr(obj);
	PyObject *py_trusted_domain_name;
	py_trusted_domain_name = pytalloc_reference_ex(&lsa_String_Type, object->in.trusted_domain_name, object->in.trusted_domain_name);
	return py_trusted_domain_name;
}

static int py_lsa_lsaRQueryForestTrustInformation_in_set_trusted_domain_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_lsaRQueryForestTrustInformation *object = (struct lsa_lsaRQueryForestTrustInformation *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.trusted_domain_name));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.trusted_domain_name");
		return -1;
	}
	object->in.trusted_domain_name = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.trusted_domain_name);
	if (object->in.trusted_domain_name == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_String_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.trusted_domain_name = (struct lsa_String *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_lsaRQueryForestTrustInformation_in_get_highest_record_type(PyObject *obj, void *closure)
{
	struct lsa_lsaRQueryForestTrustInformation *object = (struct lsa_lsaRQueryForestTrustInformation *)pytalloc_get_ptr(obj);
	PyObject *py_highest_record_type;
	py_highest_record_type = PyInt_FromLong((uint16_t)object->in.highest_record_type);
	return py_highest_record_type;
}

static int py_lsa_lsaRQueryForestTrustInformation_in_set_highest_record_type(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_lsaRQueryForestTrustInformation *object = (struct lsa_lsaRQueryForestTrustInformation *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.highest_record_type");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.highest_record_type));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.highest_record_type = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.highest_record_type = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_lsaRQueryForestTrustInformation_out_get_forest_trust_info(PyObject *obj, void *closure)
{
	struct lsa_lsaRQueryForestTrustInformation *object = (struct lsa_lsaRQueryForestTrustInformation *)pytalloc_get_ptr(obj);
	PyObject *py_forest_trust_info;
	if (*object->out.forest_trust_info == NULL) {
		py_forest_trust_info = Py_None;
		Py_INCREF(py_forest_trust_info);
	} else {
		py_forest_trust_info = pytalloc_reference_ex(&lsa_ForestTrustInformation_Type, *object->out.forest_trust_info, *object->out.forest_trust_info);
	}
	return py_forest_trust_info;
}

static int py_lsa_lsaRQueryForestTrustInformation_out_set_forest_trust_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_lsaRQueryForestTrustInformation *object = (struct lsa_lsaRQueryForestTrustInformation *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.forest_trust_info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.forest_trust_info");
		return -1;
	}
	object->out.forest_trust_info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.forest_trust_info);
	if (object->out.forest_trust_info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.forest_trust_info = NULL;
	} else {
		*object->out.forest_trust_info = NULL;
		PY_CHECK_TYPE(&lsa_ForestTrustInformation_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		*object->out.forest_trust_info = (struct lsa_ForestTrustInformation *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_lsaRQueryForestTrustInformation_get_result(PyObject *obj, void *closure)
{
	struct lsa_lsaRQueryForestTrustInformation *object = (struct lsa_lsaRQueryForestTrustInformation *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_lsaRQueryForestTrustInformation_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_lsaRQueryForestTrustInformation *object = (struct lsa_lsaRQueryForestTrustInformation *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_lsaRQueryForestTrustInformation_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_lsaRQueryForestTrustInformation_in_get_handle,
		.set = py_lsa_lsaRQueryForestTrustInformation_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_trusted_domain_name"),
		.get = py_lsa_lsaRQueryForestTrustInformation_in_get_trusted_domain_name,
		.set = py_lsa_lsaRQueryForestTrustInformation_in_set_trusted_domain_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "in_highest_record_type"),
		.get = py_lsa_lsaRQueryForestTrustInformation_in_get_highest_record_type,
		.set = py_lsa_lsaRQueryForestTrustInformation_in_set_highest_record_type,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ForestTrustRecordType")
	},
	{
		.name = discard_const_p(char, "out_forest_trust_info"),
		.get = py_lsa_lsaRQueryForestTrustInformation_out_get_forest_trust_info,
		.set = py_lsa_lsaRQueryForestTrustInformation_out_set_forest_trust_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ForestTrustInformation")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_lsaRQueryForestTrustInformation_get_result,
		.set = py_lsa_lsaRQueryForestTrustInformation_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_lsaRQueryForestTrustInformation_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_lsaRQueryForestTrustInformation, type);
}

static PyObject *py_lsa_lsaRQueryForestTrustInformation_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(73);
}

static PyObject *py_lsa_lsaRQueryForestTrustInformation_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_lsaRQueryForestTrustInformation *object = (struct lsa_lsaRQueryForestTrustInformation *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 74) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_lsaRQueryForestTrustInformation_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[73];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_lsaRQueryForestTrustInformation_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_lsaRQueryForestTrustInformation_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_lsaRQueryForestTrustInformation_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_lsaRQueryForestTrustInformation_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_lsaRQueryForestTrustInformation_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_lsaRQueryForestTrustInformation *object = (struct lsa_lsaRQueryForestTrustInformation *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 74) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_lsaRQueryForestTrustInformation_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[73];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_lsaRQueryForestTrustInformation_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_lsaRQueryForestTrustInformation_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_lsaRQueryForestTrustInformation_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_lsaRQueryForestTrustInformation_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_lsaRQueryForestTrustInformation_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_lsaRQueryForestTrustInformation *object = (struct lsa_lsaRQueryForestTrustInformation *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 74) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_lsaRQueryForestTrustInformation_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[73];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_lsaRQueryForestTrustInformation_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_lsaRQueryForestTrustInformation_ndr_print(py_obj, "lsa_lsaRQueryForestTrustInformation_in", NDR_IN);
}

static PyObject *py_lsa_lsaRQueryForestTrustInformation_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_lsaRQueryForestTrustInformation_ndr_print(py_obj, "lsa_lsaRQueryForestTrustInformation_out", NDR_OUT);
}

static PyMethodDef py_lsa_lsaRQueryForestTrustInformation_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_lsaRQueryForestTrustInformation_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.lsaRQueryForestTrustInformation.opnum() -> 73 (0x49) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_lsaRQueryForestTrustInformation_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_lsaRQueryForestTrustInformation_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_lsaRQueryForestTrustInformation_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_lsaRQueryForestTrustInformation_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_lsaRQueryForestTrustInformation_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_lsaRQueryForestTrustInformation_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_lsaRQueryForestTrustInformation_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.lsaRQueryForestTrustInformation",
	.tp_getset = py_lsa_lsaRQueryForestTrustInformation_getsetters,
	.tp_methods = py_lsa_lsaRQueryForestTrustInformation_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_lsaRQueryForestTrustInformation_new,
};

static bool pack_py_lsa_lsaRQueryForestTrustInformation_args_in(PyObject *args, PyObject *kwargs, struct lsa_lsaRQueryForestTrustInformation *r)
{
	PyObject *py_handle;
	PyObject *py_trusted_domain_name;
	PyObject *py_highest_record_type;
	const char *kwnames[] = {
		"handle", "trusted_domain_name", "highest_record_type", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:lsa_lsaRQueryForestTrustInformation", discard_const_p(char *, kwnames), &py_handle, &py_trusted_domain_name, &py_highest_record_type)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_trusted_domain_name == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.trusted_domain_name");
		return false;
	}
	r->in.trusted_domain_name = talloc_ptrtype(r, r->in.trusted_domain_name);
	if (r->in.trusted_domain_name == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_String_Type, py_trusted_domain_name, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_trusted_domain_name)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.trusted_domain_name = (struct lsa_String *)pytalloc_get_ptr(py_trusted_domain_name);
	if (py_highest_record_type == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.highest_record_type");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.highest_record_type));
		if (PyLong_Check(py_highest_record_type)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_highest_record_type);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.highest_record_type = test_var;
		} else if (PyInt_Check(py_highest_record_type)) {
			long test_var;
			test_var = PyInt_AsLong(py_highest_record_type);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.highest_record_type = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_lsaRQueryForestTrustInformation_args_out(struct lsa_lsaRQueryForestTrustInformation *r)
{
	PyObject *result;
	PyObject *py_forest_trust_info;
	if (*r->out.forest_trust_info == NULL) {
		py_forest_trust_info = Py_None;
		Py_INCREF(py_forest_trust_info);
	} else {
		py_forest_trust_info = pytalloc_reference_ex(&lsa_ForestTrustInformation_Type, *r->out.forest_trust_info, *r->out.forest_trust_info);
	}
	result = py_forest_trust_info;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_lsaRSetForestTrustInformation_in_get_handle(PyObject *obj, void *closure)
{
	struct lsa_lsaRSetForestTrustInformation *object = (struct lsa_lsaRSetForestTrustInformation *)pytalloc_get_ptr(obj);
	PyObject *py_handle;
	py_handle = pytalloc_reference_ex(policy_handle_Type, object->in.handle, object->in.handle);
	return py_handle;
}

static int py_lsa_lsaRSetForestTrustInformation_in_set_handle(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_lsaRSetForestTrustInformation *object = (struct lsa_lsaRSetForestTrustInformation *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.handle));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.handle");
		return -1;
	}
	object->in.handle = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.handle);
	if (object->in.handle == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(policy_handle_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.handle = (struct policy_handle *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_lsaRSetForestTrustInformation_in_get_trusted_domain_name(PyObject *obj, void *closure)
{
	struct lsa_lsaRSetForestTrustInformation *object = (struct lsa_lsaRSetForestTrustInformation *)pytalloc_get_ptr(obj);
	PyObject *py_trusted_domain_name;
	py_trusted_domain_name = pytalloc_reference_ex(&lsa_StringLarge_Type, object->in.trusted_domain_name, object->in.trusted_domain_name);
	return py_trusted_domain_name;
}

static int py_lsa_lsaRSetForestTrustInformation_in_set_trusted_domain_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_lsaRSetForestTrustInformation *object = (struct lsa_lsaRSetForestTrustInformation *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.trusted_domain_name));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.trusted_domain_name");
		return -1;
	}
	object->in.trusted_domain_name = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.trusted_domain_name);
	if (object->in.trusted_domain_name == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_StringLarge_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.trusted_domain_name = (struct lsa_StringLarge *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_lsaRSetForestTrustInformation_in_get_highest_record_type(PyObject *obj, void *closure)
{
	struct lsa_lsaRSetForestTrustInformation *object = (struct lsa_lsaRSetForestTrustInformation *)pytalloc_get_ptr(obj);
	PyObject *py_highest_record_type;
	py_highest_record_type = PyInt_FromLong((uint16_t)object->in.highest_record_type);
	return py_highest_record_type;
}

static int py_lsa_lsaRSetForestTrustInformation_in_set_highest_record_type(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_lsaRSetForestTrustInformation *object = (struct lsa_lsaRSetForestTrustInformation *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.highest_record_type");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.highest_record_type));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.highest_record_type = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.highest_record_type = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_lsaRSetForestTrustInformation_in_get_forest_trust_info(PyObject *obj, void *closure)
{
	struct lsa_lsaRSetForestTrustInformation *object = (struct lsa_lsaRSetForestTrustInformation *)pytalloc_get_ptr(obj);
	PyObject *py_forest_trust_info;
	py_forest_trust_info = pytalloc_reference_ex(&lsa_ForestTrustInformation_Type, object->in.forest_trust_info, object->in.forest_trust_info);
	return py_forest_trust_info;
}

static int py_lsa_lsaRSetForestTrustInformation_in_set_forest_trust_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_lsaRSetForestTrustInformation *object = (struct lsa_lsaRSetForestTrustInformation *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.forest_trust_info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.forest_trust_info");
		return -1;
	}
	object->in.forest_trust_info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.forest_trust_info);
	if (object->in.forest_trust_info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_ForestTrustInformation_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.forest_trust_info = (struct lsa_ForestTrustInformation *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_lsaRSetForestTrustInformation_in_get_check_only(PyObject *obj, void *closure)
{
	struct lsa_lsaRSetForestTrustInformation *object = (struct lsa_lsaRSetForestTrustInformation *)pytalloc_get_ptr(obj);
	PyObject *py_check_only;
	py_check_only = PyInt_FromLong((uint16_t)object->in.check_only);
	return py_check_only;
}

static int py_lsa_lsaRSetForestTrustInformation_in_set_check_only(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_lsaRSetForestTrustInformation *object = (struct lsa_lsaRSetForestTrustInformation *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.check_only");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.check_only));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.check_only = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.check_only = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_lsaRSetForestTrustInformation_out_get_collision_info(PyObject *obj, void *closure)
{
	struct lsa_lsaRSetForestTrustInformation *object = (struct lsa_lsaRSetForestTrustInformation *)pytalloc_get_ptr(obj);
	PyObject *py_collision_info;
	if (*object->out.collision_info == NULL) {
		py_collision_info = Py_None;
		Py_INCREF(py_collision_info);
	} else {
		py_collision_info = pytalloc_reference_ex(&lsa_ForestTrustCollisionInfo_Type, *object->out.collision_info, *object->out.collision_info);
	}
	return py_collision_info;
}

static int py_lsa_lsaRSetForestTrustInformation_out_set_collision_info(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_lsaRSetForestTrustInformation *object = (struct lsa_lsaRSetForestTrustInformation *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.collision_info));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.collision_info");
		return -1;
	}
	object->out.collision_info = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.collision_info);
	if (object->out.collision_info == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.collision_info = NULL;
	} else {
		*object->out.collision_info = NULL;
		PY_CHECK_TYPE(&lsa_ForestTrustCollisionInfo_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		*object->out.collision_info = (struct lsa_ForestTrustCollisionInfo *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_lsaRSetForestTrustInformation_get_result(PyObject *obj, void *closure)
{
	struct lsa_lsaRSetForestTrustInformation *object = (struct lsa_lsaRSetForestTrustInformation *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_lsaRSetForestTrustInformation_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_lsaRSetForestTrustInformation *object = (struct lsa_lsaRSetForestTrustInformation *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_lsaRSetForestTrustInformation_getsetters[] = {
	{
		.name = discard_const_p(char, "in_handle"),
		.get = py_lsa_lsaRSetForestTrustInformation_in_get_handle,
		.set = py_lsa_lsaRSetForestTrustInformation_in_set_handle,
		.doc = discard_const_p(char, "PIDL-generated element of base type policy_handle")
	},
	{
		.name = discard_const_p(char, "in_trusted_domain_name"),
		.get = py_lsa_lsaRSetForestTrustInformation_in_get_trusted_domain_name,
		.set = py_lsa_lsaRSetForestTrustInformation_in_set_trusted_domain_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_StringLarge")
	},
	{
		.name = discard_const_p(char, "in_highest_record_type"),
		.get = py_lsa_lsaRSetForestTrustInformation_in_get_highest_record_type,
		.set = py_lsa_lsaRSetForestTrustInformation_in_set_highest_record_type,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ForestTrustRecordType")
	},
	{
		.name = discard_const_p(char, "in_forest_trust_info"),
		.get = py_lsa_lsaRSetForestTrustInformation_in_get_forest_trust_info,
		.set = py_lsa_lsaRSetForestTrustInformation_in_set_forest_trust_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ForestTrustInformation")
	},
	{
		.name = discard_const_p(char, "in_check_only"),
		.get = py_lsa_lsaRSetForestTrustInformation_in_get_check_only,
		.set = py_lsa_lsaRSetForestTrustInformation_in_set_check_only,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{
		.name = discard_const_p(char, "out_collision_info"),
		.get = py_lsa_lsaRSetForestTrustInformation_out_get_collision_info,
		.set = py_lsa_lsaRSetForestTrustInformation_out_set_collision_info,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ForestTrustCollisionInfo")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_lsaRSetForestTrustInformation_get_result,
		.set = py_lsa_lsaRSetForestTrustInformation_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_lsaRSetForestTrustInformation_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_lsaRSetForestTrustInformation, type);
}

static PyObject *py_lsa_lsaRSetForestTrustInformation_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(74);
}

static PyObject *py_lsa_lsaRSetForestTrustInformation_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_lsaRSetForestTrustInformation *object = (struct lsa_lsaRSetForestTrustInformation *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 75) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_lsaRSetForestTrustInformation_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[74];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_lsaRSetForestTrustInformation_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_lsaRSetForestTrustInformation_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_lsaRSetForestTrustInformation_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_lsaRSetForestTrustInformation_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_lsaRSetForestTrustInformation_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_lsaRSetForestTrustInformation *object = (struct lsa_lsaRSetForestTrustInformation *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 75) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_lsaRSetForestTrustInformation_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[74];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_lsaRSetForestTrustInformation_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_lsaRSetForestTrustInformation_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_lsaRSetForestTrustInformation_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_lsaRSetForestTrustInformation_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_lsaRSetForestTrustInformation_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_lsaRSetForestTrustInformation *object = (struct lsa_lsaRSetForestTrustInformation *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 75) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_lsaRSetForestTrustInformation_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[74];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_lsaRSetForestTrustInformation_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_lsaRSetForestTrustInformation_ndr_print(py_obj, "lsa_lsaRSetForestTrustInformation_in", NDR_IN);
}

static PyObject *py_lsa_lsaRSetForestTrustInformation_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_lsaRSetForestTrustInformation_ndr_print(py_obj, "lsa_lsaRSetForestTrustInformation_out", NDR_OUT);
}

static PyMethodDef py_lsa_lsaRSetForestTrustInformation_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_lsaRSetForestTrustInformation_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.lsaRSetForestTrustInformation.opnum() -> 74 (0x4a) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_lsaRSetForestTrustInformation_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_lsaRSetForestTrustInformation_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_lsaRSetForestTrustInformation_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_lsaRSetForestTrustInformation_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_lsaRSetForestTrustInformation_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_lsaRSetForestTrustInformation_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_lsaRSetForestTrustInformation_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.lsaRSetForestTrustInformation",
	.tp_getset = py_lsa_lsaRSetForestTrustInformation_getsetters,
	.tp_methods = py_lsa_lsaRSetForestTrustInformation_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_lsaRSetForestTrustInformation_new,
};

static bool pack_py_lsa_lsaRSetForestTrustInformation_args_in(PyObject *args, PyObject *kwargs, struct lsa_lsaRSetForestTrustInformation *r)
{
	PyObject *py_handle;
	PyObject *py_trusted_domain_name;
	PyObject *py_highest_record_type;
	PyObject *py_forest_trust_info;
	PyObject *py_check_only;
	const char *kwnames[] = {
		"handle", "trusted_domain_name", "highest_record_type", "forest_trust_info", "check_only", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOOO:lsa_lsaRSetForestTrustInformation", discard_const_p(char *, kwnames), &py_handle, &py_trusted_domain_name, &py_highest_record_type, &py_forest_trust_info, &py_check_only)) {
		return false;
	}

	if (py_handle == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.handle");
		return false;
	}
	r->in.handle = talloc_ptrtype(r, r->in.handle);
	if (r->in.handle == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(policy_handle_Type, py_handle, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.handle = (struct policy_handle *)pytalloc_get_ptr(py_handle);
	if (py_trusted_domain_name == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.trusted_domain_name");
		return false;
	}
	r->in.trusted_domain_name = talloc_ptrtype(r, r->in.trusted_domain_name);
	if (r->in.trusted_domain_name == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_StringLarge_Type, py_trusted_domain_name, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_trusted_domain_name)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.trusted_domain_name = (struct lsa_StringLarge *)pytalloc_get_ptr(py_trusted_domain_name);
	if (py_highest_record_type == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.highest_record_type");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.highest_record_type));
		if (PyLong_Check(py_highest_record_type)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_highest_record_type);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.highest_record_type = test_var;
		} else if (PyInt_Check(py_highest_record_type)) {
			long test_var;
			test_var = PyInt_AsLong(py_highest_record_type);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.highest_record_type = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_forest_trust_info == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.forest_trust_info");
		return false;
	}
	r->in.forest_trust_info = talloc_ptrtype(r, r->in.forest_trust_info);
	if (r->in.forest_trust_info == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_ForestTrustInformation_Type, py_forest_trust_info, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_forest_trust_info)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.forest_trust_info = (struct lsa_ForestTrustInformation *)pytalloc_get_ptr(py_forest_trust_info);
	if (py_check_only == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.check_only");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.check_only));
		if (PyLong_Check(py_check_only)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_check_only);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.check_only = test_var;
		} else if (PyInt_Check(py_check_only)) {
			long test_var;
			test_var = PyInt_AsLong(py_check_only);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.check_only = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_lsaRSetForestTrustInformation_args_out(struct lsa_lsaRSetForestTrustInformation *r)
{
	PyObject *result;
	PyObject *py_collision_info;
	if (*r->out.collision_info == NULL) {
		py_collision_info = Py_None;
		Py_INCREF(py_collision_info);
	} else {
		py_collision_info = pytalloc_reference_ex(&lsa_ForestTrustCollisionInfo_Type, *r->out.collision_info, *r->out.collision_info);
	}
	result = py_collision_info;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_LookupSids3_in_get_sids(PyObject *obj, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(obj);
	PyObject *py_sids;
	py_sids = pytalloc_reference_ex(&lsa_SidArray_Type, object->in.sids, object->in.sids);
	return py_sids;
}

static int py_lsa_LookupSids3_in_set_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.sids));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sids");
		return -1;
	}
	object->in.sids = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.sids);
	if (object->in.sids == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_SidArray_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.sids = (struct lsa_SidArray *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupSids3_out_get_domains(PyObject *obj, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(obj);
	PyObject *py_domains;
	if (*object->out.domains == NULL) {
		py_domains = Py_None;
		Py_INCREF(py_domains);
	} else {
		py_domains = pytalloc_reference_ex(&lsa_RefDomainList_Type, *object->out.domains, *object->out.domains);
	}
	return py_domains;
}

static int py_lsa_LookupSids3_out_set_domains(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.domains));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.domains");
		return -1;
	}
	object->out.domains = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.domains);
	if (object->out.domains == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.domains = NULL;
	} else {
		*object->out.domains = NULL;
		PY_CHECK_TYPE(&lsa_RefDomainList_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		*object->out.domains = (struct lsa_RefDomainList *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_LookupSids3_in_get_names(PyObject *obj, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(obj);
	PyObject *py_names;
	py_names = pytalloc_reference_ex(&lsa_TransNameArray2_Type, object->in.names, object->in.names);
	return py_names;
}

static int py_lsa_LookupSids3_in_set_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.names));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.names");
		return -1;
	}
	object->in.names = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.names);
	if (object->in.names == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TransNameArray2_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.names = (struct lsa_TransNameArray2 *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupSids3_out_get_names(PyObject *obj, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(obj);
	PyObject *py_names;
	py_names = pytalloc_reference_ex(&lsa_TransNameArray2_Type, object->out.names, object->out.names);
	return py_names;
}

static int py_lsa_LookupSids3_out_set_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.names));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.names");
		return -1;
	}
	object->out.names = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.names);
	if (object->out.names == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TransNameArray2_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.names = (struct lsa_TransNameArray2 *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupSids3_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_LookupSids3_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupSids3_in_get_count(PyObject *obj, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->in.count);
	return py_count;
}

static int py_lsa_LookupSids3_in_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.count));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.count");
		return -1;
	}
	object->in.count = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.count);
	if (object->in.count == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->in.count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupSids3_out_get_count(PyObject *obj, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->out.count);
	return py_count;
}

static int py_lsa_LookupSids3_out_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.count));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.count");
		return -1;
	}
	object->out.count = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.count);
	if (object->out.count == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->out.count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupSids3_in_get_lookup_options(PyObject *obj, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(obj);
	PyObject *py_lookup_options;
	py_lookup_options = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.lookup_options);
	return py_lookup_options;
}

static int py_lsa_LookupSids3_in_set_lookup_options(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.lookup_options");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.lookup_options));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.lookup_options = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.lookup_options = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupSids3_in_get_client_revision(PyObject *obj, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(obj);
	PyObject *py_client_revision;
	py_client_revision = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.client_revision);
	return py_client_revision;
}

static int py_lsa_LookupSids3_in_set_client_revision(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.client_revision");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.client_revision));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.client_revision = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.client_revision = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupSids3_get_result(PyObject *obj, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_LookupSids3_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_LookupSids3_getsetters[] = {
	{
		.name = discard_const_p(char, "in_sids"),
		.get = py_lsa_LookupSids3_in_get_sids,
		.set = py_lsa_LookupSids3_in_set_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_SidArray")
	},
	{
		.name = discard_const_p(char, "out_domains"),
		.get = py_lsa_LookupSids3_out_get_domains,
		.set = py_lsa_LookupSids3_out_set_domains,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_RefDomainList")
	},
	{
		.name = discard_const_p(char, "in_names"),
		.get = py_lsa_LookupSids3_in_get_names,
		.set = py_lsa_LookupSids3_in_set_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TransNameArray2")
	},
	{
		.name = discard_const_p(char, "out_names"),
		.get = py_lsa_LookupSids3_out_get_names,
		.set = py_lsa_LookupSids3_out_set_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TransNameArray2")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_LookupSids3_in_get_level,
		.set = py_lsa_LookupSids3_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_LookupNamesLevel")
	},
	{
		.name = discard_const_p(char, "in_count"),
		.get = py_lsa_LookupSids3_in_get_count,
		.set = py_lsa_LookupSids3_in_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "out_count"),
		.get = py_lsa_LookupSids3_out_get_count,
		.set = py_lsa_LookupSids3_out_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "in_lookup_options"),
		.get = py_lsa_LookupSids3_in_get_lookup_options,
		.set = py_lsa_LookupSids3_in_set_lookup_options,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_LookupOptions")
	},
	{
		.name = discard_const_p(char, "in_client_revision"),
		.get = py_lsa_LookupSids3_in_get_client_revision,
		.set = py_lsa_LookupSids3_in_set_client_revision,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ClientRevision")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_LookupSids3_get_result,
		.set = py_lsa_LookupSids3_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_LookupSids3_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_LookupSids3, type);
}

static PyObject *py_lsa_LookupSids3_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(76);
}

static PyObject *py_lsa_LookupSids3_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 77) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupSids3_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[76];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_LookupSids3_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupSids3_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_LookupSids3_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupSids3_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_LookupSids3_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 77) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupSids3_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[76];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_LookupSids3_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupSids3_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupSids3_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupSids3_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupSids3_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupSids3 *object = (struct lsa_LookupSids3 *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 77) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupSids3_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[76];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_LookupSids3_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_LookupSids3_ndr_print(py_obj, "lsa_LookupSids3_in", NDR_IN);
}

static PyObject *py_lsa_LookupSids3_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_LookupSids3_ndr_print(py_obj, "lsa_LookupSids3_out", NDR_OUT);
}

static PyMethodDef py_lsa_LookupSids3_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_LookupSids3_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.LookupSids3.opnum() -> 76 (0x4c) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_LookupSids3_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_LookupSids3_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_LookupSids3_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_LookupSids3_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_LookupSids3_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_LookupSids3_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_LookupSids3_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.LookupSids3",
	.tp_getset = py_lsa_LookupSids3_getsetters,
	.tp_methods = py_lsa_LookupSids3_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_LookupSids3_new,
};

static bool pack_py_lsa_LookupSids3_args_in(PyObject *args, PyObject *kwargs, struct lsa_LookupSids3 *r)
{
	PyObject *py_sids;
	PyObject *py_names;
	PyObject *py_level;
	PyObject *py_count;
	PyObject *py_lookup_options;
	PyObject *py_client_revision;
	const char *kwnames[] = {
		"sids", "names", "level", "count", "lookup_options", "client_revision", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOOOO:lsa_LookupSids3", discard_const_p(char *, kwnames), &py_sids, &py_names, &py_level, &py_count, &py_lookup_options, &py_client_revision)) {
		return false;
	}

	if (py_sids == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sids");
		return false;
	}
	r->in.sids = talloc_ptrtype(r, r->in.sids);
	if (r->in.sids == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_SidArray_Type, py_sids, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_sids)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.sids = (struct lsa_SidArray *)pytalloc_get_ptr(py_sids);
	if (py_names == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.names");
		return false;
	}
	r->in.names = talloc_ptrtype(r, r->in.names);
	if (r->in.names == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_TransNameArray2_Type, py_names, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_names)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.names = (struct lsa_TransNameArray2 *)pytalloc_get_ptr(py_names);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_count == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.count");
		return false;
	}
	r->in.count = talloc_ptrtype(r, r->in.count);
	if (r->in.count == NULL) {
		PyErr_NoMemory();
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*r->in.count));
		if (PyLong_Check(py_count)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_count);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.count = test_var;
		} else if (PyInt_Check(py_count)) {
			long test_var;
			test_var = PyInt_AsLong(py_count);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_lookup_options == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.lookup_options");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.lookup_options));
		if (PyLong_Check(py_lookup_options)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_lookup_options);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.lookup_options = test_var;
		} else if (PyInt_Check(py_lookup_options)) {
			long test_var;
			test_var = PyInt_AsLong(py_lookup_options);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.lookup_options = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_client_revision == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.client_revision");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.client_revision));
		if (PyLong_Check(py_client_revision)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_client_revision);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.client_revision = test_var;
		} else if (PyInt_Check(py_client_revision)) {
			long test_var;
			test_var = PyInt_AsLong(py_client_revision);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.client_revision = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_LookupSids3_args_out(struct lsa_LookupSids3 *r)
{
	PyObject *result;
	PyObject *py_domains;
	PyObject *py_names;
	PyObject *py_count;
	result = PyTuple_New(3);
	if (*r->out.domains == NULL) {
		py_domains = Py_None;
		Py_INCREF(py_domains);
	} else {
		py_domains = pytalloc_reference_ex(&lsa_RefDomainList_Type, *r->out.domains, *r->out.domains);
	}
	PyTuple_SetItem(result, 0, py_domains);
	py_names = pytalloc_reference_ex(&lsa_TransNameArray2_Type, r->out.names, r->out.names);
	PyTuple_SetItem(result, 1, py_names);
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*r->out.count);
	PyTuple_SetItem(result, 2, py_count);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}


static PyObject *py_lsa_LookupNames4_in_get_num_names(PyObject *obj, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(obj);
	PyObject *py_num_names;
	py_num_names = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.num_names);
	return py_num_names;
}

static int py_lsa_LookupNames4_in_set_num_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.num_names");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.num_names));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.num_names = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.num_names = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames4_in_get_names(PyObject *obj, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(obj);
	PyObject *py_names;
	py_names = PyList_New(object->in.num_names);
	if (py_names == NULL) {
		return NULL;
	}
	{
		int names_cntr_0;
		for (names_cntr_0 = 0; names_cntr_0 < (object->in.num_names); names_cntr_0++) {
			PyObject *py_names_0;
			py_names_0 = pytalloc_reference_ex(&lsa_String_Type, object->in.names, &object->in.names[names_cntr_0]);
			PyList_SetItem(py_names, names_cntr_0, py_names_0);
		}
	}
	return py_names;
}

static int py_lsa_LookupNames4_in_set_names(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.names");
		return -1;
	}
	PY_CHECK_TYPE(&PyList_Type, value, return -1;);
	{
		int names_cntr_0;
		object->in.names = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.names, PyList_GET_SIZE(value));
		if (!object->in.names) { return -1;; }
		talloc_set_name_const(object->in.names, "ARRAY: object->in.names");
		for (names_cntr_0 = 0; names_cntr_0 < PyList_GET_SIZE(value); names_cntr_0++) {
			if (PyList_GET_ITEM(value, names_cntr_0) == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.names[names_cntr_0]");
				return -1;
			}
			PY_CHECK_TYPE(&lsa_String_Type, PyList_GET_ITEM(value, names_cntr_0), return -1;);
			if (talloc_reference(object->in.names, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, names_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->in.names[names_cntr_0] = *(struct lsa_String *)pytalloc_get_ptr(PyList_GET_ITEM(value, names_cntr_0));
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames4_out_get_domains(PyObject *obj, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(obj);
	PyObject *py_domains;
	if (*object->out.domains == NULL) {
		py_domains = Py_None;
		Py_INCREF(py_domains);
	} else {
		py_domains = pytalloc_reference_ex(&lsa_RefDomainList_Type, *object->out.domains, *object->out.domains);
	}
	return py_domains;
}

static int py_lsa_LookupNames4_out_set_domains(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.domains));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.domains");
		return -1;
	}
	object->out.domains = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.domains);
	if (object->out.domains == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (value == Py_None) {
		*object->out.domains = NULL;
	} else {
		*object->out.domains = NULL;
		PY_CHECK_TYPE(&lsa_RefDomainList_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		*object->out.domains = (struct lsa_RefDomainList *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_lsa_LookupNames4_in_get_sids(PyObject *obj, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(obj);
	PyObject *py_sids;
	py_sids = pytalloc_reference_ex(&lsa_TransSidArray3_Type, object->in.sids, object->in.sids);
	return py_sids;
}

static int py_lsa_LookupNames4_in_set_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.sids));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.sids");
		return -1;
	}
	object->in.sids = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.sids);
	if (object->in.sids == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TransSidArray3_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->in.sids = (struct lsa_TransSidArray3 *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupNames4_out_get_sids(PyObject *obj, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(obj);
	PyObject *py_sids;
	py_sids = pytalloc_reference_ex(&lsa_TransSidArray3_Type, object->out.sids, object->out.sids);
	return py_sids;
}

static int py_lsa_LookupNames4_out_set_sids(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.sids));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.sids");
		return -1;
	}
	object->out.sids = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.sids);
	if (object->out.sids == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	PY_CHECK_TYPE(&lsa_TransSidArray3_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->out.sids = (struct lsa_TransSidArray3 *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_lsa_LookupNames4_in_get_level(PyObject *obj, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(obj);
	PyObject *py_level;
	py_level = PyInt_FromLong((uint16_t)object->in.level);
	return py_level;
}

static int py_lsa_LookupNames4_in_set_level(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.level");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.level));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames4_in_get_count(PyObject *obj, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->in.count);
	return py_count;
}

static int py_lsa_LookupNames4_in_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->in.count));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.count");
		return -1;
	}
	object->in.count = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->in.count);
	if (object->in.count == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->in.count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->in.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames4_out_get_count(PyObject *obj, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(obj);
	PyObject *py_count;
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*object->out.count);
	return py_count;
}

static int py_lsa_LookupNames4_out_set_count(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->out.count));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.count");
		return -1;
	}
	object->out.count = talloc_ptrtype(pytalloc_get_mem_ctx(py_obj), object->out.count);
	if (object->out.count == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*object->out.count));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.count = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			*object->out.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames4_in_get_lookup_options(PyObject *obj, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(obj);
	PyObject *py_lookup_options;
	py_lookup_options = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.lookup_options);
	return py_lookup_options;
}

static int py_lsa_LookupNames4_in_set_lookup_options(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.lookup_options");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.lookup_options));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.lookup_options = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.lookup_options = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames4_in_get_client_revision(PyObject *obj, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(obj);
	PyObject *py_client_revision;
	py_client_revision = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->in.client_revision);
	return py_client_revision;
}

static int py_lsa_LookupNames4_in_set_client_revision(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->in.client_revision");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->in.client_revision));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.client_revision = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->in.client_revision = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_lsa_LookupNames4_get_result(PyObject *obj, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(obj);
	PyObject *py_result;
	py_result = PyErr_FromNTSTATUS(object->out.result);
	return py_result;
}

static int py_lsa_LookupNames4_set_result(PyObject *py_obj, PyObject *value, void *closure)
{
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->out.result");
		return -1;
	}
	object->out.result = NT_STATUS(PyInt_AsLong(value));
	return 0;
}

static PyGetSetDef py_lsa_LookupNames4_getsetters[] = {
	{
		.name = discard_const_p(char, "in_num_names"),
		.get = py_lsa_LookupNames4_in_get_num_names,
		.set = py_lsa_LookupNames4_in_set_num_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "in_names"),
		.get = py_lsa_LookupNames4_in_get_names,
		.set = py_lsa_LookupNames4_in_set_names,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_String")
	},
	{
		.name = discard_const_p(char, "out_domains"),
		.get = py_lsa_LookupNames4_out_get_domains,
		.set = py_lsa_LookupNames4_out_set_domains,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_RefDomainList")
	},
	{
		.name = discard_const_p(char, "in_sids"),
		.get = py_lsa_LookupNames4_in_get_sids,
		.set = py_lsa_LookupNames4_in_set_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TransSidArray3")
	},
	{
		.name = discard_const_p(char, "out_sids"),
		.get = py_lsa_LookupNames4_out_get_sids,
		.set = py_lsa_LookupNames4_out_set_sids,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_TransSidArray3")
	},
	{
		.name = discard_const_p(char, "in_level"),
		.get = py_lsa_LookupNames4_in_get_level,
		.set = py_lsa_LookupNames4_in_set_level,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_LookupNamesLevel")
	},
	{
		.name = discard_const_p(char, "in_count"),
		.get = py_lsa_LookupNames4_in_get_count,
		.set = py_lsa_LookupNames4_in_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "out_count"),
		.get = py_lsa_LookupNames4_out_get_count,
		.set = py_lsa_LookupNames4_out_set_count,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "in_lookup_options"),
		.get = py_lsa_LookupNames4_in_get_lookup_options,
		.set = py_lsa_LookupNames4_in_set_lookup_options,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_LookupOptions")
	},
	{
		.name = discard_const_p(char, "in_client_revision"),
		.get = py_lsa_LookupNames4_in_get_client_revision,
		.set = py_lsa_LookupNames4_in_set_client_revision,
		.doc = discard_const_p(char, "PIDL-generated element of base type lsa_ClientRevision")
	},
	{
		.name = discard_const_p(char, "result"),
		.get = py_lsa_LookupNames4_get_result,
		.set = py_lsa_LookupNames4_set_result,
		.doc = discard_const_p(char, "PIDL-generated element of type NTSTATUS")
	},
	{ .name = NULL }
};

static PyObject *py_lsa_LookupNames4_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct lsa_LookupNames4, type);
}

static PyObject *py_lsa_LookupNames4_ndr_opnum(PyTypeObject *type)
{


	return PyInt_FromLong(77);
}

static PyObject *py_lsa_LookupNames4_ndr_pack(PyObject *py_obj, int ndr_inout_flags, uint32_t ndr_push_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	struct ndr_push *push = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 78) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupNames4_ndr_pack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[77];

	push = ndr_push_init_ctx(pytalloc_get_mem_ctx(py_obj));
	if (push == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	push->flags |= ndr_push_flags;

	err = call->ndr_push(push, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(push);
		PyErr_SetNdrError(err);
		return NULL;
	}
	blob = ndr_push_blob(push);
	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(push);
	return ret;
}

static PyObject *py_lsa_LookupNames4_ndr_pack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_in__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupNames4_ndr_pack(py_obj, NDR_IN, ndr_push_flags);
}

static PyObject *py_lsa_LookupNames4_ndr_pack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "bigendian", "ndr64", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_push_flags = 0;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:__ndr_pack_out__",
		discard_const_p(char *, kwnames),
		&bigendian_obj,
		&ndr64_obj)) {
		return NULL;
	}

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_push_flags |= LIBNDR_FLAG_NDR64;
	}

	return py_lsa_LookupNames4_ndr_pack(py_obj, NDR_OUT, ndr_push_flags);
}

static PyObject *py_lsa_LookupNames4_ndr_unpack(PyObject *py_obj, const DATA_BLOB *blob, int ndr_inout_flags, uint32_t ndr_pull_flags, bool allow_remaining)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(py_obj);
	struct ndr_pull *pull = NULL;
	enum ndr_err_code err;

	if (ndr_table_lsarpc.num_calls < 78) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupNames4_ndr_unpack");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[77];

	pull = ndr_pull_init_blob(blob, object);
	if (pull == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}

	pull->flags |= ndr_pull_flags;

	err = call->ndr_pull(pull, ndr_inout_flags, object);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(pull);
		PyErr_SetNdrError(err);
		return NULL;
	}
	if (!allow_remaining) {
		uint32_t highest_ofs;

		if (pull->offset > pull->relative_highest_offset) {
			highest_ofs = pull->offset;
		} else {
			highest_ofs = pull->relative_highest_offset;
		}
		if (highest_ofs < pull->data_size) {
			err = ndr_pull_error(pull, NDR_ERR_UNREAD_BYTES,
				"not all bytes consumed ofs[%u] size[%u]",
				highest_ofs, pull->data_size);
			TALLOC_FREE(pull);
			PyErr_SetNdrError(err);
			return NULL;
		}
	}

	TALLOC_FREE(pull);
	Py_RETURN_NONE;
}

static PyObject *py_lsa_LookupNames4_ndr_unpack_in(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_in__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupNames4_ndr_unpack(py_obj, &blob, NDR_IN, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupNames4_ndr_unpack_out(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	const char * const kwnames[] = { "data_blob", "bigendian", "ndr64", "allow_remaining", NULL };
	PyObject *bigendian_obj = NULL;
	PyObject *ndr64_obj = NULL;
	uint32_t ndr_pull_flags = LIBNDR_FLAG_REF_ALLOC;
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|OOO:__ndr_unpack_out__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&bigendian_obj,
		&ndr64_obj,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (bigendian_obj && PyObject_IsTrue(bigendian_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	if (ndr64_obj && PyObject_IsTrue(ndr64_obj)) {
		ndr_pull_flags |= LIBNDR_FLAG_NDR64;
	}

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	return py_lsa_LookupNames4_ndr_unpack(py_obj, &blob, NDR_OUT, ndr_pull_flags, allow_remaining);
}

static PyObject *py_lsa_LookupNames4_ndr_print(PyObject *py_obj, const char *name, int ndr_inout_flags)
{
	const struct ndr_interface_call *call = NULL;
	struct lsa_LookupNames4 *object = (struct lsa_LookupNames4 *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	if (ndr_table_lsarpc.num_calls < 78) {
		PyErr_SetString(PyExc_TypeError, "Internal Error, ndr_interface_call missing for py_lsa_LookupNames4_ndr_print");
		return NULL;
	}
	call = &ndr_table_lsarpc.calls[77];

	retstr = ndr_print_function_string(pytalloc_get_mem_ctx(py_obj), call->ndr_print, name, ndr_inout_flags, object);
	ret = PyStr_FromString(retstr);
	TALLOC_FREE(retstr);

	return ret;
}

static PyObject *py_lsa_LookupNames4_ndr_print_in(PyObject *py_obj)
{
	return py_lsa_LookupNames4_ndr_print(py_obj, "lsa_LookupNames4_in", NDR_IN);
}

static PyObject *py_lsa_LookupNames4_ndr_print_out(PyObject *py_obj)
{
	return py_lsa_LookupNames4_ndr_print(py_obj, "lsa_LookupNames4_out", NDR_OUT);
}

static PyMethodDef py_lsa_LookupNames4_methods[] = {
	{ "opnum", (PyCFunction)py_lsa_LookupNames4_ndr_opnum, METH_NOARGS|METH_CLASS,
		"lsa.LookupNames4.opnum() -> 77 (0x4d) " },
	{ "__ndr_pack_in__", (PyCFunction)py_lsa_LookupNames4_ndr_pack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_in(object, bigendian=False, ndr64=False) -> blob\nNDR pack input" },
	{ "__ndr_pack_out__", (PyCFunction)py_lsa_LookupNames4_ndr_pack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_pack_out(object, bigendian=False, ndr64=False) -> blob\nNDR pack output" },
	{ "__ndr_unpack_in__", (PyCFunction)py_lsa_LookupNames4_ndr_unpack_in, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_in(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack input" },
	{ "__ndr_unpack_out__", (PyCFunction)py_lsa_LookupNames4_ndr_unpack_out, METH_VARARGS|METH_KEYWORDS,
		"S.ndr_unpack_out(class, blob, bigendian=False, ndr64=False, allow_remaining=False) -> None\nNDR unpack output" },
	{ "__ndr_print_in__", (PyCFunction)py_lsa_LookupNames4_ndr_print_in, METH_NOARGS, "S.ndr_print_in(object) -> None\nNDR print input" },
	{ "__ndr_print_out__", (PyCFunction)py_lsa_LookupNames4_ndr_print_out, METH_NOARGS, "S.ndr_print_out(object) -> None\nNDR print output" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject lsa_LookupNames4_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.LookupNames4",
	.tp_getset = py_lsa_LookupNames4_getsetters,
	.tp_methods = py_lsa_LookupNames4_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_lsa_LookupNames4_new,
};

static bool pack_py_lsa_LookupNames4_args_in(PyObject *args, PyObject *kwargs, struct lsa_LookupNames4 *r)
{
	PyObject *py_names;
	PyObject *py_sids;
	PyObject *py_level;
	PyObject *py_count;
	PyObject *py_lookup_options;
	PyObject *py_client_revision;
	const char *kwnames[] = {
		"names", "sids", "level", "count", "lookup_options", "client_revision", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOOOO:lsa_LookupNames4", discard_const_p(char *, kwnames), &py_names, &py_sids, &py_level, &py_count, &py_lookup_options, &py_client_revision)) {
		return false;
	}

	PY_CHECK_TYPE(&PyList_Type, py_names, return false;);
	r->in.num_names = PyList_GET_SIZE(py_names);
	if (py_names == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.names");
		return false;
	}
	PY_CHECK_TYPE(&PyList_Type, py_names, return false;);
	{
		int names_cntr_0;
		r->in.names = talloc_array_ptrtype(r, r->in.names, PyList_GET_SIZE(py_names));
		if (!r->in.names) { return false;; }
		talloc_set_name_const(r->in.names, "ARRAY: r->in.names");
		for (names_cntr_0 = 0; names_cntr_0 < PyList_GET_SIZE(py_names); names_cntr_0++) {
			if (PyList_GET_ITEM(py_names, names_cntr_0) == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.names[names_cntr_0]");
				return false;
			}
			PY_CHECK_TYPE(&lsa_String_Type, PyList_GET_ITEM(py_names, names_cntr_0), return false;);
			if (talloc_reference(r->in.names, pytalloc_get_mem_ctx(PyList_GET_ITEM(py_names, names_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return false;
			}
			r->in.names[names_cntr_0] = *(struct lsa_String *)pytalloc_get_ptr(PyList_GET_ITEM(py_names, names_cntr_0));
		}
	}
	if (py_sids == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.sids");
		return false;
	}
	r->in.sids = talloc_ptrtype(r, r->in.sids);
	if (r->in.sids == NULL) {
		PyErr_NoMemory();
		return false;
	}
	PY_CHECK_TYPE(&lsa_TransSidArray3_Type, py_sids, return false;);
	if (talloc_reference(r, pytalloc_get_mem_ctx(py_sids)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.sids = (struct lsa_TransSidArray3 *)pytalloc_get_ptr(py_sids);
	if (py_level == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.level");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.level));
		if (PyLong_Check(py_level)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_level);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else if (PyInt_Check(py_level)) {
			long test_var;
			test_var = PyInt_AsLong(py_level);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.level = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_count == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.count");
		return false;
	}
	r->in.count = talloc_ptrtype(r, r->in.count);
	if (r->in.count == NULL) {
		PyErr_NoMemory();
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(*r->in.count));
		if (PyLong_Check(py_count)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_count);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.count = test_var;
		} else if (PyInt_Check(py_count)) {
			long test_var;
			test_var = PyInt_AsLong(py_count);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			*r->in.count = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_lookup_options == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.lookup_options");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.lookup_options));
		if (PyLong_Check(py_lookup_options)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_lookup_options);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.lookup_options = test_var;
		} else if (PyInt_Check(py_lookup_options)) {
			long test_var;
			test_var = PyInt_AsLong(py_lookup_options);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.lookup_options = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	if (py_client_revision == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct r->in.client_revision");
		return false;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(r->in.client_revision));
		if (PyLong_Check(py_client_revision)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(py_client_revision);
			if (PyErr_Occurred() != NULL) {
				return false;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.client_revision = test_var;
		} else if (PyInt_Check(py_client_revision)) {
			long test_var;
			test_var = PyInt_AsLong(py_client_revision);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return false;
			}
			r->in.client_revision = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return false;
		}
	}
	return true;
}

static PyObject *unpack_py_lsa_LookupNames4_args_out(struct lsa_LookupNames4 *r)
{
	PyObject *result;
	PyObject *py_domains;
	PyObject *py_sids;
	PyObject *py_count;
	result = PyTuple_New(3);
	if (*r->out.domains == NULL) {
		py_domains = Py_None;
		Py_INCREF(py_domains);
	} else {
		py_domains = pytalloc_reference_ex(&lsa_RefDomainList_Type, *r->out.domains, *r->out.domains);
	}
	PyTuple_SetItem(result, 0, py_domains);
	py_sids = pytalloc_reference_ex(&lsa_TransSidArray3_Type, r->out.sids, r->out.sids);
	PyTuple_SetItem(result, 1, py_sids);
	py_count = ndr_PyLong_FromUnsignedLongLong((uint32_t)*r->out.count);
	PyTuple_SetItem(result, 2, py_count);
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}

const struct PyNdrRpcMethodDef py_ndr_lsarpc_methods[] = {
	{ "Close", "S.Close(handle) -> handle", (py_dcerpc_call_fn)dcerpc_lsa_Close_r, (py_data_pack_fn)pack_py_lsa_Close_args_in, (py_data_unpack_fn)unpack_py_lsa_Close_args_out, 0, &ndr_table_lsarpc },
	{ "Delete", "S.Delete(handle) -> None", (py_dcerpc_call_fn)dcerpc_lsa_Delete_r, (py_data_pack_fn)pack_py_lsa_Delete_args_in, (py_data_unpack_fn)unpack_py_lsa_Delete_args_out, 1, &ndr_table_lsarpc },
	{ "EnumPrivs", "S.EnumPrivs(handle, resume_handle, max_count) -> (resume_handle, privs)", (py_dcerpc_call_fn)dcerpc_lsa_EnumPrivs_r, (py_data_pack_fn)pack_py_lsa_EnumPrivs_args_in, (py_data_unpack_fn)unpack_py_lsa_EnumPrivs_args_out, 2, &ndr_table_lsarpc },
	{ "QuerySecurity", "S.QuerySecurity(handle, sec_info) -> sdbuf", (py_dcerpc_call_fn)dcerpc_lsa_QuerySecurity_r, (py_data_pack_fn)pack_py_lsa_QuerySecurity_args_in, (py_data_unpack_fn)unpack_py_lsa_QuerySecurity_args_out, 3, &ndr_table_lsarpc },
	{ "SetSecObj", "S.SetSecObj(handle, sec_info, sdbuf) -> None", (py_dcerpc_call_fn)dcerpc_lsa_SetSecObj_r, (py_data_pack_fn)pack_py_lsa_SetSecObj_args_in, (py_data_unpack_fn)unpack_py_lsa_SetSecObj_args_out, 4, &ndr_table_lsarpc },
	{ "OpenPolicy", "S.OpenPolicy(system_name, attr, access_mask) -> handle", (py_dcerpc_call_fn)dcerpc_lsa_OpenPolicy_r, (py_data_pack_fn)pack_py_lsa_OpenPolicy_args_in, (py_data_unpack_fn)unpack_py_lsa_OpenPolicy_args_out, 6, &ndr_table_lsarpc },
	{ "QueryInfoPolicy", "S.QueryInfoPolicy(handle, level) -> info", (py_dcerpc_call_fn)dcerpc_lsa_QueryInfoPolicy_r, (py_data_pack_fn)pack_py_lsa_QueryInfoPolicy_args_in, (py_data_unpack_fn)unpack_py_lsa_QueryInfoPolicy_args_out, 7, &ndr_table_lsarpc },
	{ "SetInfoPolicy", "S.SetInfoPolicy(handle, level, info) -> None", (py_dcerpc_call_fn)dcerpc_lsa_SetInfoPolicy_r, (py_data_pack_fn)pack_py_lsa_SetInfoPolicy_args_in, (py_data_unpack_fn)unpack_py_lsa_SetInfoPolicy_args_out, 8, &ndr_table_lsarpc },
	{ "CreateAccount", "S.CreateAccount(handle, sid, access_mask) -> acct_handle", (py_dcerpc_call_fn)dcerpc_lsa_CreateAccount_r, (py_data_pack_fn)pack_py_lsa_CreateAccount_args_in, (py_data_unpack_fn)unpack_py_lsa_CreateAccount_args_out, 10, &ndr_table_lsarpc },
	{ "EnumAccounts", "S.EnumAccounts(handle, resume_handle, num_entries) -> (resume_handle, sids)", (py_dcerpc_call_fn)dcerpc_lsa_EnumAccounts_r, (py_data_pack_fn)pack_py_lsa_EnumAccounts_args_in, (py_data_unpack_fn)unpack_py_lsa_EnumAccounts_args_out, 11, &ndr_table_lsarpc },
	{ "CreateTrustedDomain", "S.CreateTrustedDomain(policy_handle, info, access_mask) -> trustdom_handle", (py_dcerpc_call_fn)dcerpc_lsa_CreateTrustedDomain_r, (py_data_pack_fn)pack_py_lsa_CreateTrustedDomain_args_in, (py_data_unpack_fn)unpack_py_lsa_CreateTrustedDomain_args_out, 12, &ndr_table_lsarpc },
	{ "EnumTrustDom", "S.EnumTrustDom(handle, resume_handle, max_size) -> (resume_handle, domains)", (py_dcerpc_call_fn)dcerpc_lsa_EnumTrustDom_r, (py_data_pack_fn)pack_py_lsa_EnumTrustDom_args_in, (py_data_unpack_fn)unpack_py_lsa_EnumTrustDom_args_out, 13, &ndr_table_lsarpc },
	{ "LookupNames", "S.LookupNames(handle, names, sids, level, count) -> (domains, sids, count)", (py_dcerpc_call_fn)dcerpc_lsa_LookupNames_r, (py_data_pack_fn)pack_py_lsa_LookupNames_args_in, (py_data_unpack_fn)unpack_py_lsa_LookupNames_args_out, 14, &ndr_table_lsarpc },
	{ "LookupSids", "S.LookupSids(handle, sids, names, level, count) -> (domains, names, count)", (py_dcerpc_call_fn)dcerpc_lsa_LookupSids_r, (py_data_pack_fn)pack_py_lsa_LookupSids_args_in, (py_data_unpack_fn)unpack_py_lsa_LookupSids_args_out, 15, &ndr_table_lsarpc },
	{ "CreateSecret", "S.CreateSecret(handle, name, access_mask) -> sec_handle", (py_dcerpc_call_fn)dcerpc_lsa_CreateSecret_r, (py_data_pack_fn)pack_py_lsa_CreateSecret_args_in, (py_data_unpack_fn)unpack_py_lsa_CreateSecret_args_out, 16, &ndr_table_lsarpc },
	{ "OpenAccount", "S.OpenAccount(handle, sid, access_mask) -> acct_handle", (py_dcerpc_call_fn)dcerpc_lsa_OpenAccount_r, (py_data_pack_fn)pack_py_lsa_OpenAccount_args_in, (py_data_unpack_fn)unpack_py_lsa_OpenAccount_args_out, 17, &ndr_table_lsarpc },
	{ "EnumPrivsAccount", "S.EnumPrivsAccount(handle) -> privs", (py_dcerpc_call_fn)dcerpc_lsa_EnumPrivsAccount_r, (py_data_pack_fn)pack_py_lsa_EnumPrivsAccount_args_in, (py_data_unpack_fn)unpack_py_lsa_EnumPrivsAccount_args_out, 18, &ndr_table_lsarpc },
	{ "AddPrivilegesToAccount", "S.AddPrivilegesToAccount(handle, privs) -> None", (py_dcerpc_call_fn)dcerpc_lsa_AddPrivilegesToAccount_r, (py_data_pack_fn)pack_py_lsa_AddPrivilegesToAccount_args_in, (py_data_unpack_fn)unpack_py_lsa_AddPrivilegesToAccount_args_out, 19, &ndr_table_lsarpc },
	{ "RemovePrivilegesFromAccount", "S.RemovePrivilegesFromAccount(handle, remove_all, privs) -> None", (py_dcerpc_call_fn)dcerpc_lsa_RemovePrivilegesFromAccount_r, (py_data_pack_fn)pack_py_lsa_RemovePrivilegesFromAccount_args_in, (py_data_unpack_fn)unpack_py_lsa_RemovePrivilegesFromAccount_args_out, 20, &ndr_table_lsarpc },
	{ "GetSystemAccessAccount", "S.GetSystemAccessAccount(handle) -> access_mask", (py_dcerpc_call_fn)dcerpc_lsa_GetSystemAccessAccount_r, (py_data_pack_fn)pack_py_lsa_GetSystemAccessAccount_args_in, (py_data_unpack_fn)unpack_py_lsa_GetSystemAccessAccount_args_out, 23, &ndr_table_lsarpc },
	{ "SetSystemAccessAccount", "S.SetSystemAccessAccount(handle, access_mask) -> None", (py_dcerpc_call_fn)dcerpc_lsa_SetSystemAccessAccount_r, (py_data_pack_fn)pack_py_lsa_SetSystemAccessAccount_args_in, (py_data_unpack_fn)unpack_py_lsa_SetSystemAccessAccount_args_out, 24, &ndr_table_lsarpc },
	{ "OpenTrustedDomain", "S.OpenTrustedDomain(handle, sid, access_mask) -> trustdom_handle", (py_dcerpc_call_fn)dcerpc_lsa_OpenTrustedDomain_r, (py_data_pack_fn)pack_py_lsa_OpenTrustedDomain_args_in, (py_data_unpack_fn)unpack_py_lsa_OpenTrustedDomain_args_out, 25, &ndr_table_lsarpc },
	{ "QueryTrustedDomainInfo", "S.QueryTrustedDomainInfo(trustdom_handle, level) -> info", (py_dcerpc_call_fn)dcerpc_lsa_QueryTrustedDomainInfo_r, (py_data_pack_fn)pack_py_lsa_QueryTrustedDomainInfo_args_in, (py_data_unpack_fn)unpack_py_lsa_QueryTrustedDomainInfo_args_out, 26, &ndr_table_lsarpc },
	{ "SetInformationTrustedDomain", "S.SetInformationTrustedDomain(trustdom_handle, level, info) -> None", (py_dcerpc_call_fn)dcerpc_lsa_SetInformationTrustedDomain_r, (py_data_pack_fn)pack_py_lsa_SetInformationTrustedDomain_args_in, (py_data_unpack_fn)unpack_py_lsa_SetInformationTrustedDomain_args_out, 27, &ndr_table_lsarpc },
	{ "OpenSecret", "S.OpenSecret(handle, name, access_mask) -> sec_handle", (py_dcerpc_call_fn)dcerpc_lsa_OpenSecret_r, (py_data_pack_fn)pack_py_lsa_OpenSecret_args_in, (py_data_unpack_fn)unpack_py_lsa_OpenSecret_args_out, 28, &ndr_table_lsarpc },
	{ "SetSecret", "S.SetSecret(sec_handle, new_val, old_val) -> None", (py_dcerpc_call_fn)dcerpc_lsa_SetSecret_r, (py_data_pack_fn)pack_py_lsa_SetSecret_args_in, (py_data_unpack_fn)unpack_py_lsa_SetSecret_args_out, 29, &ndr_table_lsarpc },
	{ "QuerySecret", "S.QuerySecret(sec_handle, new_val, new_mtime, old_val, old_mtime) -> (new_val, new_mtime, old_val, old_mtime)", (py_dcerpc_call_fn)dcerpc_lsa_QuerySecret_r, (py_data_pack_fn)pack_py_lsa_QuerySecret_args_in, (py_data_unpack_fn)unpack_py_lsa_QuerySecret_args_out, 30, &ndr_table_lsarpc },
	{ "LookupPrivValue", "S.LookupPrivValue(handle, name) -> luid", (py_dcerpc_call_fn)dcerpc_lsa_LookupPrivValue_r, (py_data_pack_fn)pack_py_lsa_LookupPrivValue_args_in, (py_data_unpack_fn)unpack_py_lsa_LookupPrivValue_args_out, 31, &ndr_table_lsarpc },
	{ "LookupPrivName", "S.LookupPrivName(handle, luid) -> name", (py_dcerpc_call_fn)dcerpc_lsa_LookupPrivName_r, (py_data_pack_fn)pack_py_lsa_LookupPrivName_args_in, (py_data_unpack_fn)unpack_py_lsa_LookupPrivName_args_out, 32, &ndr_table_lsarpc },
	{ "LookupPrivDisplayName", "S.LookupPrivDisplayName(handle, name, language_id, language_id_sys) -> (disp_name, returned_language_id)", (py_dcerpc_call_fn)dcerpc_lsa_LookupPrivDisplayName_r, (py_data_pack_fn)pack_py_lsa_LookupPrivDisplayName_args_in, (py_data_unpack_fn)unpack_py_lsa_LookupPrivDisplayName_args_out, 33, &ndr_table_lsarpc },
	{ "DeleteObject", "S.DeleteObject(handle) -> handle", (py_dcerpc_call_fn)dcerpc_lsa_DeleteObject_r, (py_data_pack_fn)pack_py_lsa_DeleteObject_args_in, (py_data_unpack_fn)unpack_py_lsa_DeleteObject_args_out, 34, &ndr_table_lsarpc },
	{ "EnumAccountsWithUserRight", "S.EnumAccountsWithUserRight(handle, name) -> sids", (py_dcerpc_call_fn)dcerpc_lsa_EnumAccountsWithUserRight_r, (py_data_pack_fn)pack_py_lsa_EnumAccountsWithUserRight_args_in, (py_data_unpack_fn)unpack_py_lsa_EnumAccountsWithUserRight_args_out, 35, &ndr_table_lsarpc },
	{ "EnumAccountRights", "S.EnumAccountRights(handle, sid) -> rights", (py_dcerpc_call_fn)dcerpc_lsa_EnumAccountRights_r, (py_data_pack_fn)pack_py_lsa_EnumAccountRights_args_in, (py_data_unpack_fn)unpack_py_lsa_EnumAccountRights_args_out, 36, &ndr_table_lsarpc },
	{ "AddAccountRights", "S.AddAccountRights(handle, sid, rights) -> None", (py_dcerpc_call_fn)dcerpc_lsa_AddAccountRights_r, (py_data_pack_fn)pack_py_lsa_AddAccountRights_args_in, (py_data_unpack_fn)unpack_py_lsa_AddAccountRights_args_out, 37, &ndr_table_lsarpc },
	{ "RemoveAccountRights", "S.RemoveAccountRights(handle, sid, remove_all, rights) -> None", (py_dcerpc_call_fn)dcerpc_lsa_RemoveAccountRights_r, (py_data_pack_fn)pack_py_lsa_RemoveAccountRights_args_in, (py_data_unpack_fn)unpack_py_lsa_RemoveAccountRights_args_out, 38, &ndr_table_lsarpc },
	{ "QueryTrustedDomainInfoBySid", "S.QueryTrustedDomainInfoBySid(handle, dom_sid, level) -> info", (py_dcerpc_call_fn)dcerpc_lsa_QueryTrustedDomainInfoBySid_r, (py_data_pack_fn)pack_py_lsa_QueryTrustedDomainInfoBySid_args_in, (py_data_unpack_fn)unpack_py_lsa_QueryTrustedDomainInfoBySid_args_out, 39, &ndr_table_lsarpc },
	{ "SetTrustedDomainInfo", "S.SetTrustedDomainInfo(handle, dom_sid, level, info) -> None", (py_dcerpc_call_fn)dcerpc_lsa_SetTrustedDomainInfo_r, (py_data_pack_fn)pack_py_lsa_SetTrustedDomainInfo_args_in, (py_data_unpack_fn)unpack_py_lsa_SetTrustedDomainInfo_args_out, 40, &ndr_table_lsarpc },
	{ "DeleteTrustedDomain", "S.DeleteTrustedDomain(handle, dom_sid) -> None", (py_dcerpc_call_fn)dcerpc_lsa_DeleteTrustedDomain_r, (py_data_pack_fn)pack_py_lsa_DeleteTrustedDomain_args_in, (py_data_unpack_fn)unpack_py_lsa_DeleteTrustedDomain_args_out, 41, &ndr_table_lsarpc },
	{ "StorePrivateData", "S.StorePrivateData(handle, name, val) -> None", (py_dcerpc_call_fn)dcerpc_lsa_StorePrivateData_r, (py_data_pack_fn)pack_py_lsa_StorePrivateData_args_in, (py_data_unpack_fn)unpack_py_lsa_StorePrivateData_args_out, 42, &ndr_table_lsarpc },
	{ "RetrievePrivateData", "S.RetrievePrivateData(handle, name, val) -> val", (py_dcerpc_call_fn)dcerpc_lsa_RetrievePrivateData_r, (py_data_pack_fn)pack_py_lsa_RetrievePrivateData_args_in, (py_data_unpack_fn)unpack_py_lsa_RetrievePrivateData_args_out, 43, &ndr_table_lsarpc },
	{ "OpenPolicy2", "S.OpenPolicy2(system_name, attr, access_mask) -> handle", (py_dcerpc_call_fn)dcerpc_lsa_OpenPolicy2_r, (py_data_pack_fn)pack_py_lsa_OpenPolicy2_args_in, (py_data_unpack_fn)unpack_py_lsa_OpenPolicy2_args_out, 44, &ndr_table_lsarpc },
	{ "GetUserName", "S.GetUserName(system_name, account_name, authority_name) -> (account_name, authority_name)", (py_dcerpc_call_fn)dcerpc_lsa_GetUserName_r, (py_data_pack_fn)pack_py_lsa_GetUserName_args_in, (py_data_unpack_fn)unpack_py_lsa_GetUserName_args_out, 45, &ndr_table_lsarpc },
	{ "QueryInfoPolicy2", "S.QueryInfoPolicy2(handle, level) -> info", (py_dcerpc_call_fn)dcerpc_lsa_QueryInfoPolicy2_r, (py_data_pack_fn)pack_py_lsa_QueryInfoPolicy2_args_in, (py_data_unpack_fn)unpack_py_lsa_QueryInfoPolicy2_args_out, 46, &ndr_table_lsarpc },
	{ "SetInfoPolicy2", "S.SetInfoPolicy2(handle, level, info) -> None", (py_dcerpc_call_fn)dcerpc_lsa_SetInfoPolicy2_r, (py_data_pack_fn)pack_py_lsa_SetInfoPolicy2_args_in, (py_data_unpack_fn)unpack_py_lsa_SetInfoPolicy2_args_out, 47, &ndr_table_lsarpc },
	{ "QueryTrustedDomainInfoByName", "S.QueryTrustedDomainInfoByName(handle, trusted_domain, level) -> info", (py_dcerpc_call_fn)dcerpc_lsa_QueryTrustedDomainInfoByName_r, (py_data_pack_fn)pack_py_lsa_QueryTrustedDomainInfoByName_args_in, (py_data_unpack_fn)unpack_py_lsa_QueryTrustedDomainInfoByName_args_out, 48, &ndr_table_lsarpc },
	{ "SetTrustedDomainInfoByName", "S.SetTrustedDomainInfoByName(handle, trusted_domain, level, info) -> None", (py_dcerpc_call_fn)dcerpc_lsa_SetTrustedDomainInfoByName_r, (py_data_pack_fn)pack_py_lsa_SetTrustedDomainInfoByName_args_in, (py_data_unpack_fn)unpack_py_lsa_SetTrustedDomainInfoByName_args_out, 49, &ndr_table_lsarpc },
	{ "EnumTrustedDomainsEx", "S.EnumTrustedDomainsEx(handle, resume_handle, max_size) -> (resume_handle, domains)", (py_dcerpc_call_fn)dcerpc_lsa_EnumTrustedDomainsEx_r, (py_data_pack_fn)pack_py_lsa_EnumTrustedDomainsEx_args_in, (py_data_unpack_fn)unpack_py_lsa_EnumTrustedDomainsEx_args_out, 50, &ndr_table_lsarpc },
	{ "CreateTrustedDomainEx", "S.CreateTrustedDomainEx(policy_handle, info, auth_info, access_mask) -> trustdom_handle", (py_dcerpc_call_fn)dcerpc_lsa_CreateTrustedDomainEx_r, (py_data_pack_fn)pack_py_lsa_CreateTrustedDomainEx_args_in, (py_data_unpack_fn)unpack_py_lsa_CreateTrustedDomainEx_args_out, 51, &ndr_table_lsarpc },
	{ "CloseTrustedDomainEx", "S.CloseTrustedDomainEx(handle) -> handle", (py_dcerpc_call_fn)dcerpc_lsa_CloseTrustedDomainEx_r, (py_data_pack_fn)pack_py_lsa_CloseTrustedDomainEx_args_in, (py_data_unpack_fn)unpack_py_lsa_CloseTrustedDomainEx_args_out, 52, &ndr_table_lsarpc },
	{ "QueryDomainInformationPolicy", "S.QueryDomainInformationPolicy(handle, level) -> info", (py_dcerpc_call_fn)dcerpc_lsa_QueryDomainInformationPolicy_r, (py_data_pack_fn)pack_py_lsa_QueryDomainInformationPolicy_args_in, (py_data_unpack_fn)unpack_py_lsa_QueryDomainInformationPolicy_args_out, 53, &ndr_table_lsarpc },
	{ "SetDomainInformationPolicy", "S.SetDomainInformationPolicy(handle, level, info) -> None", (py_dcerpc_call_fn)dcerpc_lsa_SetDomainInformationPolicy_r, (py_data_pack_fn)pack_py_lsa_SetDomainInformationPolicy_args_in, (py_data_unpack_fn)unpack_py_lsa_SetDomainInformationPolicy_args_out, 54, &ndr_table_lsarpc },
	{ "OpenTrustedDomainByName", "S.OpenTrustedDomainByName(handle, name, access_mask) -> trustdom_handle", (py_dcerpc_call_fn)dcerpc_lsa_OpenTrustedDomainByName_r, (py_data_pack_fn)pack_py_lsa_OpenTrustedDomainByName_args_in, (py_data_unpack_fn)unpack_py_lsa_OpenTrustedDomainByName_args_out, 55, &ndr_table_lsarpc },
	{ "LookupSids2", "S.LookupSids2(handle, sids, names, level, count, lookup_options, client_revision) -> (domains, names, count)", (py_dcerpc_call_fn)dcerpc_lsa_LookupSids2_r, (py_data_pack_fn)pack_py_lsa_LookupSids2_args_in, (py_data_unpack_fn)unpack_py_lsa_LookupSids2_args_out, 57, &ndr_table_lsarpc },
	{ "LookupNames2", "S.LookupNames2(handle, names, sids, level, count, lookup_options, client_revision) -> (domains, sids, count)", (py_dcerpc_call_fn)dcerpc_lsa_LookupNames2_r, (py_data_pack_fn)pack_py_lsa_LookupNames2_args_in, (py_data_unpack_fn)unpack_py_lsa_LookupNames2_args_out, 58, &ndr_table_lsarpc },
	{ "CreateTrustedDomainEx2", "S.CreateTrustedDomainEx2(policy_handle, info, auth_info_internal, access_mask) -> trustdom_handle", (py_dcerpc_call_fn)dcerpc_lsa_CreateTrustedDomainEx2_r, (py_data_pack_fn)pack_py_lsa_CreateTrustedDomainEx2_args_in, (py_data_unpack_fn)unpack_py_lsa_CreateTrustedDomainEx2_args_out, 59, &ndr_table_lsarpc },
	{ "LookupNames3", "S.LookupNames3(handle, names, sids, level, count, lookup_options, client_revision) -> (domains, sids, count)", (py_dcerpc_call_fn)dcerpc_lsa_LookupNames3_r, (py_data_pack_fn)pack_py_lsa_LookupNames3_args_in, (py_data_unpack_fn)unpack_py_lsa_LookupNames3_args_out, 68, &ndr_table_lsarpc },
	{ "lsaRQueryForestTrustInformation", "S.lsaRQueryForestTrustInformation(handle, trusted_domain_name, highest_record_type) -> forest_trust_info", (py_dcerpc_call_fn)dcerpc_lsa_lsaRQueryForestTrustInformation_r, (py_data_pack_fn)pack_py_lsa_lsaRQueryForestTrustInformation_args_in, (py_data_unpack_fn)unpack_py_lsa_lsaRQueryForestTrustInformation_args_out, 73, &ndr_table_lsarpc },
	{ "lsaRSetForestTrustInformation", "S.lsaRSetForestTrustInformation(handle, trusted_domain_name, highest_record_type, forest_trust_info, check_only) -> collision_info", (py_dcerpc_call_fn)dcerpc_lsa_lsaRSetForestTrustInformation_r, (py_data_pack_fn)pack_py_lsa_lsaRSetForestTrustInformation_args_in, (py_data_unpack_fn)unpack_py_lsa_lsaRSetForestTrustInformation_args_out, 74, &ndr_table_lsarpc },
	{ "LookupSids3", "S.LookupSids3(sids, names, level, count, lookup_options, client_revision) -> (domains, names, count)", (py_dcerpc_call_fn)dcerpc_lsa_LookupSids3_r, (py_data_pack_fn)pack_py_lsa_LookupSids3_args_in, (py_data_unpack_fn)unpack_py_lsa_LookupSids3_args_out, 76, &ndr_table_lsarpc },
	{ "LookupNames4", "S.LookupNames4(names, sids, level, count, lookup_options, client_revision) -> (domains, sids, count)", (py_dcerpc_call_fn)dcerpc_lsa_LookupNames4_r, (py_data_pack_fn)pack_py_lsa_LookupNames4_args_in, (py_data_unpack_fn)unpack_py_lsa_LookupNames4_args_out, 77, &ndr_table_lsarpc },
	{ NULL }
};

static PyObject *interface_lsarpc_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_dcerpc_interface_init_helper(type, args, kwargs, &ndr_table_lsarpc);
}

#define PY_DOC_LSARPC "Local Security Authority"
static PyTypeObject lsarpc_InterfaceType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.lsarpc",
	.tp_basicsize = sizeof(dcerpc_InterfaceObject),
	.tp_doc = "lsarpc(binding, lp_ctx=None, credentials=None) -> connection\n"
"\n"
"binding should be a DCE/RPC binding string (for example: ncacn_ip_tcp:127.0.0.1)\n"
"lp_ctx should be a path to a smb.conf file or a param.LoadParm object\n"
"credentials should be a credentials.Credentials object.\n\n"PY_DOC_LSARPC,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = interface_lsarpc_new,
};

static PyObject *syntax_lsarpc_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_dcerpc_syntax_init_helper(type, args, kwargs, &ndr_table_lsarpc.syntax_id);
}

#define PY_DOC_LSARPC_SYNTAX "Local Security Authority"
static PyTypeObject lsarpc_SyntaxType = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "lsa.lsarpc_abstract_syntax",
	.tp_doc = "lsarpc_abstract_syntax()\n"PY_DOC_LSARPC_SYNTAX,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = syntax_lsarpc_new,
};

static PyMethodDef lsa_methods[] = {
	{ NULL, NULL, 0, NULL }
};

static struct PyModuleDef moduledef = {
	PyModuleDef_HEAD_INIT,
	.m_name = "lsa",
	.m_doc = "lsa DCE/RPC",
	.m_size = -1,
	.m_methods = lsa_methods,
};
MODULE_INIT_FUNC(lsa)
{
	PyObject *m;
	PyObject *dep_samba_dcerpc_misc;
	PyObject *dep_samba_dcerpc_security;
	PyObject *dep_talloc;
	PyObject *dep_samba_dcerpc_base;

	dep_samba_dcerpc_misc = PyImport_ImportModule("samba.dcerpc.misc");
	if (dep_samba_dcerpc_misc == NULL)
		return NULL;

	dep_samba_dcerpc_security = PyImport_ImportModule("samba.dcerpc.security");
	if (dep_samba_dcerpc_security == NULL)
		return NULL;

	dep_talloc = PyImport_ImportModule("talloc");
	if (dep_talloc == NULL)
		return NULL;

	dep_samba_dcerpc_base = PyImport_ImportModule("samba.dcerpc.base");
	if (dep_samba_dcerpc_base == NULL)
		return NULL;

	BaseObject_Type = (PyTypeObject *)PyObject_GetAttrString(dep_talloc, "BaseObject");
	if (BaseObject_Type == NULL)
		return NULL;

	security_descriptor_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_security, "descriptor");
	if (security_descriptor_Type == NULL)
		return NULL;

	dom_sid_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_security, "dom_sid");
	if (dom_sid_Type == NULL)
		return NULL;

	GUID_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_misc, "GUID");
	if (GUID_Type == NULL)
		return NULL;

	policy_handle_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_misc, "policy_handle");
	if (policy_handle_Type == NULL)
		return NULL;

	sec_desc_buf_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_security, "sec_desc_buf");
	if (sec_desc_buf_Type == NULL)
		return NULL;

	ClientConnection_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_base, "ClientConnection");
	if (ClientConnection_Type == NULL)
		return NULL;

	ndr_syntax_id_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_misc, "ndr_syntax_id");
	if (ndr_syntax_id_Type == NULL)
		return NULL;

	lsa_String_Type.tp_base = BaseObject_Type;
	lsa_String_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_StringLarge_Type.tp_base = BaseObject_Type;
	lsa_StringLarge_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_Strings_Type.tp_base = BaseObject_Type;
	lsa_Strings_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_AsciiString_Type.tp_base = BaseObject_Type;
	lsa_AsciiString_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_AsciiStringLarge_Type.tp_base = BaseObject_Type;
	lsa_AsciiStringLarge_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_BinaryString_Type.tp_base = BaseObject_Type;
	lsa_BinaryString_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_LUID_Type.tp_base = BaseObject_Type;
	lsa_LUID_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_PrivEntry_Type.tp_base = BaseObject_Type;
	lsa_PrivEntry_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_PrivArray_Type.tp_base = BaseObject_Type;
	lsa_PrivArray_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_QosInfo_Type.tp_base = BaseObject_Type;
	lsa_QosInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_ObjectAttribute_Type.tp_base = BaseObject_Type;
	lsa_ObjectAttribute_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_AuditLogInfo_Type.tp_base = BaseObject_Type;
	lsa_AuditLogInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_AuditEventsInfo_Type.tp_base = BaseObject_Type;
	lsa_AuditEventsInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_DomainInfo_Type.tp_base = BaseObject_Type;
	lsa_DomainInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_PDAccountInfo_Type.tp_base = BaseObject_Type;
	lsa_PDAccountInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_ServerRole_Type.tp_base = BaseObject_Type;
	lsa_ServerRole_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_ReplicaSourceInfo_Type.tp_base = BaseObject_Type;
	lsa_ReplicaSourceInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_DefaultQuotaInfo_Type.tp_base = BaseObject_Type;
	lsa_DefaultQuotaInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_ModificationInfo_Type.tp_base = BaseObject_Type;
	lsa_ModificationInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_AuditFullSetInfo_Type.tp_base = BaseObject_Type;
	lsa_AuditFullSetInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_AuditFullQueryInfo_Type.tp_base = BaseObject_Type;
	lsa_AuditFullQueryInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_DnsDomainInfo_Type.tp_base = BaseObject_Type;
	lsa_DnsDomainInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_PolicyInformation_Type.tp_base = BaseObject_Type;
	lsa_PolicyInformation_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_SidPtr_Type.tp_base = BaseObject_Type;
	lsa_SidPtr_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_SidArray_Type.tp_base = BaseObject_Type;
	lsa_SidArray_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_DomainList_Type.tp_base = BaseObject_Type;
	lsa_DomainList_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TranslatedSid_Type.tp_base = BaseObject_Type;
	lsa_TranslatedSid_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TransSidArray_Type.tp_base = BaseObject_Type;
	lsa_TransSidArray_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_RefDomainList_Type.tp_base = BaseObject_Type;
	lsa_RefDomainList_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TranslatedName_Type.tp_base = BaseObject_Type;
	lsa_TranslatedName_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TransNameArray_Type.tp_base = BaseObject_Type;
	lsa_TransNameArray_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_LUIDAttribute_Type.tp_base = BaseObject_Type;
	lsa_LUIDAttribute_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_PrivilegeSet_Type.tp_base = BaseObject_Type;
	lsa_PrivilegeSet_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_DATA_BUF_Type.tp_base = BaseObject_Type;
	lsa_DATA_BUF_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_DATA_BUF2_Type.tp_base = BaseObject_Type;
	lsa_DATA_BUF2_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TrustDomainInfoName_Type.tp_base = BaseObject_Type;
	lsa_TrustDomainInfoName_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TrustDomainInfoControllers_Type.tp_base = BaseObject_Type;
	lsa_TrustDomainInfoControllers_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TrustDomainInfoPosixOffset_Type.tp_base = BaseObject_Type;
	lsa_TrustDomainInfoPosixOffset_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TrustDomainInfoPassword_Type.tp_base = BaseObject_Type;
	lsa_TrustDomainInfoPassword_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TrustDomainInfoBasic_Type.tp_base = BaseObject_Type;
	lsa_TrustDomainInfoBasic_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TrustDomainInfoInfoEx_Type.tp_base = BaseObject_Type;
	lsa_TrustDomainInfoInfoEx_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TrustDomainInfoBuffer_Type.tp_base = BaseObject_Type;
	lsa_TrustDomainInfoBuffer_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TrustDomainInfoAuthInfo_Type.tp_base = BaseObject_Type;
	lsa_TrustDomainInfoAuthInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TrustDomainInfoFullInfo_Type.tp_base = BaseObject_Type;
	lsa_TrustDomainInfoFullInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TrustDomainInfoAuthInfoInternal_Type.tp_base = BaseObject_Type;
	lsa_TrustDomainInfoAuthInfoInternal_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TrustDomainInfoFullInfoInternal_Type.tp_base = BaseObject_Type;
	lsa_TrustDomainInfoFullInfoInternal_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TrustDomainInfoInfoEx2Internal_Type.tp_base = BaseObject_Type;
	lsa_TrustDomainInfoInfoEx2Internal_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TrustDomainInfoFullInfo2Internal_Type.tp_base = BaseObject_Type;
	lsa_TrustDomainInfoFullInfo2Internal_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TrustDomainInfoSupportedEncTypes_Type.tp_base = BaseObject_Type;
	lsa_TrustDomainInfoSupportedEncTypes_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TrustedDomainInfo_Type.tp_base = BaseObject_Type;
	lsa_TrustedDomainInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_DATA_BUF_PTR_Type.tp_base = BaseObject_Type;
	lsa_DATA_BUF_PTR_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_RightAttribute_Type.tp_base = BaseObject_Type;
	lsa_RightAttribute_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_RightSet_Type.tp_base = BaseObject_Type;
	lsa_RightSet_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_DomainListEx_Type.tp_base = BaseObject_Type;
	lsa_DomainListEx_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_DomainInfoKerberos_Type.tp_base = BaseObject_Type;
	lsa_DomainInfoKerberos_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_DomainInfoEfs_Type.tp_base = BaseObject_Type;
	lsa_DomainInfoEfs_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_DomainInformationPolicy_Type.tp_base = BaseObject_Type;
	lsa_DomainInformationPolicy_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TranslatedName2_Type.tp_base = BaseObject_Type;
	lsa_TranslatedName2_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TransNameArray2_Type.tp_base = BaseObject_Type;
	lsa_TransNameArray2_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TranslatedSid2_Type.tp_base = BaseObject_Type;
	lsa_TranslatedSid2_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TransSidArray2_Type.tp_base = BaseObject_Type;
	lsa_TransSidArray2_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TranslatedSid3_Type.tp_base = BaseObject_Type;
	lsa_TranslatedSid3_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_TransSidArray3_Type.tp_base = BaseObject_Type;
	lsa_TransSidArray3_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_ForestTrustBinaryData_Type.tp_base = BaseObject_Type;
	lsa_ForestTrustBinaryData_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_ForestTrustDomainInfo_Type.tp_base = BaseObject_Type;
	lsa_ForestTrustDomainInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_ForestTrustData_Type.tp_base = BaseObject_Type;
	lsa_ForestTrustData_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_ForestTrustRecord_Type.tp_base = BaseObject_Type;
	lsa_ForestTrustRecord_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_ForestTrustInformation_Type.tp_base = BaseObject_Type;
	lsa_ForestTrustInformation_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_ForestTrustCollisionRecord_Type.tp_base = BaseObject_Type;
	lsa_ForestTrustCollisionRecord_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_ForestTrustCollisionInfo_Type.tp_base = BaseObject_Type;
	lsa_ForestTrustCollisionInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_Close_Type.tp_base = BaseObject_Type;
	lsa_Close_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_Delete_Type.tp_base = BaseObject_Type;
	lsa_Delete_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_EnumPrivs_Type.tp_base = BaseObject_Type;
	lsa_EnumPrivs_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_QuerySecurity_Type.tp_base = BaseObject_Type;
	lsa_QuerySecurity_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_SetSecObj_Type.tp_base = BaseObject_Type;
	lsa_SetSecObj_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_OpenPolicy_Type.tp_base = BaseObject_Type;
	lsa_OpenPolicy_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_QueryInfoPolicy_Type.tp_base = BaseObject_Type;
	lsa_QueryInfoPolicy_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_SetInfoPolicy_Type.tp_base = BaseObject_Type;
	lsa_SetInfoPolicy_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_CreateAccount_Type.tp_base = BaseObject_Type;
	lsa_CreateAccount_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_EnumAccounts_Type.tp_base = BaseObject_Type;
	lsa_EnumAccounts_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_CreateTrustedDomain_Type.tp_base = BaseObject_Type;
	lsa_CreateTrustedDomain_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_EnumTrustDom_Type.tp_base = BaseObject_Type;
	lsa_EnumTrustDom_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_LookupNames_Type.tp_base = BaseObject_Type;
	lsa_LookupNames_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_LookupSids_Type.tp_base = BaseObject_Type;
	lsa_LookupSids_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_CreateSecret_Type.tp_base = BaseObject_Type;
	lsa_CreateSecret_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_OpenAccount_Type.tp_base = BaseObject_Type;
	lsa_OpenAccount_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_EnumPrivsAccount_Type.tp_base = BaseObject_Type;
	lsa_EnumPrivsAccount_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_AddPrivilegesToAccount_Type.tp_base = BaseObject_Type;
	lsa_AddPrivilegesToAccount_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_RemovePrivilegesFromAccount_Type.tp_base = BaseObject_Type;
	lsa_RemovePrivilegesFromAccount_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_GetSystemAccessAccount_Type.tp_base = BaseObject_Type;
	lsa_GetSystemAccessAccount_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_SetSystemAccessAccount_Type.tp_base = BaseObject_Type;
	lsa_SetSystemAccessAccount_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_OpenTrustedDomain_Type.tp_base = BaseObject_Type;
	lsa_OpenTrustedDomain_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_QueryTrustedDomainInfo_Type.tp_base = BaseObject_Type;
	lsa_QueryTrustedDomainInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_SetInformationTrustedDomain_Type.tp_base = BaseObject_Type;
	lsa_SetInformationTrustedDomain_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_OpenSecret_Type.tp_base = BaseObject_Type;
	lsa_OpenSecret_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_SetSecret_Type.tp_base = BaseObject_Type;
	lsa_SetSecret_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_QuerySecret_Type.tp_base = BaseObject_Type;
	lsa_QuerySecret_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_LookupPrivValue_Type.tp_base = BaseObject_Type;
	lsa_LookupPrivValue_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_LookupPrivName_Type.tp_base = BaseObject_Type;
	lsa_LookupPrivName_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_LookupPrivDisplayName_Type.tp_base = BaseObject_Type;
	lsa_LookupPrivDisplayName_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_DeleteObject_Type.tp_base = BaseObject_Type;
	lsa_DeleteObject_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_EnumAccountsWithUserRight_Type.tp_base = BaseObject_Type;
	lsa_EnumAccountsWithUserRight_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_EnumAccountRights_Type.tp_base = BaseObject_Type;
	lsa_EnumAccountRights_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_AddAccountRights_Type.tp_base = BaseObject_Type;
	lsa_AddAccountRights_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_RemoveAccountRights_Type.tp_base = BaseObject_Type;
	lsa_RemoveAccountRights_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_QueryTrustedDomainInfoBySid_Type.tp_base = BaseObject_Type;
	lsa_QueryTrustedDomainInfoBySid_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_SetTrustedDomainInfo_Type.tp_base = BaseObject_Type;
	lsa_SetTrustedDomainInfo_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_DeleteTrustedDomain_Type.tp_base = BaseObject_Type;
	lsa_DeleteTrustedDomain_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_StorePrivateData_Type.tp_base = BaseObject_Type;
	lsa_StorePrivateData_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_RetrievePrivateData_Type.tp_base = BaseObject_Type;
	lsa_RetrievePrivateData_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_OpenPolicy2_Type.tp_base = BaseObject_Type;
	lsa_OpenPolicy2_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_GetUserName_Type.tp_base = BaseObject_Type;
	lsa_GetUserName_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_QueryInfoPolicy2_Type.tp_base = BaseObject_Type;
	lsa_QueryInfoPolicy2_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_SetInfoPolicy2_Type.tp_base = BaseObject_Type;
	lsa_SetInfoPolicy2_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_QueryTrustedDomainInfoByName_Type.tp_base = BaseObject_Type;
	lsa_QueryTrustedDomainInfoByName_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_SetTrustedDomainInfoByName_Type.tp_base = BaseObject_Type;
	lsa_SetTrustedDomainInfoByName_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_EnumTrustedDomainsEx_Type.tp_base = BaseObject_Type;
	lsa_EnumTrustedDomainsEx_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_CreateTrustedDomainEx_Type.tp_base = BaseObject_Type;
	lsa_CreateTrustedDomainEx_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_CloseTrustedDomainEx_Type.tp_base = BaseObject_Type;
	lsa_CloseTrustedDomainEx_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_QueryDomainInformationPolicy_Type.tp_base = BaseObject_Type;
	lsa_QueryDomainInformationPolicy_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_SetDomainInformationPolicy_Type.tp_base = BaseObject_Type;
	lsa_SetDomainInformationPolicy_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_OpenTrustedDomainByName_Type.tp_base = BaseObject_Type;
	lsa_OpenTrustedDomainByName_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_LookupSids2_Type.tp_base = BaseObject_Type;
	lsa_LookupSids2_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_LookupNames2_Type.tp_base = BaseObject_Type;
	lsa_LookupNames2_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_CreateTrustedDomainEx2_Type.tp_base = BaseObject_Type;
	lsa_CreateTrustedDomainEx2_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_LookupNames3_Type.tp_base = BaseObject_Type;
	lsa_LookupNames3_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_lsaRQueryForestTrustInformation_Type.tp_base = BaseObject_Type;
	lsa_lsaRQueryForestTrustInformation_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_lsaRSetForestTrustInformation_Type.tp_base = BaseObject_Type;
	lsa_lsaRSetForestTrustInformation_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_LookupSids3_Type.tp_base = BaseObject_Type;
	lsa_LookupSids3_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsa_LookupNames4_Type.tp_base = BaseObject_Type;
	lsa_LookupNames4_Type.tp_basicsize = pytalloc_BaseObject_size();

	lsarpc_InterfaceType.tp_base = ClientConnection_Type;

	lsarpc_SyntaxType.tp_base = ndr_syntax_id_Type;
	lsarpc_SyntaxType.tp_basicsize = pytalloc_BaseObject_size();

	if (PyType_Ready(&lsa_String_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_StringLarge_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_Strings_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_AsciiString_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_AsciiStringLarge_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_BinaryString_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_LUID_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_PrivEntry_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_PrivArray_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_QosInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_ObjectAttribute_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_AuditLogInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_AuditEventsInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_DomainInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_PDAccountInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_ServerRole_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_ReplicaSourceInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_DefaultQuotaInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_ModificationInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_AuditFullSetInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_AuditFullQueryInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_DnsDomainInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_PolicyInformation_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_SidPtr_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_SidArray_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_DomainList_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TranslatedSid_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TransSidArray_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_RefDomainList_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TranslatedName_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TransNameArray_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_LUIDAttribute_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_PrivilegeSet_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_DATA_BUF_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_DATA_BUF2_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TrustDomainInfoName_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TrustDomainInfoControllers_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TrustDomainInfoPosixOffset_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TrustDomainInfoPassword_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TrustDomainInfoBasic_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TrustDomainInfoInfoEx_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TrustDomainInfoBuffer_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TrustDomainInfoAuthInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TrustDomainInfoFullInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TrustDomainInfoAuthInfoInternal_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TrustDomainInfoFullInfoInternal_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TrustDomainInfoInfoEx2Internal_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TrustDomainInfoFullInfo2Internal_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TrustDomainInfoSupportedEncTypes_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TrustedDomainInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_DATA_BUF_PTR_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_RightAttribute_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_RightSet_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_DomainListEx_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_DomainInfoKerberos_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_DomainInfoEfs_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_DomainInformationPolicy_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TranslatedName2_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TransNameArray2_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TranslatedSid2_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TransSidArray2_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TranslatedSid3_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_TransSidArray3_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_ForestTrustBinaryData_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_ForestTrustDomainInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_ForestTrustData_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_ForestTrustRecord_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_ForestTrustInformation_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_ForestTrustCollisionRecord_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_ForestTrustCollisionInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_Close_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_Delete_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_EnumPrivs_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_QuerySecurity_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_SetSecObj_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_OpenPolicy_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_QueryInfoPolicy_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_SetInfoPolicy_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_CreateAccount_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_EnumAccounts_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_CreateTrustedDomain_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_EnumTrustDom_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_LookupNames_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_LookupSids_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_CreateSecret_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_OpenAccount_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_EnumPrivsAccount_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_AddPrivilegesToAccount_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_RemovePrivilegesFromAccount_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_GetSystemAccessAccount_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_SetSystemAccessAccount_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_OpenTrustedDomain_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_QueryTrustedDomainInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_SetInformationTrustedDomain_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_OpenSecret_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_SetSecret_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_QuerySecret_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_LookupPrivValue_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_LookupPrivName_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_LookupPrivDisplayName_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_DeleteObject_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_EnumAccountsWithUserRight_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_EnumAccountRights_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_AddAccountRights_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_RemoveAccountRights_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_QueryTrustedDomainInfoBySid_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_SetTrustedDomainInfo_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_DeleteTrustedDomain_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_StorePrivateData_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_RetrievePrivateData_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_OpenPolicy2_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_GetUserName_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_QueryInfoPolicy2_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_SetInfoPolicy2_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_QueryTrustedDomainInfoByName_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_SetTrustedDomainInfoByName_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_EnumTrustedDomainsEx_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_CreateTrustedDomainEx_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_CloseTrustedDomainEx_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_QueryDomainInformationPolicy_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_SetDomainInformationPolicy_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_OpenTrustedDomainByName_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_LookupSids2_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_LookupNames2_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_CreateTrustedDomainEx2_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_LookupNames3_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_lsaRQueryForestTrustInformation_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_lsaRSetForestTrustInformation_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_LookupSids3_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsa_LookupNames4_Type) < 0)
		return NULL;
	if (PyType_Ready(&lsarpc_InterfaceType) < 0)
		return NULL;
	if (PyType_Ready(&lsarpc_SyntaxType) < 0)
		return NULL;
	if (!PyInterface_AddNdrRpcMethods(&lsarpc_InterfaceType, py_ndr_lsarpc_methods))
		return NULL;

#ifdef PY_STRING_PATCH
	PY_STRING_PATCH(&lsa_String_Type);
#endif
#ifdef PY_STRINGLARGE_PATCH
	PY_STRINGLARGE_PATCH(&lsa_StringLarge_Type);
#endif
#ifdef PY_STRINGS_PATCH
	PY_STRINGS_PATCH(&lsa_Strings_Type);
#endif
#ifdef PY_ASCIISTRING_PATCH
	PY_ASCIISTRING_PATCH(&lsa_AsciiString_Type);
#endif
#ifdef PY_ASCIISTRINGLARGE_PATCH
	PY_ASCIISTRINGLARGE_PATCH(&lsa_AsciiStringLarge_Type);
#endif
#ifdef PY_BINARYSTRING_PATCH
	PY_BINARYSTRING_PATCH(&lsa_BinaryString_Type);
#endif
#ifdef PY_LUID_PATCH
	PY_LUID_PATCH(&lsa_LUID_Type);
#endif
#ifdef PY_PRIVENTRY_PATCH
	PY_PRIVENTRY_PATCH(&lsa_PrivEntry_Type);
#endif
#ifdef PY_PRIVARRAY_PATCH
	PY_PRIVARRAY_PATCH(&lsa_PrivArray_Type);
#endif
#ifdef PY_QOSINFO_PATCH
	PY_QOSINFO_PATCH(&lsa_QosInfo_Type);
#endif
#ifdef PY_OBJECTATTRIBUTE_PATCH
	PY_OBJECTATTRIBUTE_PATCH(&lsa_ObjectAttribute_Type);
#endif
#ifdef PY_AUDITLOGINFO_PATCH
	PY_AUDITLOGINFO_PATCH(&lsa_AuditLogInfo_Type);
#endif
#ifdef PY_AUDITEVENTSINFO_PATCH
	PY_AUDITEVENTSINFO_PATCH(&lsa_AuditEventsInfo_Type);
#endif
#ifdef PY_DOMAININFO_PATCH
	PY_DOMAININFO_PATCH(&lsa_DomainInfo_Type);
#endif
#ifdef PY_PDACCOUNTINFO_PATCH
	PY_PDACCOUNTINFO_PATCH(&lsa_PDAccountInfo_Type);
#endif
#ifdef PY_SERVERROLE_PATCH
	PY_SERVERROLE_PATCH(&lsa_ServerRole_Type);
#endif
#ifdef PY_REPLICASOURCEINFO_PATCH
	PY_REPLICASOURCEINFO_PATCH(&lsa_ReplicaSourceInfo_Type);
#endif
#ifdef PY_DEFAULTQUOTAINFO_PATCH
	PY_DEFAULTQUOTAINFO_PATCH(&lsa_DefaultQuotaInfo_Type);
#endif
#ifdef PY_MODIFICATIONINFO_PATCH
	PY_MODIFICATIONINFO_PATCH(&lsa_ModificationInfo_Type);
#endif
#ifdef PY_AUDITFULLSETINFO_PATCH
	PY_AUDITFULLSETINFO_PATCH(&lsa_AuditFullSetInfo_Type);
#endif
#ifdef PY_AUDITFULLQUERYINFO_PATCH
	PY_AUDITFULLQUERYINFO_PATCH(&lsa_AuditFullQueryInfo_Type);
#endif
#ifdef PY_DNSDOMAININFO_PATCH
	PY_DNSDOMAININFO_PATCH(&lsa_DnsDomainInfo_Type);
#endif
#ifdef PY_POLICYINFORMATION_PATCH
	PY_POLICYINFORMATION_PATCH(&lsa_PolicyInformation_Type);
#endif
#ifdef PY_SIDPTR_PATCH
	PY_SIDPTR_PATCH(&lsa_SidPtr_Type);
#endif
#ifdef PY_SIDARRAY_PATCH
	PY_SIDARRAY_PATCH(&lsa_SidArray_Type);
#endif
#ifdef PY_DOMAINLIST_PATCH
	PY_DOMAINLIST_PATCH(&lsa_DomainList_Type);
#endif
#ifdef PY_TRANSLATEDSID_PATCH
	PY_TRANSLATEDSID_PATCH(&lsa_TranslatedSid_Type);
#endif
#ifdef PY_TRANSSIDARRAY_PATCH
	PY_TRANSSIDARRAY_PATCH(&lsa_TransSidArray_Type);
#endif
#ifdef PY_REFDOMAINLIST_PATCH
	PY_REFDOMAINLIST_PATCH(&lsa_RefDomainList_Type);
#endif
#ifdef PY_TRANSLATEDNAME_PATCH
	PY_TRANSLATEDNAME_PATCH(&lsa_TranslatedName_Type);
#endif
#ifdef PY_TRANSNAMEARRAY_PATCH
	PY_TRANSNAMEARRAY_PATCH(&lsa_TransNameArray_Type);
#endif
#ifdef PY_LUIDATTRIBUTE_PATCH
	PY_LUIDATTRIBUTE_PATCH(&lsa_LUIDAttribute_Type);
#endif
#ifdef PY_PRIVILEGESET_PATCH
	PY_PRIVILEGESET_PATCH(&lsa_PrivilegeSet_Type);
#endif
#ifdef PY_DATA_BUF_PATCH
	PY_DATA_BUF_PATCH(&lsa_DATA_BUF_Type);
#endif
#ifdef PY_DATA_BUF2_PATCH
	PY_DATA_BUF2_PATCH(&lsa_DATA_BUF2_Type);
#endif
#ifdef PY_TRUSTDOMAININFONAME_PATCH
	PY_TRUSTDOMAININFONAME_PATCH(&lsa_TrustDomainInfoName_Type);
#endif
#ifdef PY_TRUSTDOMAININFOCONTROLLERS_PATCH
	PY_TRUSTDOMAININFOCONTROLLERS_PATCH(&lsa_TrustDomainInfoControllers_Type);
#endif
#ifdef PY_TRUSTDOMAININFOPOSIXOFFSET_PATCH
	PY_TRUSTDOMAININFOPOSIXOFFSET_PATCH(&lsa_TrustDomainInfoPosixOffset_Type);
#endif
#ifdef PY_TRUSTDOMAININFOPASSWORD_PATCH
	PY_TRUSTDOMAININFOPASSWORD_PATCH(&lsa_TrustDomainInfoPassword_Type);
#endif
#ifdef PY_TRUSTDOMAININFOBASIC_PATCH
	PY_TRUSTDOMAININFOBASIC_PATCH(&lsa_TrustDomainInfoBasic_Type);
#endif
#ifdef PY_TRUSTDOMAININFOINFOEX_PATCH
	PY_TRUSTDOMAININFOINFOEX_PATCH(&lsa_TrustDomainInfoInfoEx_Type);
#endif
#ifdef PY_TRUSTDOMAININFOBUFFER_PATCH
	PY_TRUSTDOMAININFOBUFFER_PATCH(&lsa_TrustDomainInfoBuffer_Type);
#endif
#ifdef PY_TRUSTDOMAININFOAUTHINFO_PATCH
	PY_TRUSTDOMAININFOAUTHINFO_PATCH(&lsa_TrustDomainInfoAuthInfo_Type);
#endif
#ifdef PY_TRUSTDOMAININFOFULLINFO_PATCH
	PY_TRUSTDOMAININFOFULLINFO_PATCH(&lsa_TrustDomainInfoFullInfo_Type);
#endif
#ifdef PY_TRUSTDOMAININFOAUTHINFOINTERNAL_PATCH
	PY_TRUSTDOMAININFOAUTHINFOINTERNAL_PATCH(&lsa_TrustDomainInfoAuthInfoInternal_Type);
#endif
#ifdef PY_TRUSTDOMAININFOFULLINFOINTERNAL_PATCH
	PY_TRUSTDOMAININFOFULLINFOINTERNAL_PATCH(&lsa_TrustDomainInfoFullInfoInternal_Type);
#endif
#ifdef PY_TRUSTDOMAININFOINFOEX2INTERNAL_PATCH
	PY_TRUSTDOMAININFOINFOEX2INTERNAL_PATCH(&lsa_TrustDomainInfoInfoEx2Internal_Type);
#endif
#ifdef PY_TRUSTDOMAININFOFULLINFO2INTERNAL_PATCH
	PY_TRUSTDOMAININFOFULLINFO2INTERNAL_PATCH(&lsa_TrustDomainInfoFullInfo2Internal_Type);
#endif
#ifdef PY_TRUSTDOMAININFOSUPPORTEDENCTYPES_PATCH
	PY_TRUSTDOMAININFOSUPPORTEDENCTYPES_PATCH(&lsa_TrustDomainInfoSupportedEncTypes_Type);
#endif
#ifdef PY_TRUSTEDDOMAININFO_PATCH
	PY_TRUSTEDDOMAININFO_PATCH(&lsa_TrustedDomainInfo_Type);
#endif
#ifdef PY_DATA_BUF_PTR_PATCH
	PY_DATA_BUF_PTR_PATCH(&lsa_DATA_BUF_PTR_Type);
#endif
#ifdef PY_RIGHTATTRIBUTE_PATCH
	PY_RIGHTATTRIBUTE_PATCH(&lsa_RightAttribute_Type);
#endif
#ifdef PY_RIGHTSET_PATCH
	PY_RIGHTSET_PATCH(&lsa_RightSet_Type);
#endif
#ifdef PY_DOMAINLISTEX_PATCH
	PY_DOMAINLISTEX_PATCH(&lsa_DomainListEx_Type);
#endif
#ifdef PY_DOMAININFOKERBEROS_PATCH
	PY_DOMAININFOKERBEROS_PATCH(&lsa_DomainInfoKerberos_Type);
#endif
#ifdef PY_DOMAININFOEFS_PATCH
	PY_DOMAININFOEFS_PATCH(&lsa_DomainInfoEfs_Type);
#endif
#ifdef PY_DOMAININFORMATIONPOLICY_PATCH
	PY_DOMAININFORMATIONPOLICY_PATCH(&lsa_DomainInformationPolicy_Type);
#endif
#ifdef PY_TRANSLATEDNAME2_PATCH
	PY_TRANSLATEDNAME2_PATCH(&lsa_TranslatedName2_Type);
#endif
#ifdef PY_TRANSNAMEARRAY2_PATCH
	PY_TRANSNAMEARRAY2_PATCH(&lsa_TransNameArray2_Type);
#endif
#ifdef PY_TRANSLATEDSID2_PATCH
	PY_TRANSLATEDSID2_PATCH(&lsa_TranslatedSid2_Type);
#endif
#ifdef PY_TRANSSIDARRAY2_PATCH
	PY_TRANSSIDARRAY2_PATCH(&lsa_TransSidArray2_Type);
#endif
#ifdef PY_TRANSLATEDSID3_PATCH
	PY_TRANSLATEDSID3_PATCH(&lsa_TranslatedSid3_Type);
#endif
#ifdef PY_TRANSSIDARRAY3_PATCH
	PY_TRANSSIDARRAY3_PATCH(&lsa_TransSidArray3_Type);
#endif
#ifdef PY_FORESTTRUSTBINARYDATA_PATCH
	PY_FORESTTRUSTBINARYDATA_PATCH(&lsa_ForestTrustBinaryData_Type);
#endif
#ifdef PY_FORESTTRUSTDOMAININFO_PATCH
	PY_FORESTTRUSTDOMAININFO_PATCH(&lsa_ForestTrustDomainInfo_Type);
#endif
#ifdef PY_FORESTTRUSTDATA_PATCH
	PY_FORESTTRUSTDATA_PATCH(&lsa_ForestTrustData_Type);
#endif
#ifdef PY_FORESTTRUSTRECORD_PATCH
	PY_FORESTTRUSTRECORD_PATCH(&lsa_ForestTrustRecord_Type);
#endif
#ifdef PY_FORESTTRUSTINFORMATION_PATCH
	PY_FORESTTRUSTINFORMATION_PATCH(&lsa_ForestTrustInformation_Type);
#endif
#ifdef PY_FORESTTRUSTCOLLISIONRECORD_PATCH
	PY_FORESTTRUSTCOLLISIONRECORD_PATCH(&lsa_ForestTrustCollisionRecord_Type);
#endif
#ifdef PY_FORESTTRUSTCOLLISIONINFO_PATCH
	PY_FORESTTRUSTCOLLISIONINFO_PATCH(&lsa_ForestTrustCollisionInfo_Type);
#endif
#ifdef PY_CLOSE_PATCH
	PY_CLOSE_PATCH(&lsa_Close_Type);
#endif
#ifdef PY_DELETE_PATCH
	PY_DELETE_PATCH(&lsa_Delete_Type);
#endif
#ifdef PY_ENUMPRIVS_PATCH
	PY_ENUMPRIVS_PATCH(&lsa_EnumPrivs_Type);
#endif
#ifdef PY_QUERYSECURITY_PATCH
	PY_QUERYSECURITY_PATCH(&lsa_QuerySecurity_Type);
#endif
#ifdef PY_SETSECOBJ_PATCH
	PY_SETSECOBJ_PATCH(&lsa_SetSecObj_Type);
#endif
#ifdef PY_OPENPOLICY_PATCH
	PY_OPENPOLICY_PATCH(&lsa_OpenPolicy_Type);
#endif
#ifdef PY_QUERYINFOPOLICY_PATCH
	PY_QUERYINFOPOLICY_PATCH(&lsa_QueryInfoPolicy_Type);
#endif
#ifdef PY_SETINFOPOLICY_PATCH
	PY_SETINFOPOLICY_PATCH(&lsa_SetInfoPolicy_Type);
#endif
#ifdef PY_CREATEACCOUNT_PATCH
	PY_CREATEACCOUNT_PATCH(&lsa_CreateAccount_Type);
#endif
#ifdef PY_ENUMACCOUNTS_PATCH
	PY_ENUMACCOUNTS_PATCH(&lsa_EnumAccounts_Type);
#endif
#ifdef PY_CREATETRUSTEDDOMAIN_PATCH
	PY_CREATETRUSTEDDOMAIN_PATCH(&lsa_CreateTrustedDomain_Type);
#endif
#ifdef PY_ENUMTRUSTDOM_PATCH
	PY_ENUMTRUSTDOM_PATCH(&lsa_EnumTrustDom_Type);
#endif
#ifdef PY_LOOKUPNAMES_PATCH
	PY_LOOKUPNAMES_PATCH(&lsa_LookupNames_Type);
#endif
#ifdef PY_LOOKUPSIDS_PATCH
	PY_LOOKUPSIDS_PATCH(&lsa_LookupSids_Type);
#endif
#ifdef PY_CREATESECRET_PATCH
	PY_CREATESECRET_PATCH(&lsa_CreateSecret_Type);
#endif
#ifdef PY_OPENACCOUNT_PATCH
	PY_OPENACCOUNT_PATCH(&lsa_OpenAccount_Type);
#endif
#ifdef PY_ENUMPRIVSACCOUNT_PATCH
	PY_ENUMPRIVSACCOUNT_PATCH(&lsa_EnumPrivsAccount_Type);
#endif
#ifdef PY_ADDPRIVILEGESTOACCOUNT_PATCH
	PY_ADDPRIVILEGESTOACCOUNT_PATCH(&lsa_AddPrivilegesToAccount_Type);
#endif
#ifdef PY_REMOVEPRIVILEGESFROMACCOUNT_PATCH
	PY_REMOVEPRIVILEGESFROMACCOUNT_PATCH(&lsa_RemovePrivilegesFromAccount_Type);
#endif
#ifdef PY_GETSYSTEMACCESSACCOUNT_PATCH
	PY_GETSYSTEMACCESSACCOUNT_PATCH(&lsa_GetSystemAccessAccount_Type);
#endif
#ifdef PY_SETSYSTEMACCESSACCOUNT_PATCH
	PY_SETSYSTEMACCESSACCOUNT_PATCH(&lsa_SetSystemAccessAccount_Type);
#endif
#ifdef PY_OPENTRUSTEDDOMAIN_PATCH
	PY_OPENTRUSTEDDOMAIN_PATCH(&lsa_OpenTrustedDomain_Type);
#endif
#ifdef PY_QUERYTRUSTEDDOMAININFO_PATCH
	PY_QUERYTRUSTEDDOMAININFO_PATCH(&lsa_QueryTrustedDomainInfo_Type);
#endif
#ifdef PY_SETINFORMATIONTRUSTEDDOMAIN_PATCH
	PY_SETINFORMATIONTRUSTEDDOMAIN_PATCH(&lsa_SetInformationTrustedDomain_Type);
#endif
#ifdef PY_OPENSECRET_PATCH
	PY_OPENSECRET_PATCH(&lsa_OpenSecret_Type);
#endif
#ifdef PY_SETSECRET_PATCH
	PY_SETSECRET_PATCH(&lsa_SetSecret_Type);
#endif
#ifdef PY_QUERYSECRET_PATCH
	PY_QUERYSECRET_PATCH(&lsa_QuerySecret_Type);
#endif
#ifdef PY_LOOKUPPRIVVALUE_PATCH
	PY_LOOKUPPRIVVALUE_PATCH(&lsa_LookupPrivValue_Type);
#endif
#ifdef PY_LOOKUPPRIVNAME_PATCH
	PY_LOOKUPPRIVNAME_PATCH(&lsa_LookupPrivName_Type);
#endif
#ifdef PY_LOOKUPPRIVDISPLAYNAME_PATCH
	PY_LOOKUPPRIVDISPLAYNAME_PATCH(&lsa_LookupPrivDisplayName_Type);
#endif
#ifdef PY_DELETEOBJECT_PATCH
	PY_DELETEOBJECT_PATCH(&lsa_DeleteObject_Type);
#endif
#ifdef PY_ENUMACCOUNTSWITHUSERRIGHT_PATCH
	PY_ENUMACCOUNTSWITHUSERRIGHT_PATCH(&lsa_EnumAccountsWithUserRight_Type);
#endif
#ifdef PY_ENUMACCOUNTRIGHTS_PATCH
	PY_ENUMACCOUNTRIGHTS_PATCH(&lsa_EnumAccountRights_Type);
#endif
#ifdef PY_ADDACCOUNTRIGHTS_PATCH
	PY_ADDACCOUNTRIGHTS_PATCH(&lsa_AddAccountRights_Type);
#endif
#ifdef PY_REMOVEACCOUNTRIGHTS_PATCH
	PY_REMOVEACCOUNTRIGHTS_PATCH(&lsa_RemoveAccountRights_Type);
#endif
#ifdef PY_QUERYTRUSTEDDOMAININFOBYSID_PATCH
	PY_QUERYTRUSTEDDOMAININFOBYSID_PATCH(&lsa_QueryTrustedDomainInfoBySid_Type);
#endif
#ifdef PY_SETTRUSTEDDOMAININFO_PATCH
	PY_SETTRUSTEDDOMAININFO_PATCH(&lsa_SetTrustedDomainInfo_Type);
#endif
#ifdef PY_DELETETRUSTEDDOMAIN_PATCH
	PY_DELETETRUSTEDDOMAIN_PATCH(&lsa_DeleteTrustedDomain_Type);
#endif
#ifdef PY_STOREPRIVATEDATA_PATCH
	PY_STOREPRIVATEDATA_PATCH(&lsa_StorePrivateData_Type);
#endif
#ifdef PY_RETRIEVEPRIVATEDATA_PATCH
	PY_RETRIEVEPRIVATEDATA_PATCH(&lsa_RetrievePrivateData_Type);
#endif
#ifdef PY_OPENPOLICY2_PATCH
	PY_OPENPOLICY2_PATCH(&lsa_OpenPolicy2_Type);
#endif
#ifdef PY_GETUSERNAME_PATCH
	PY_GETUSERNAME_PATCH(&lsa_GetUserName_Type);
#endif
#ifdef PY_QUERYINFOPOLICY2_PATCH
	PY_QUERYINFOPOLICY2_PATCH(&lsa_QueryInfoPolicy2_Type);
#endif
#ifdef PY_SETINFOPOLICY2_PATCH
	PY_SETINFOPOLICY2_PATCH(&lsa_SetInfoPolicy2_Type);
#endif
#ifdef PY_QUERYTRUSTEDDOMAININFOBYNAME_PATCH
	PY_QUERYTRUSTEDDOMAININFOBYNAME_PATCH(&lsa_QueryTrustedDomainInfoByName_Type);
#endif
#ifdef PY_SETTRUSTEDDOMAININFOBYNAME_PATCH
	PY_SETTRUSTEDDOMAININFOBYNAME_PATCH(&lsa_SetTrustedDomainInfoByName_Type);
#endif
#ifdef PY_ENUMTRUSTEDDOMAINSEX_PATCH
	PY_ENUMTRUSTEDDOMAINSEX_PATCH(&lsa_EnumTrustedDomainsEx_Type);
#endif
#ifdef PY_CREATETRUSTEDDOMAINEX_PATCH
	PY_CREATETRUSTEDDOMAINEX_PATCH(&lsa_CreateTrustedDomainEx_Type);
#endif
#ifdef PY_CLOSETRUSTEDDOMAINEX_PATCH
	PY_CLOSETRUSTEDDOMAINEX_PATCH(&lsa_CloseTrustedDomainEx_Type);
#endif
#ifdef PY_QUERYDOMAININFORMATIONPOLICY_PATCH
	PY_QUERYDOMAININFORMATIONPOLICY_PATCH(&lsa_QueryDomainInformationPolicy_Type);
#endif
#ifdef PY_SETDOMAININFORMATIONPOLICY_PATCH
	PY_SETDOMAININFORMATIONPOLICY_PATCH(&lsa_SetDomainInformationPolicy_Type);
#endif
#ifdef PY_OPENTRUSTEDDOMAINBYNAME_PATCH
	PY_OPENTRUSTEDDOMAINBYNAME_PATCH(&lsa_OpenTrustedDomainByName_Type);
#endif
#ifdef PY_LOOKUPSIDS2_PATCH
	PY_LOOKUPSIDS2_PATCH(&lsa_LookupSids2_Type);
#endif
#ifdef PY_LOOKUPNAMES2_PATCH
	PY_LOOKUPNAMES2_PATCH(&lsa_LookupNames2_Type);
#endif
#ifdef PY_CREATETRUSTEDDOMAINEX2_PATCH
	PY_CREATETRUSTEDDOMAINEX2_PATCH(&lsa_CreateTrustedDomainEx2_Type);
#endif
#ifdef PY_LOOKUPNAMES3_PATCH
	PY_LOOKUPNAMES3_PATCH(&lsa_LookupNames3_Type);
#endif
#ifdef PY_LSARQUERYFORESTTRUSTINFORMATION_PATCH
	PY_LSARQUERYFORESTTRUSTINFORMATION_PATCH(&lsa_lsaRQueryForestTrustInformation_Type);
#endif
#ifdef PY_LSARSETFORESTTRUSTINFORMATION_PATCH
	PY_LSARSETFORESTTRUSTINFORMATION_PATCH(&lsa_lsaRSetForestTrustInformation_Type);
#endif
#ifdef PY_LOOKUPSIDS3_PATCH
	PY_LOOKUPSIDS3_PATCH(&lsa_LookupSids3_Type);
#endif
#ifdef PY_LOOKUPNAMES4_PATCH
	PY_LOOKUPNAMES4_PATCH(&lsa_LookupNames4_Type);
#endif
#ifdef PY_LSARPC_PATCH
	PY_LSARPC_PATCH(&lsarpc_InterfaceType);
#endif
#ifdef PY_LSARPC_ABSTRACT_SYNTAX_PATCH
	PY_LSARPC_ABSTRACT_SYNTAX_PATCH(&lsarpc_SyntaxType);
#endif
#ifdef PY_ABSTRACT_SYNTAX_PATCH
	PY_ABSTRACT_SYNTAX_PATCH(&lsarpc_SyntaxType);
#endif

	m = PyModule_Create(&moduledef);
	if (m == NULL)
		return NULL;

	PyModule_AddObject(m, "LSA_POLICY_ALL_ACCESS", PyInt_FromLong((STANDARD_RIGHTS_REQUIRED_ACCESS|LSA_POLICY_VIEW_LOCAL_INFORMATION|LSA_POLICY_VIEW_AUDIT_INFORMATION|LSA_POLICY_GET_PRIVATE_INFORMATION|LSA_POLICY_TRUST_ADMIN|LSA_POLICY_CREATE_ACCOUNT|LSA_POLICY_CREATE_SECRET|LSA_POLICY_CREATE_PRIVILEGE|LSA_POLICY_SET_DEFAULT_QUOTA_LIMITS|LSA_POLICY_SET_AUDIT_REQUIREMENTS|LSA_POLICY_AUDIT_LOG_ADMIN|LSA_POLICY_SERVER_ADMIN|LSA_POLICY_LOOKUP_NAMES|LSA_POLICY_NOTIFICATION)));
	PyModule_AddObject(m, "LSA_POLICY_READ", PyInt_FromLong((STANDARD_RIGHTS_READ_ACCESS|LSA_POLICY_VIEW_LOCAL_INFORMATION|LSA_POLICY_VIEW_AUDIT_INFORMATION|LSA_POLICY_GET_PRIVATE_INFORMATION)));
	PyModule_AddObject(m, "LSA_POLICY_WRITE", PyInt_FromLong((STANDARD_RIGHTS_READ_ACCESS|LSA_POLICY_TRUST_ADMIN|LSA_POLICY_CREATE_ACCOUNT|LSA_POLICY_CREATE_SECRET|LSA_POLICY_CREATE_PRIVILEGE|LSA_POLICY_SET_DEFAULT_QUOTA_LIMITS|LSA_POLICY_SET_AUDIT_REQUIREMENTS|LSA_POLICY_AUDIT_LOG_ADMIN|LSA_POLICY_SERVER_ADMIN)));
	PyModule_AddObject(m, "LSA_POLICY_EXECUTE", PyInt_FromLong((STANDARD_RIGHTS_EXECUTE_ACCESS|LSA_POLICY_VIEW_LOCAL_INFORMATION|LSA_POLICY_LOOKUP_NAMES)));
	PyModule_AddObject(m, "LSA_ACCOUNT_ALL_ACCESS", PyInt_FromLong((STANDARD_RIGHTS_REQUIRED_ACCESS|LSA_ACCOUNT_VIEW|LSA_ACCOUNT_ADJUST_PRIVILEGES|LSA_ACCOUNT_ADJUST_QUOTAS|LSA_ACCOUNT_ADJUST_SYSTEM_ACCESS)));
	PyModule_AddObject(m, "LSA_ACCOUNT_READ", PyInt_FromLong((STANDARD_RIGHTS_READ_ACCESS|LSA_ACCOUNT_VIEW)));
	PyModule_AddObject(m, "LSA_ACCOUNT_WRITE", PyInt_FromLong((STANDARD_RIGHTS_READ_ACCESS|LSA_ACCOUNT_ADJUST_PRIVILEGES|LSA_ACCOUNT_ADJUST_QUOTAS|LSA_ACCOUNT_ADJUST_SYSTEM_ACCESS)));
	PyModule_AddObject(m, "LSA_ACCOUNT_EXECUTE", PyInt_FromLong((STANDARD_RIGHTS_EXECUTE_ACCESS)));
	PyModule_AddObject(m, "LSA_SECRET_ALL_ACCESS", PyInt_FromLong((LSA_SECRET_QUERY_VALUE|LSA_SECRET_SET_VALUE|SEC_STD_DELETE|STANDARD_RIGHTS_READ_ACCESS|SEC_STD_WRITE_DAC|SEC_STD_WRITE_OWNER)));
	PyModule_AddObject(m, "LSA_SECRET_READ", PyInt_FromLong((LSA_SECRET_QUERY_VALUE|STANDARD_RIGHTS_READ_ACCESS)));
	PyModule_AddObject(m, "LSA_SECRET_WRITE", PyInt_FromLong((LSA_SECRET_SET_VALUE|STANDARD_RIGHTS_READ_ACCESS)));
	PyModule_AddObject(m, "LSA_SECRET_EXECUTE", PyInt_FromLong((STANDARD_RIGHTS_READ_ACCESS)));
	PyModule_AddObject(m, "LSA_TRUSTED_DOMAIN_ALL_ACCESS", PyInt_FromLong((LSA_TRUSTED_QUERY_DOMAIN_NAME|LSA_TRUSTED_QUERY_CONTROLLERS|LSA_TRUSTED_SET_CONTROLLERS|LSA_TRUSTED_QUERY_POSIX|LSA_TRUSTED_SET_POSIX|LSA_TRUSTED_SET_AUTH|LSA_TRUSTED_QUERY_AUTH|SEC_STD_DELETE|STANDARD_RIGHTS_READ_ACCESS|SEC_STD_WRITE_DAC|SEC_STD_WRITE_OWNER)));
	PyModule_AddObject(m, "LSA_TRUSTED_DOMAIN_READ", PyInt_FromLong((LSA_TRUSTED_QUERY_DOMAIN_NAME|STANDARD_RIGHTS_READ_ACCESS)));
	PyModule_AddObject(m, "LSA_TRUSTED_DOMAIN_WRITE", PyInt_FromLong((LSA_TRUSTED_SET_CONTROLLERS|LSA_TRUSTED_SET_POSIX|LSA_TRUSTED_SET_AUTH|STANDARD_RIGHTS_READ_ACCESS)));
	PyModule_AddObject(m, "LSA_TRUSTED_DOMAIN_EXECUTE", PyInt_FromLong((LSA_TRUSTED_QUERY_DOMAIN_NAME|LSA_TRUSTED_QUERY_POSIX|STANDARD_RIGHTS_READ_ACCESS)));
	PyModule_AddObject(m, "LSA_ENUM_TRUST_DOMAIN_MULTIPLIER", ndr_PyLong_FromUnsignedLongLong(60));
	PyModule_AddObject(m, "LSA_REF_DOMAIN_LIST_MULTIPLIER", ndr_PyLong_FromUnsignedLongLong(32));
	PyModule_AddObject(m, "LSA_ENUM_TRUST_DOMAIN_EX_MULTIPLIER", ndr_PyLong_FromUnsignedLongLong(82));
	PyModule_AddObject(m, "LSA_TLN_DISABLED_MASK", ndr_PyLong_FromUnsignedLongLong((uint32_t)(LSA_TLN_DISABLED_NEW|LSA_TLN_DISABLED_ADMIN|LSA_TLN_DISABLED_CONFLICT)));
	PyModule_AddObject(m, "LSA_SID_DISABLED_MASK", ndr_PyLong_FromUnsignedLongLong((uint32_t)(LSA_SID_DISABLED_ADMIN|LSA_SID_DISABLED_CONFLICT)));
	PyModule_AddObject(m, "LSA_NB_DISABLED_MASK", ndr_PyLong_FromUnsignedLongLong((uint32_t)(LSA_NB_DISABLED_ADMIN|LSA_NB_DISABLED_CONFLICT)));
	PyModule_AddObject(m, "LSA_CLIENT_REVISION_NO_DNS", ndr_PyLong_FromUnsignedLongLong(0x00000001));
	PyModule_AddObject(m, "LSA_CLIENT_REVISION_DNS", ndr_PyLong_FromUnsignedLongLong(0x00000002));
	PyModule_AddObject(m, "LSA_LOOKUP_OPTIONS_NO_ISOLATED", ndr_PyLong_FromUnsignedLongLong(0x80000000));
	PyModule_AddObject(m, "LSA_POLICY_VIEW_LOCAL_INFORMATION", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_POLICY_VIEW_LOCAL_INFORMATION));
	PyModule_AddObject(m, "LSA_POLICY_VIEW_AUDIT_INFORMATION", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_POLICY_VIEW_AUDIT_INFORMATION));
	PyModule_AddObject(m, "LSA_POLICY_GET_PRIVATE_INFORMATION", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_POLICY_GET_PRIVATE_INFORMATION));
	PyModule_AddObject(m, "LSA_POLICY_TRUST_ADMIN", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_POLICY_TRUST_ADMIN));
	PyModule_AddObject(m, "LSA_POLICY_CREATE_ACCOUNT", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_POLICY_CREATE_ACCOUNT));
	PyModule_AddObject(m, "LSA_POLICY_CREATE_SECRET", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_POLICY_CREATE_SECRET));
	PyModule_AddObject(m, "LSA_POLICY_CREATE_PRIVILEGE", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_POLICY_CREATE_PRIVILEGE));
	PyModule_AddObject(m, "LSA_POLICY_SET_DEFAULT_QUOTA_LIMITS", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_POLICY_SET_DEFAULT_QUOTA_LIMITS));
	PyModule_AddObject(m, "LSA_POLICY_SET_AUDIT_REQUIREMENTS", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_POLICY_SET_AUDIT_REQUIREMENTS));
	PyModule_AddObject(m, "LSA_POLICY_AUDIT_LOG_ADMIN", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_POLICY_AUDIT_LOG_ADMIN));
	PyModule_AddObject(m, "LSA_POLICY_SERVER_ADMIN", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_POLICY_SERVER_ADMIN));
	PyModule_AddObject(m, "LSA_POLICY_LOOKUP_NAMES", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_POLICY_LOOKUP_NAMES));
	PyModule_AddObject(m, "LSA_POLICY_NOTIFICATION", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_POLICY_NOTIFICATION));
	PyModule_AddObject(m, "LSA_ACCOUNT_VIEW", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_ACCOUNT_VIEW));
	PyModule_AddObject(m, "LSA_ACCOUNT_ADJUST_PRIVILEGES", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_ACCOUNT_ADJUST_PRIVILEGES));
	PyModule_AddObject(m, "LSA_ACCOUNT_ADJUST_QUOTAS", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_ACCOUNT_ADJUST_QUOTAS));
	PyModule_AddObject(m, "LSA_ACCOUNT_ADJUST_SYSTEM_ACCESS", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_ACCOUNT_ADJUST_SYSTEM_ACCESS));
	PyModule_AddObject(m, "LSA_SECRET_SET_VALUE", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_SECRET_SET_VALUE));
	PyModule_AddObject(m, "LSA_SECRET_QUERY_VALUE", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_SECRET_QUERY_VALUE));
	PyModule_AddObject(m, "LSA_TRUSTED_QUERY_DOMAIN_NAME", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUSTED_QUERY_DOMAIN_NAME));
	PyModule_AddObject(m, "LSA_TRUSTED_QUERY_CONTROLLERS", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUSTED_QUERY_CONTROLLERS));
	PyModule_AddObject(m, "LSA_TRUSTED_SET_CONTROLLERS", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUSTED_SET_CONTROLLERS));
	PyModule_AddObject(m, "LSA_TRUSTED_QUERY_POSIX", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUSTED_QUERY_POSIX));
	PyModule_AddObject(m, "LSA_TRUSTED_SET_POSIX", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUSTED_SET_POSIX));
	PyModule_AddObject(m, "LSA_TRUSTED_SET_AUTH", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUSTED_SET_AUTH));
	PyModule_AddObject(m, "LSA_TRUSTED_QUERY_AUTH", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUSTED_QUERY_AUTH));
	PyModule_AddObject(m, "LSA_AUDIT_POLICY_NONE", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_AUDIT_POLICY_NONE));
	PyModule_AddObject(m, "LSA_AUDIT_POLICY_SUCCESS", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_AUDIT_POLICY_SUCCESS));
	PyModule_AddObject(m, "LSA_AUDIT_POLICY_FAILURE", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_AUDIT_POLICY_FAILURE));
	PyModule_AddObject(m, "LSA_AUDIT_POLICY_ALL", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_AUDIT_POLICY_ALL));
	PyModule_AddObject(m, "LSA_AUDIT_POLICY_CLEAR", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_AUDIT_POLICY_CLEAR));
	PyModule_AddObject(m, "LSA_AUDIT_CATEGORY_SYSTEM", PyInt_FromLong((uint16_t)LSA_AUDIT_CATEGORY_SYSTEM));
	PyModule_AddObject(m, "LSA_AUDIT_CATEGORY_LOGON", PyInt_FromLong((uint16_t)LSA_AUDIT_CATEGORY_LOGON));
	PyModule_AddObject(m, "LSA_AUDIT_CATEGORY_FILE_AND_OBJECT_ACCESS", PyInt_FromLong((uint16_t)LSA_AUDIT_CATEGORY_FILE_AND_OBJECT_ACCESS));
	PyModule_AddObject(m, "LSA_AUDIT_CATEGORY_USE_OF_USER_RIGHTS", PyInt_FromLong((uint16_t)LSA_AUDIT_CATEGORY_USE_OF_USER_RIGHTS));
	PyModule_AddObject(m, "LSA_AUDIT_CATEGORY_PROCCESS_TRACKING", PyInt_FromLong((uint16_t)LSA_AUDIT_CATEGORY_PROCCESS_TRACKING));
	PyModule_AddObject(m, "LSA_AUDIT_CATEGORY_SECURITY_POLICY_CHANGES", PyInt_FromLong((uint16_t)LSA_AUDIT_CATEGORY_SECURITY_POLICY_CHANGES));
	PyModule_AddObject(m, "LSA_AUDIT_CATEGORY_ACCOUNT_MANAGEMENT", PyInt_FromLong((uint16_t)LSA_AUDIT_CATEGORY_ACCOUNT_MANAGEMENT));
	PyModule_AddObject(m, "LSA_AUDIT_CATEGORY_DIRECTORY_SERVICE_ACCESS", PyInt_FromLong((uint16_t)LSA_AUDIT_CATEGORY_DIRECTORY_SERVICE_ACCESS));
	PyModule_AddObject(m, "LSA_AUDIT_CATEGORY_ACCOUNT_LOGON", PyInt_FromLong((uint16_t)LSA_AUDIT_CATEGORY_ACCOUNT_LOGON));
	PyModule_AddObject(m, "LSA_ROLE_BACKUP", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_ROLE_BACKUP));
	PyModule_AddObject(m, "LSA_ROLE_PRIMARY", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_ROLE_PRIMARY));
	PyModule_AddObject(m, "LSA_POLICY_INFO_AUDIT_LOG", PyInt_FromLong((uint16_t)LSA_POLICY_INFO_AUDIT_LOG));
	PyModule_AddObject(m, "LSA_POLICY_INFO_AUDIT_EVENTS", PyInt_FromLong((uint16_t)LSA_POLICY_INFO_AUDIT_EVENTS));
	PyModule_AddObject(m, "LSA_POLICY_INFO_DOMAIN", PyInt_FromLong((uint16_t)LSA_POLICY_INFO_DOMAIN));
	PyModule_AddObject(m, "LSA_POLICY_INFO_PD", PyInt_FromLong((uint16_t)LSA_POLICY_INFO_PD));
	PyModule_AddObject(m, "LSA_POLICY_INFO_ACCOUNT_DOMAIN", PyInt_FromLong((uint16_t)LSA_POLICY_INFO_ACCOUNT_DOMAIN));
	PyModule_AddObject(m, "LSA_POLICY_INFO_ROLE", PyInt_FromLong((uint16_t)LSA_POLICY_INFO_ROLE));
	PyModule_AddObject(m, "LSA_POLICY_INFO_REPLICA", PyInt_FromLong((uint16_t)LSA_POLICY_INFO_REPLICA));
	PyModule_AddObject(m, "LSA_POLICY_INFO_QUOTA", PyInt_FromLong((uint16_t)LSA_POLICY_INFO_QUOTA));
	PyModule_AddObject(m, "LSA_POLICY_INFO_MOD", PyInt_FromLong((uint16_t)LSA_POLICY_INFO_MOD));
	PyModule_AddObject(m, "LSA_POLICY_INFO_AUDIT_FULL_SET", PyInt_FromLong((uint16_t)LSA_POLICY_INFO_AUDIT_FULL_SET));
	PyModule_AddObject(m, "LSA_POLICY_INFO_AUDIT_FULL_QUERY", PyInt_FromLong((uint16_t)LSA_POLICY_INFO_AUDIT_FULL_QUERY));
	PyModule_AddObject(m, "LSA_POLICY_INFO_DNS", PyInt_FromLong((uint16_t)LSA_POLICY_INFO_DNS));
	PyModule_AddObject(m, "LSA_POLICY_INFO_DNS_INT", PyInt_FromLong((uint16_t)LSA_POLICY_INFO_DNS_INT));
	PyModule_AddObject(m, "LSA_POLICY_INFO_L_ACCOUNT_DOMAIN", PyInt_FromLong((uint16_t)LSA_POLICY_INFO_L_ACCOUNT_DOMAIN));
	PyModule_AddObject(m, "SID_NAME_USE_NONE", PyInt_FromLong((uint16_t)SID_NAME_USE_NONE));
	PyModule_AddObject(m, "SID_NAME_USER", PyInt_FromLong((uint16_t)SID_NAME_USER));
	PyModule_AddObject(m, "SID_NAME_DOM_GRP", PyInt_FromLong((uint16_t)SID_NAME_DOM_GRP));
	PyModule_AddObject(m, "SID_NAME_DOMAIN", PyInt_FromLong((uint16_t)SID_NAME_DOMAIN));
	PyModule_AddObject(m, "SID_NAME_ALIAS", PyInt_FromLong((uint16_t)SID_NAME_ALIAS));
	PyModule_AddObject(m, "SID_NAME_WKN_GRP", PyInt_FromLong((uint16_t)SID_NAME_WKN_GRP));
	PyModule_AddObject(m, "SID_NAME_DELETED", PyInt_FromLong((uint16_t)SID_NAME_DELETED));
	PyModule_AddObject(m, "SID_NAME_INVALID", PyInt_FromLong((uint16_t)SID_NAME_INVALID));
	PyModule_AddObject(m, "SID_NAME_UNKNOWN", PyInt_FromLong((uint16_t)SID_NAME_UNKNOWN));
	PyModule_AddObject(m, "SID_NAME_COMPUTER", PyInt_FromLong((uint16_t)SID_NAME_COMPUTER));
	PyModule_AddObject(m, "SID_NAME_LABEL", PyInt_FromLong((uint16_t)SID_NAME_LABEL));
	PyModule_AddObject(m, "LSA_LOOKUP_NAMES_ALL", PyInt_FromLong((uint16_t)LSA_LOOKUP_NAMES_ALL));
	PyModule_AddObject(m, "LSA_LOOKUP_NAMES_DOMAINS_ONLY", PyInt_FromLong((uint16_t)LSA_LOOKUP_NAMES_DOMAINS_ONLY));
	PyModule_AddObject(m, "LSA_LOOKUP_NAMES_PRIMARY_DOMAIN_ONLY", PyInt_FromLong((uint16_t)LSA_LOOKUP_NAMES_PRIMARY_DOMAIN_ONLY));
	PyModule_AddObject(m, "LSA_LOOKUP_NAMES_UPLEVEL_TRUSTS_ONLY", PyInt_FromLong((uint16_t)LSA_LOOKUP_NAMES_UPLEVEL_TRUSTS_ONLY));
	PyModule_AddObject(m, "LSA_LOOKUP_NAMES_FOREST_TRUSTS_ONLY", PyInt_FromLong((uint16_t)LSA_LOOKUP_NAMES_FOREST_TRUSTS_ONLY));
	PyModule_AddObject(m, "LSA_LOOKUP_NAMES_UPLEVEL_TRUSTS_ONLY2", PyInt_FromLong((uint16_t)LSA_LOOKUP_NAMES_UPLEVEL_TRUSTS_ONLY2));
	PyModule_AddObject(m, "LSA_LOOKUP_NAMES_RODC_REFERRAL_TO_FULL_DC", PyInt_FromLong((uint16_t)LSA_LOOKUP_NAMES_RODC_REFERRAL_TO_FULL_DC));
	PyModule_AddObject(m, "LSA_TRUSTED_DOMAIN_INFO_NAME", PyInt_FromLong((uint16_t)LSA_TRUSTED_DOMAIN_INFO_NAME));
	PyModule_AddObject(m, "LSA_TRUSTED_DOMAIN_INFO_CONTROLLERS", PyInt_FromLong((uint16_t)LSA_TRUSTED_DOMAIN_INFO_CONTROLLERS));
	PyModule_AddObject(m, "LSA_TRUSTED_DOMAIN_INFO_POSIX_OFFSET", PyInt_FromLong((uint16_t)LSA_TRUSTED_DOMAIN_INFO_POSIX_OFFSET));
	PyModule_AddObject(m, "LSA_TRUSTED_DOMAIN_INFO_PASSWORD", PyInt_FromLong((uint16_t)LSA_TRUSTED_DOMAIN_INFO_PASSWORD));
	PyModule_AddObject(m, "LSA_TRUSTED_DOMAIN_INFO_BASIC", PyInt_FromLong((uint16_t)LSA_TRUSTED_DOMAIN_INFO_BASIC));
	PyModule_AddObject(m, "LSA_TRUSTED_DOMAIN_INFO_INFO_EX", PyInt_FromLong((uint16_t)LSA_TRUSTED_DOMAIN_INFO_INFO_EX));
	PyModule_AddObject(m, "LSA_TRUSTED_DOMAIN_INFO_AUTH_INFO", PyInt_FromLong((uint16_t)LSA_TRUSTED_DOMAIN_INFO_AUTH_INFO));
	PyModule_AddObject(m, "LSA_TRUSTED_DOMAIN_INFO_FULL_INFO", PyInt_FromLong((uint16_t)LSA_TRUSTED_DOMAIN_INFO_FULL_INFO));
	PyModule_AddObject(m, "LSA_TRUSTED_DOMAIN_INFO_AUTH_INFO_INTERNAL", PyInt_FromLong((uint16_t)LSA_TRUSTED_DOMAIN_INFO_AUTH_INFO_INTERNAL));
	PyModule_AddObject(m, "LSA_TRUSTED_DOMAIN_INFO_FULL_INFO_INTERNAL", PyInt_FromLong((uint16_t)LSA_TRUSTED_DOMAIN_INFO_FULL_INFO_INTERNAL));
	PyModule_AddObject(m, "LSA_TRUSTED_DOMAIN_INFO_INFO_EX2_INTERNAL", PyInt_FromLong((uint16_t)LSA_TRUSTED_DOMAIN_INFO_INFO_EX2_INTERNAL));
	PyModule_AddObject(m, "LSA_TRUSTED_DOMAIN_INFO_FULL_INFO_2_INTERNAL", PyInt_FromLong((uint16_t)LSA_TRUSTED_DOMAIN_INFO_FULL_INFO_2_INTERNAL));
	PyModule_AddObject(m, "LSA_TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES", PyInt_FromLong((uint16_t)LSA_TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES));
	PyModule_AddObject(m, "LSA_TRUST_DIRECTION_INBOUND", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUST_DIRECTION_INBOUND));
	PyModule_AddObject(m, "LSA_TRUST_DIRECTION_OUTBOUND", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUST_DIRECTION_OUTBOUND));
	PyModule_AddObject(m, "LSA_TRUST_TYPE_DOWNLEVEL", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUST_TYPE_DOWNLEVEL));
	PyModule_AddObject(m, "LSA_TRUST_TYPE_UPLEVEL", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUST_TYPE_UPLEVEL));
	PyModule_AddObject(m, "LSA_TRUST_TYPE_MIT", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUST_TYPE_MIT));
	PyModule_AddObject(m, "LSA_TRUST_TYPE_DCE", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUST_TYPE_DCE));
	PyModule_AddObject(m, "LSA_TRUST_ATTRIBUTE_NON_TRANSITIVE", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUST_ATTRIBUTE_NON_TRANSITIVE));
	PyModule_AddObject(m, "LSA_TRUST_ATTRIBUTE_UPLEVEL_ONLY", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUST_ATTRIBUTE_UPLEVEL_ONLY));
	PyModule_AddObject(m, "LSA_TRUST_ATTRIBUTE_QUARANTINED_DOMAIN", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUST_ATTRIBUTE_QUARANTINED_DOMAIN));
	PyModule_AddObject(m, "LSA_TRUST_ATTRIBUTE_FOREST_TRANSITIVE", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUST_ATTRIBUTE_FOREST_TRANSITIVE));
	PyModule_AddObject(m, "LSA_TRUST_ATTRIBUTE_CROSS_ORGANIZATION", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUST_ATTRIBUTE_CROSS_ORGANIZATION));
	PyModule_AddObject(m, "LSA_TRUST_ATTRIBUTE_WITHIN_FOREST", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUST_ATTRIBUTE_WITHIN_FOREST));
	PyModule_AddObject(m, "LSA_TRUST_ATTRIBUTE_TREAT_AS_EXTERNAL", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUST_ATTRIBUTE_TREAT_AS_EXTERNAL));
	PyModule_AddObject(m, "LSA_TRUST_ATTRIBUTE_USES_RC4_ENCRYPTION", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TRUST_ATTRIBUTE_USES_RC4_ENCRYPTION));
	PyModule_AddObject(m, "TRUST_AUTH_TYPE_NONE", ndr_PyLong_FromUnsignedLongLong((uint32_t)TRUST_AUTH_TYPE_NONE));
	PyModule_AddObject(m, "TRUST_AUTH_TYPE_NT4OWF", ndr_PyLong_FromUnsignedLongLong((uint32_t)TRUST_AUTH_TYPE_NT4OWF));
	PyModule_AddObject(m, "TRUST_AUTH_TYPE_CLEAR", ndr_PyLong_FromUnsignedLongLong((uint32_t)TRUST_AUTH_TYPE_CLEAR));
	PyModule_AddObject(m, "TRUST_AUTH_TYPE_VERSION", ndr_PyLong_FromUnsignedLongLong((uint32_t)TRUST_AUTH_TYPE_VERSION));
	PyModule_AddObject(m, "LSA_POLICY_KERBEROS_VALIDATE_CLIENT", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_POLICY_KERBEROS_VALIDATE_CLIENT));
	PyModule_AddObject(m, "LSA_DOMAIN_INFO_POLICY_EFS", PyInt_FromLong((uint16_t)LSA_DOMAIN_INFO_POLICY_EFS));
	PyModule_AddObject(m, "LSA_DOMAIN_INFO_POLICY_KERBEROS", PyInt_FromLong((uint16_t)LSA_DOMAIN_INFO_POLICY_KERBEROS));
	PyModule_AddObject(m, "LSA_LOOKUP_OPTION_SEARCH_ISOLATED_NAMES", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_LOOKUP_OPTION_SEARCH_ISOLATED_NAMES));
	PyModule_AddObject(m, "LSA_LOOKUP_OPTION_SEARCH_ISOLATED_NAMES_LOCAL", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_LOOKUP_OPTION_SEARCH_ISOLATED_NAMES_LOCAL));
	PyModule_AddObject(m, "LSA_CLIENT_REVISION_1", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_CLIENT_REVISION_1));
	PyModule_AddObject(m, "LSA_CLIENT_REVISION_2", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_CLIENT_REVISION_2));
	PyModule_AddObject(m, "LSA_TLN_DISABLED_NEW", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TLN_DISABLED_NEW));
	PyModule_AddObject(m, "LSA_TLN_DISABLED_ADMIN", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TLN_DISABLED_ADMIN));
	PyModule_AddObject(m, "LSA_TLN_DISABLED_CONFLICT", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_TLN_DISABLED_CONFLICT));
	PyModule_AddObject(m, "LSA_SID_DISABLED_ADMIN", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_SID_DISABLED_ADMIN));
	PyModule_AddObject(m, "LSA_SID_DISABLED_CONFLICT", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_SID_DISABLED_CONFLICT));
	PyModule_AddObject(m, "LSA_NB_DISABLED_ADMIN", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_NB_DISABLED_ADMIN));
	PyModule_AddObject(m, "LSA_NB_DISABLED_CONFLICT", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_NB_DISABLED_CONFLICT));
	PyModule_AddObject(m, "LSA_FOREST_TRUST_TOP_LEVEL_NAME", PyInt_FromLong((uint16_t)LSA_FOREST_TRUST_TOP_LEVEL_NAME));
	PyModule_AddObject(m, "LSA_FOREST_TRUST_TOP_LEVEL_NAME_EX", PyInt_FromLong((uint16_t)LSA_FOREST_TRUST_TOP_LEVEL_NAME_EX));
	PyModule_AddObject(m, "LSA_FOREST_TRUST_DOMAIN_INFO", PyInt_FromLong((uint16_t)LSA_FOREST_TRUST_DOMAIN_INFO));
	PyModule_AddObject(m, "LSA_FOREST_TRUST_RECORD_TYPE_LAST", PyInt_FromLong((uint16_t)LSA_FOREST_TRUST_RECORD_TYPE_LAST));
	PyModule_AddObject(m, "LSA_FOREST_TRUST_COLLISION_TDO", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_FOREST_TRUST_COLLISION_TDO));
	PyModule_AddObject(m, "LSA_FOREST_TRUST_COLLISION_XREF", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_FOREST_TRUST_COLLISION_XREF));
	PyModule_AddObject(m, "LSA_FOREST_TRUST_COLLISION_OTHER", ndr_PyLong_FromUnsignedLongLong((uint32_t)LSA_FOREST_TRUST_COLLISION_OTHER));
	Py_INCREF((PyObject *)(void *)&lsa_String_Type);
	PyModule_AddObject(m, "String", (PyObject *)(void *)&lsa_String_Type);
	Py_INCREF((PyObject *)(void *)&lsa_StringLarge_Type);
	PyModule_AddObject(m, "StringLarge", (PyObject *)(void *)&lsa_StringLarge_Type);
	Py_INCREF((PyObject *)(void *)&lsa_Strings_Type);
	PyModule_AddObject(m, "Strings", (PyObject *)(void *)&lsa_Strings_Type);
	Py_INCREF((PyObject *)(void *)&lsa_AsciiString_Type);
	PyModule_AddObject(m, "AsciiString", (PyObject *)(void *)&lsa_AsciiString_Type);
	Py_INCREF((PyObject *)(void *)&lsa_AsciiStringLarge_Type);
	PyModule_AddObject(m, "AsciiStringLarge", (PyObject *)(void *)&lsa_AsciiStringLarge_Type);
	Py_INCREF((PyObject *)(void *)&lsa_BinaryString_Type);
	PyModule_AddObject(m, "BinaryString", (PyObject *)(void *)&lsa_BinaryString_Type);
	Py_INCREF((PyObject *)(void *)&lsa_LUID_Type);
	PyModule_AddObject(m, "LUID", (PyObject *)(void *)&lsa_LUID_Type);
	Py_INCREF((PyObject *)(void *)&lsa_PrivEntry_Type);
	PyModule_AddObject(m, "PrivEntry", (PyObject *)(void *)&lsa_PrivEntry_Type);
	Py_INCREF((PyObject *)(void *)&lsa_PrivArray_Type);
	PyModule_AddObject(m, "PrivArray", (PyObject *)(void *)&lsa_PrivArray_Type);
	Py_INCREF((PyObject *)(void *)&lsa_QosInfo_Type);
	PyModule_AddObject(m, "QosInfo", (PyObject *)(void *)&lsa_QosInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_ObjectAttribute_Type);
	PyModule_AddObject(m, "ObjectAttribute", (PyObject *)(void *)&lsa_ObjectAttribute_Type);
	Py_INCREF((PyObject *)(void *)&lsa_AuditLogInfo_Type);
	PyModule_AddObject(m, "AuditLogInfo", (PyObject *)(void *)&lsa_AuditLogInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_AuditEventsInfo_Type);
	PyModule_AddObject(m, "AuditEventsInfo", (PyObject *)(void *)&lsa_AuditEventsInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_DomainInfo_Type);
	PyModule_AddObject(m, "DomainInfo", (PyObject *)(void *)&lsa_DomainInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_PDAccountInfo_Type);
	PyModule_AddObject(m, "PDAccountInfo", (PyObject *)(void *)&lsa_PDAccountInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_ServerRole_Type);
	PyModule_AddObject(m, "ServerRole", (PyObject *)(void *)&lsa_ServerRole_Type);
	Py_INCREF((PyObject *)(void *)&lsa_ReplicaSourceInfo_Type);
	PyModule_AddObject(m, "ReplicaSourceInfo", (PyObject *)(void *)&lsa_ReplicaSourceInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_DefaultQuotaInfo_Type);
	PyModule_AddObject(m, "DefaultQuotaInfo", (PyObject *)(void *)&lsa_DefaultQuotaInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_ModificationInfo_Type);
	PyModule_AddObject(m, "ModificationInfo", (PyObject *)(void *)&lsa_ModificationInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_AuditFullSetInfo_Type);
	PyModule_AddObject(m, "AuditFullSetInfo", (PyObject *)(void *)&lsa_AuditFullSetInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_AuditFullQueryInfo_Type);
	PyModule_AddObject(m, "AuditFullQueryInfo", (PyObject *)(void *)&lsa_AuditFullQueryInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_DnsDomainInfo_Type);
	PyModule_AddObject(m, "DnsDomainInfo", (PyObject *)(void *)&lsa_DnsDomainInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_PolicyInformation_Type);
	PyModule_AddObject(m, "PolicyInformation", (PyObject *)(void *)&lsa_PolicyInformation_Type);
	Py_INCREF((PyObject *)(void *)&lsa_SidPtr_Type);
	PyModule_AddObject(m, "SidPtr", (PyObject *)(void *)&lsa_SidPtr_Type);
	Py_INCREF((PyObject *)(void *)&lsa_SidArray_Type);
	PyModule_AddObject(m, "SidArray", (PyObject *)(void *)&lsa_SidArray_Type);
	Py_INCREF((PyObject *)(void *)&lsa_DomainList_Type);
	PyModule_AddObject(m, "DomainList", (PyObject *)(void *)&lsa_DomainList_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TranslatedSid_Type);
	PyModule_AddObject(m, "TranslatedSid", (PyObject *)(void *)&lsa_TranslatedSid_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TransSidArray_Type);
	PyModule_AddObject(m, "TransSidArray", (PyObject *)(void *)&lsa_TransSidArray_Type);
	Py_INCREF((PyObject *)(void *)&lsa_RefDomainList_Type);
	PyModule_AddObject(m, "RefDomainList", (PyObject *)(void *)&lsa_RefDomainList_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TranslatedName_Type);
	PyModule_AddObject(m, "TranslatedName", (PyObject *)(void *)&lsa_TranslatedName_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TransNameArray_Type);
	PyModule_AddObject(m, "TransNameArray", (PyObject *)(void *)&lsa_TransNameArray_Type);
	Py_INCREF((PyObject *)(void *)&lsa_LUIDAttribute_Type);
	PyModule_AddObject(m, "LUIDAttribute", (PyObject *)(void *)&lsa_LUIDAttribute_Type);
	Py_INCREF((PyObject *)(void *)&lsa_PrivilegeSet_Type);
	PyModule_AddObject(m, "PrivilegeSet", (PyObject *)(void *)&lsa_PrivilegeSet_Type);
	Py_INCREF((PyObject *)(void *)&lsa_DATA_BUF_Type);
	PyModule_AddObject(m, "DATA_BUF", (PyObject *)(void *)&lsa_DATA_BUF_Type);
	Py_INCREF((PyObject *)(void *)&lsa_DATA_BUF2_Type);
	PyModule_AddObject(m, "DATA_BUF2", (PyObject *)(void *)&lsa_DATA_BUF2_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TrustDomainInfoName_Type);
	PyModule_AddObject(m, "TrustDomainInfoName", (PyObject *)(void *)&lsa_TrustDomainInfoName_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TrustDomainInfoControllers_Type);
	PyModule_AddObject(m, "TrustDomainInfoControllers", (PyObject *)(void *)&lsa_TrustDomainInfoControllers_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TrustDomainInfoPosixOffset_Type);
	PyModule_AddObject(m, "TrustDomainInfoPosixOffset", (PyObject *)(void *)&lsa_TrustDomainInfoPosixOffset_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TrustDomainInfoPassword_Type);
	PyModule_AddObject(m, "TrustDomainInfoPassword", (PyObject *)(void *)&lsa_TrustDomainInfoPassword_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TrustDomainInfoBasic_Type);
	PyModule_AddObject(m, "TrustDomainInfoBasic", (PyObject *)(void *)&lsa_TrustDomainInfoBasic_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TrustDomainInfoInfoEx_Type);
	PyModule_AddObject(m, "TrustDomainInfoInfoEx", (PyObject *)(void *)&lsa_TrustDomainInfoInfoEx_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TrustDomainInfoBuffer_Type);
	PyModule_AddObject(m, "TrustDomainInfoBuffer", (PyObject *)(void *)&lsa_TrustDomainInfoBuffer_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TrustDomainInfoAuthInfo_Type);
	PyModule_AddObject(m, "TrustDomainInfoAuthInfo", (PyObject *)(void *)&lsa_TrustDomainInfoAuthInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TrustDomainInfoFullInfo_Type);
	PyModule_AddObject(m, "TrustDomainInfoFullInfo", (PyObject *)(void *)&lsa_TrustDomainInfoFullInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TrustDomainInfoAuthInfoInternal_Type);
	PyModule_AddObject(m, "TrustDomainInfoAuthInfoInternal", (PyObject *)(void *)&lsa_TrustDomainInfoAuthInfoInternal_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TrustDomainInfoFullInfoInternal_Type);
	PyModule_AddObject(m, "TrustDomainInfoFullInfoInternal", (PyObject *)(void *)&lsa_TrustDomainInfoFullInfoInternal_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TrustDomainInfoInfoEx2Internal_Type);
	PyModule_AddObject(m, "TrustDomainInfoInfoEx2Internal", (PyObject *)(void *)&lsa_TrustDomainInfoInfoEx2Internal_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TrustDomainInfoFullInfo2Internal_Type);
	PyModule_AddObject(m, "TrustDomainInfoFullInfo2Internal", (PyObject *)(void *)&lsa_TrustDomainInfoFullInfo2Internal_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TrustDomainInfoSupportedEncTypes_Type);
	PyModule_AddObject(m, "TrustDomainInfoSupportedEncTypes", (PyObject *)(void *)&lsa_TrustDomainInfoSupportedEncTypes_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TrustedDomainInfo_Type);
	PyModule_AddObject(m, "TrustedDomainInfo", (PyObject *)(void *)&lsa_TrustedDomainInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_DATA_BUF_PTR_Type);
	PyModule_AddObject(m, "DATA_BUF_PTR", (PyObject *)(void *)&lsa_DATA_BUF_PTR_Type);
	Py_INCREF((PyObject *)(void *)&lsa_RightAttribute_Type);
	PyModule_AddObject(m, "RightAttribute", (PyObject *)(void *)&lsa_RightAttribute_Type);
	Py_INCREF((PyObject *)(void *)&lsa_RightSet_Type);
	PyModule_AddObject(m, "RightSet", (PyObject *)(void *)&lsa_RightSet_Type);
	Py_INCREF((PyObject *)(void *)&lsa_DomainListEx_Type);
	PyModule_AddObject(m, "DomainListEx", (PyObject *)(void *)&lsa_DomainListEx_Type);
	Py_INCREF((PyObject *)(void *)&lsa_DomainInfoKerberos_Type);
	PyModule_AddObject(m, "DomainInfoKerberos", (PyObject *)(void *)&lsa_DomainInfoKerberos_Type);
	Py_INCREF((PyObject *)(void *)&lsa_DomainInfoEfs_Type);
	PyModule_AddObject(m, "DomainInfoEfs", (PyObject *)(void *)&lsa_DomainInfoEfs_Type);
	Py_INCREF((PyObject *)(void *)&lsa_DomainInformationPolicy_Type);
	PyModule_AddObject(m, "DomainInformationPolicy", (PyObject *)(void *)&lsa_DomainInformationPolicy_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TranslatedName2_Type);
	PyModule_AddObject(m, "TranslatedName2", (PyObject *)(void *)&lsa_TranslatedName2_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TransNameArray2_Type);
	PyModule_AddObject(m, "TransNameArray2", (PyObject *)(void *)&lsa_TransNameArray2_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TranslatedSid2_Type);
	PyModule_AddObject(m, "TranslatedSid2", (PyObject *)(void *)&lsa_TranslatedSid2_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TransSidArray2_Type);
	PyModule_AddObject(m, "TransSidArray2", (PyObject *)(void *)&lsa_TransSidArray2_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TranslatedSid3_Type);
	PyModule_AddObject(m, "TranslatedSid3", (PyObject *)(void *)&lsa_TranslatedSid3_Type);
	Py_INCREF((PyObject *)(void *)&lsa_TransSidArray3_Type);
	PyModule_AddObject(m, "TransSidArray3", (PyObject *)(void *)&lsa_TransSidArray3_Type);
	Py_INCREF((PyObject *)(void *)&lsa_ForestTrustBinaryData_Type);
	PyModule_AddObject(m, "ForestTrustBinaryData", (PyObject *)(void *)&lsa_ForestTrustBinaryData_Type);
	Py_INCREF((PyObject *)(void *)&lsa_ForestTrustDomainInfo_Type);
	PyModule_AddObject(m, "ForestTrustDomainInfo", (PyObject *)(void *)&lsa_ForestTrustDomainInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_ForestTrustData_Type);
	PyModule_AddObject(m, "ForestTrustData", (PyObject *)(void *)&lsa_ForestTrustData_Type);
	Py_INCREF((PyObject *)(void *)&lsa_ForestTrustRecord_Type);
	PyModule_AddObject(m, "ForestTrustRecord", (PyObject *)(void *)&lsa_ForestTrustRecord_Type);
	Py_INCREF((PyObject *)(void *)&lsa_ForestTrustInformation_Type);
	PyModule_AddObject(m, "ForestTrustInformation", (PyObject *)(void *)&lsa_ForestTrustInformation_Type);
	Py_INCREF((PyObject *)(void *)&lsa_ForestTrustCollisionRecord_Type);
	PyModule_AddObject(m, "ForestTrustCollisionRecord", (PyObject *)(void *)&lsa_ForestTrustCollisionRecord_Type);
	Py_INCREF((PyObject *)(void *)&lsa_ForestTrustCollisionInfo_Type);
	PyModule_AddObject(m, "ForestTrustCollisionInfo", (PyObject *)(void *)&lsa_ForestTrustCollisionInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_Close_Type);
	PyModule_AddObject(m, "Close", (PyObject *)(void *)&lsa_Close_Type);
	Py_INCREF((PyObject *)(void *)&lsa_Delete_Type);
	PyModule_AddObject(m, "Delete", (PyObject *)(void *)&lsa_Delete_Type);
	Py_INCREF((PyObject *)(void *)&lsa_EnumPrivs_Type);
	PyModule_AddObject(m, "EnumPrivs", (PyObject *)(void *)&lsa_EnumPrivs_Type);
	Py_INCREF((PyObject *)(void *)&lsa_QuerySecurity_Type);
	PyModule_AddObject(m, "QuerySecurity", (PyObject *)(void *)&lsa_QuerySecurity_Type);
	Py_INCREF((PyObject *)(void *)&lsa_SetSecObj_Type);
	PyModule_AddObject(m, "SetSecObj", (PyObject *)(void *)&lsa_SetSecObj_Type);
	Py_INCREF((PyObject *)(void *)&lsa_OpenPolicy_Type);
	PyModule_AddObject(m, "OpenPolicy", (PyObject *)(void *)&lsa_OpenPolicy_Type);
	Py_INCREF((PyObject *)(void *)&lsa_QueryInfoPolicy_Type);
	PyModule_AddObject(m, "QueryInfoPolicy", (PyObject *)(void *)&lsa_QueryInfoPolicy_Type);
	Py_INCREF((PyObject *)(void *)&lsa_SetInfoPolicy_Type);
	PyModule_AddObject(m, "SetInfoPolicy", (PyObject *)(void *)&lsa_SetInfoPolicy_Type);
	Py_INCREF((PyObject *)(void *)&lsa_CreateAccount_Type);
	PyModule_AddObject(m, "CreateAccount", (PyObject *)(void *)&lsa_CreateAccount_Type);
	Py_INCREF((PyObject *)(void *)&lsa_EnumAccounts_Type);
	PyModule_AddObject(m, "EnumAccounts", (PyObject *)(void *)&lsa_EnumAccounts_Type);
	Py_INCREF((PyObject *)(void *)&lsa_CreateTrustedDomain_Type);
	PyModule_AddObject(m, "CreateTrustedDomain", (PyObject *)(void *)&lsa_CreateTrustedDomain_Type);
	Py_INCREF((PyObject *)(void *)&lsa_EnumTrustDom_Type);
	PyModule_AddObject(m, "EnumTrustDom", (PyObject *)(void *)&lsa_EnumTrustDom_Type);
	Py_INCREF((PyObject *)(void *)&lsa_LookupNames_Type);
	PyModule_AddObject(m, "LookupNames", (PyObject *)(void *)&lsa_LookupNames_Type);
	Py_INCREF((PyObject *)(void *)&lsa_LookupSids_Type);
	PyModule_AddObject(m, "LookupSids", (PyObject *)(void *)&lsa_LookupSids_Type);
	Py_INCREF((PyObject *)(void *)&lsa_CreateSecret_Type);
	PyModule_AddObject(m, "CreateSecret", (PyObject *)(void *)&lsa_CreateSecret_Type);
	Py_INCREF((PyObject *)(void *)&lsa_OpenAccount_Type);
	PyModule_AddObject(m, "OpenAccount", (PyObject *)(void *)&lsa_OpenAccount_Type);
	Py_INCREF((PyObject *)(void *)&lsa_EnumPrivsAccount_Type);
	PyModule_AddObject(m, "EnumPrivsAccount", (PyObject *)(void *)&lsa_EnumPrivsAccount_Type);
	Py_INCREF((PyObject *)(void *)&lsa_AddPrivilegesToAccount_Type);
	PyModule_AddObject(m, "AddPrivilegesToAccount", (PyObject *)(void *)&lsa_AddPrivilegesToAccount_Type);
	Py_INCREF((PyObject *)(void *)&lsa_RemovePrivilegesFromAccount_Type);
	PyModule_AddObject(m, "RemovePrivilegesFromAccount", (PyObject *)(void *)&lsa_RemovePrivilegesFromAccount_Type);
	Py_INCREF((PyObject *)(void *)&lsa_GetSystemAccessAccount_Type);
	PyModule_AddObject(m, "GetSystemAccessAccount", (PyObject *)(void *)&lsa_GetSystemAccessAccount_Type);
	Py_INCREF((PyObject *)(void *)&lsa_SetSystemAccessAccount_Type);
	PyModule_AddObject(m, "SetSystemAccessAccount", (PyObject *)(void *)&lsa_SetSystemAccessAccount_Type);
	Py_INCREF((PyObject *)(void *)&lsa_OpenTrustedDomain_Type);
	PyModule_AddObject(m, "OpenTrustedDomain", (PyObject *)(void *)&lsa_OpenTrustedDomain_Type);
	Py_INCREF((PyObject *)(void *)&lsa_QueryTrustedDomainInfo_Type);
	PyModule_AddObject(m, "QueryTrustedDomainInfo", (PyObject *)(void *)&lsa_QueryTrustedDomainInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_SetInformationTrustedDomain_Type);
	PyModule_AddObject(m, "SetInformationTrustedDomain", (PyObject *)(void *)&lsa_SetInformationTrustedDomain_Type);
	Py_INCREF((PyObject *)(void *)&lsa_OpenSecret_Type);
	PyModule_AddObject(m, "OpenSecret", (PyObject *)(void *)&lsa_OpenSecret_Type);
	Py_INCREF((PyObject *)(void *)&lsa_SetSecret_Type);
	PyModule_AddObject(m, "SetSecret", (PyObject *)(void *)&lsa_SetSecret_Type);
	Py_INCREF((PyObject *)(void *)&lsa_QuerySecret_Type);
	PyModule_AddObject(m, "QuerySecret", (PyObject *)(void *)&lsa_QuerySecret_Type);
	Py_INCREF((PyObject *)(void *)&lsa_LookupPrivValue_Type);
	PyModule_AddObject(m, "LookupPrivValue", (PyObject *)(void *)&lsa_LookupPrivValue_Type);
	Py_INCREF((PyObject *)(void *)&lsa_LookupPrivName_Type);
	PyModule_AddObject(m, "LookupPrivName", (PyObject *)(void *)&lsa_LookupPrivName_Type);
	Py_INCREF((PyObject *)(void *)&lsa_LookupPrivDisplayName_Type);
	PyModule_AddObject(m, "LookupPrivDisplayName", (PyObject *)(void *)&lsa_LookupPrivDisplayName_Type);
	Py_INCREF((PyObject *)(void *)&lsa_DeleteObject_Type);
	PyModule_AddObject(m, "DeleteObject", (PyObject *)(void *)&lsa_DeleteObject_Type);
	Py_INCREF((PyObject *)(void *)&lsa_EnumAccountsWithUserRight_Type);
	PyModule_AddObject(m, "EnumAccountsWithUserRight", (PyObject *)(void *)&lsa_EnumAccountsWithUserRight_Type);
	Py_INCREF((PyObject *)(void *)&lsa_EnumAccountRights_Type);
	PyModule_AddObject(m, "EnumAccountRights", (PyObject *)(void *)&lsa_EnumAccountRights_Type);
	Py_INCREF((PyObject *)(void *)&lsa_AddAccountRights_Type);
	PyModule_AddObject(m, "AddAccountRights", (PyObject *)(void *)&lsa_AddAccountRights_Type);
	Py_INCREF((PyObject *)(void *)&lsa_RemoveAccountRights_Type);
	PyModule_AddObject(m, "RemoveAccountRights", (PyObject *)(void *)&lsa_RemoveAccountRights_Type);
	Py_INCREF((PyObject *)(void *)&lsa_QueryTrustedDomainInfoBySid_Type);
	PyModule_AddObject(m, "QueryTrustedDomainInfoBySid", (PyObject *)(void *)&lsa_QueryTrustedDomainInfoBySid_Type);
	Py_INCREF((PyObject *)(void *)&lsa_SetTrustedDomainInfo_Type);
	PyModule_AddObject(m, "SetTrustedDomainInfo", (PyObject *)(void *)&lsa_SetTrustedDomainInfo_Type);
	Py_INCREF((PyObject *)(void *)&lsa_DeleteTrustedDomain_Type);
	PyModule_AddObject(m, "DeleteTrustedDomain", (PyObject *)(void *)&lsa_DeleteTrustedDomain_Type);
	Py_INCREF((PyObject *)(void *)&lsa_StorePrivateData_Type);
	PyModule_AddObject(m, "StorePrivateData", (PyObject *)(void *)&lsa_StorePrivateData_Type);
	Py_INCREF((PyObject *)(void *)&lsa_RetrievePrivateData_Type);
	PyModule_AddObject(m, "RetrievePrivateData", (PyObject *)(void *)&lsa_RetrievePrivateData_Type);
	Py_INCREF((PyObject *)(void *)&lsa_OpenPolicy2_Type);
	PyModule_AddObject(m, "OpenPolicy2", (PyObject *)(void *)&lsa_OpenPolicy2_Type);
	Py_INCREF((PyObject *)(void *)&lsa_GetUserName_Type);
	PyModule_AddObject(m, "GetUserName", (PyObject *)(void *)&lsa_GetUserName_Type);
	Py_INCREF((PyObject *)(void *)&lsa_QueryInfoPolicy2_Type);
	PyModule_AddObject(m, "QueryInfoPolicy2", (PyObject *)(void *)&lsa_QueryInfoPolicy2_Type);
	Py_INCREF((PyObject *)(void *)&lsa_SetInfoPolicy2_Type);
	PyModule_AddObject(m, "SetInfoPolicy2", (PyObject *)(void *)&lsa_SetInfoPolicy2_Type);
	Py_INCREF((PyObject *)(void *)&lsa_QueryTrustedDomainInfoByName_Type);
	PyModule_AddObject(m, "QueryTrustedDomainInfoByName", (PyObject *)(void *)&lsa_QueryTrustedDomainInfoByName_Type);
	Py_INCREF((PyObject *)(void *)&lsa_SetTrustedDomainInfoByName_Type);
	PyModule_AddObject(m, "SetTrustedDomainInfoByName", (PyObject *)(void *)&lsa_SetTrustedDomainInfoByName_Type);
	Py_INCREF((PyObject *)(void *)&lsa_EnumTrustedDomainsEx_Type);
	PyModule_AddObject(m, "EnumTrustedDomainsEx", (PyObject *)(void *)&lsa_EnumTrustedDomainsEx_Type);
	Py_INCREF((PyObject *)(void *)&lsa_CreateTrustedDomainEx_Type);
	PyModule_AddObject(m, "CreateTrustedDomainEx", (PyObject *)(void *)&lsa_CreateTrustedDomainEx_Type);
	Py_INCREF((PyObject *)(void *)&lsa_CloseTrustedDomainEx_Type);
	PyModule_AddObject(m, "CloseTrustedDomainEx", (PyObject *)(void *)&lsa_CloseTrustedDomainEx_Type);
	Py_INCREF((PyObject *)(void *)&lsa_QueryDomainInformationPolicy_Type);
	PyModule_AddObject(m, "QueryDomainInformationPolicy", (PyObject *)(void *)&lsa_QueryDomainInformationPolicy_Type);
	Py_INCREF((PyObject *)(void *)&lsa_SetDomainInformationPolicy_Type);
	PyModule_AddObject(m, "SetDomainInformationPolicy", (PyObject *)(void *)&lsa_SetDomainInformationPolicy_Type);
	Py_INCREF((PyObject *)(void *)&lsa_OpenTrustedDomainByName_Type);
	PyModule_AddObject(m, "OpenTrustedDomainByName", (PyObject *)(void *)&lsa_OpenTrustedDomainByName_Type);
	Py_INCREF((PyObject *)(void *)&lsa_LookupSids2_Type);
	PyModule_AddObject(m, "LookupSids2", (PyObject *)(void *)&lsa_LookupSids2_Type);
	Py_INCREF((PyObject *)(void *)&lsa_LookupNames2_Type);
	PyModule_AddObject(m, "LookupNames2", (PyObject *)(void *)&lsa_LookupNames2_Type);
	Py_INCREF((PyObject *)(void *)&lsa_CreateTrustedDomainEx2_Type);
	PyModule_AddObject(m, "CreateTrustedDomainEx2", (PyObject *)(void *)&lsa_CreateTrustedDomainEx2_Type);
	Py_INCREF((PyObject *)(void *)&lsa_LookupNames3_Type);
	PyModule_AddObject(m, "LookupNames3", (PyObject *)(void *)&lsa_LookupNames3_Type);
	Py_INCREF((PyObject *)(void *)&lsa_lsaRQueryForestTrustInformation_Type);
	PyModule_AddObject(m, "lsaRQueryForestTrustInformation", (PyObject *)(void *)&lsa_lsaRQueryForestTrustInformation_Type);
	Py_INCREF((PyObject *)(void *)&lsa_lsaRSetForestTrustInformation_Type);
	PyModule_AddObject(m, "lsaRSetForestTrustInformation", (PyObject *)(void *)&lsa_lsaRSetForestTrustInformation_Type);
	Py_INCREF((PyObject *)(void *)&lsa_LookupSids3_Type);
	PyModule_AddObject(m, "LookupSids3", (PyObject *)(void *)&lsa_LookupSids3_Type);
	Py_INCREF((PyObject *)(void *)&lsa_LookupNames4_Type);
	PyModule_AddObject(m, "LookupNames4", (PyObject *)(void *)&lsa_LookupNames4_Type);
	Py_INCREF((PyObject *)(void *)&lsarpc_InterfaceType);
	PyModule_AddObject(m, "lsarpc", (PyObject *)(void *)&lsarpc_InterfaceType);
	Py_INCREF((PyObject *)(void *)&lsarpc_SyntaxType);
	PyModule_AddObject(m, "lsarpc_abstract_syntax", (PyObject *)(void *)&lsarpc_SyntaxType);
	Py_INCREF((PyObject *)(void *)&lsarpc_SyntaxType);
	PyModule_AddObject(m, "abstract_syntax", (PyObject *)(void *)&lsarpc_SyntaxType);
#ifdef PY_MOD_LSA_PATCH
	PY_MOD_LSA_PATCH(m);
#endif
	return m;

}
