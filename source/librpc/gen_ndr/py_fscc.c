
/* Python wrapper functions auto-generated by pidl */
#define PY_SSIZE_T_CLEAN 1 /* We use Py_ssize_t for PyArg_ParseTupleAndKeywords */
#include <Python.h>
#include "python/py3compat.h"
#include "includes.h"
#include <pytalloc.h>
#include "librpc/rpc/pyrpc.h"
#include "librpc/rpc/pyrpc_util.h"
#include "bin/default/librpc/gen_ndr/ndr_fscc.h"
#include "bin/default/librpc/gen_ndr/ndr_fscc_c.h"

/*
 * These functions are here to ensure they can be optimized out by
 * the compiler based on the constant input values
 */

static inline unsigned long long ndr_sizeof2uintmax(size_t var_size)
{
	switch (var_size) {
	case 8:
		return UINT64_MAX;
	case 4:
		return UINT32_MAX;
	case 2:
		return UINT16_MAX;
	case 1:
		return UINT8_MAX;
	}

	return 0;
}

static inline long long ndr_sizeof2intmax(size_t var_size)
{
	switch (var_size) {
	case 8:
		return INT64_MAX;
	case 4:
		return INT32_MAX;
	case 2:
		return INT16_MAX;
	case 1:
		return INT8_MAX;
	}

	return 0;
}

static inline PyObject *ndr_PyLong_FromLongLong(long long v)
{
	if (v > LONG_MAX || v < LONG_MIN) {
		return PyLong_FromLongLong(v);
	} else {
		return PyInt_FromLong(v);
	}
}

static inline PyObject *ndr_PyLong_FromUnsignedLongLong(unsigned long long v)
{
	if (v > LONG_MAX) {
		return PyLong_FromUnsignedLongLong(v);
	} else {
		return PyInt_FromLong(v);
	}
}

#include "librpc/gen_ndr/misc.h"
static PyTypeObject fscc_FileObjectIdBuffer_2_Type;
static PyTypeObject fscc_FileNetworkOpenInformation_Type;

static PyTypeObject *GUID_Type;
static PyTypeObject *BaseObject_Type;

static PyObject *py_fscc_FileObjectIdBuffer_2_get_id(PyObject *obj, void *closure)
{
	struct fscc_FileObjectIdBuffer_2 *object = (struct fscc_FileObjectIdBuffer_2 *)pytalloc_get_ptr(obj);
	PyObject *py_id;
	py_id = pytalloc_reference_ex(GUID_Type, pytalloc_get_mem_ctx(obj), &object->id);
	return py_id;
}

static int py_fscc_FileObjectIdBuffer_2_set_id(PyObject *py_obj, PyObject *value, void *closure)
{
	struct fscc_FileObjectIdBuffer_2 *object = (struct fscc_FileObjectIdBuffer_2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->id");
		return -1;
	}
	PY_CHECK_TYPE(GUID_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->id = *(struct GUID *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_fscc_FileObjectIdBuffer_2_get_birthVolumeId(PyObject *obj, void *closure)
{
	struct fscc_FileObjectIdBuffer_2 *object = (struct fscc_FileObjectIdBuffer_2 *)pytalloc_get_ptr(obj);
	PyObject *py_birthVolumeId;
	py_birthVolumeId = pytalloc_reference_ex(GUID_Type, pytalloc_get_mem_ctx(obj), &object->birthVolumeId);
	return py_birthVolumeId;
}

static int py_fscc_FileObjectIdBuffer_2_set_birthVolumeId(PyObject *py_obj, PyObject *value, void *closure)
{
	struct fscc_FileObjectIdBuffer_2 *object = (struct fscc_FileObjectIdBuffer_2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->birthVolumeId");
		return -1;
	}
	PY_CHECK_TYPE(GUID_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->birthVolumeId = *(struct GUID *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_fscc_FileObjectIdBuffer_2_get_initialObjectId(PyObject *obj, void *closure)
{
	struct fscc_FileObjectIdBuffer_2 *object = (struct fscc_FileObjectIdBuffer_2 *)pytalloc_get_ptr(obj);
	PyObject *py_initialObjectId;
	py_initialObjectId = pytalloc_reference_ex(GUID_Type, pytalloc_get_mem_ctx(obj), &object->initialObjectId);
	return py_initialObjectId;
}

static int py_fscc_FileObjectIdBuffer_2_set_initialObjectId(PyObject *py_obj, PyObject *value, void *closure)
{
	struct fscc_FileObjectIdBuffer_2 *object = (struct fscc_FileObjectIdBuffer_2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->initialObjectId");
		return -1;
	}
	PY_CHECK_TYPE(GUID_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->initialObjectId = *(struct GUID *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_fscc_FileObjectIdBuffer_2_get_domainId(PyObject *obj, void *closure)
{
	struct fscc_FileObjectIdBuffer_2 *object = (struct fscc_FileObjectIdBuffer_2 *)pytalloc_get_ptr(obj);
	PyObject *py_domainId;
	py_domainId = pytalloc_reference_ex(GUID_Type, pytalloc_get_mem_ctx(obj), &object->domainId);
	return py_domainId;
}

static int py_fscc_FileObjectIdBuffer_2_set_domainId(PyObject *py_obj, PyObject *value, void *closure)
{
	struct fscc_FileObjectIdBuffer_2 *object = (struct fscc_FileObjectIdBuffer_2 *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->domainId");
		return -1;
	}
	PY_CHECK_TYPE(GUID_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->domainId = *(struct GUID *)pytalloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_fscc_FileObjectIdBuffer_2_getsetters[] = {
	{
		.name = discard_const_p(char, "id"),
		.get = py_fscc_FileObjectIdBuffer_2_get_id,
		.set = py_fscc_FileObjectIdBuffer_2_set_id,
		.doc = discard_const_p(char, "PIDL-generated element of base type GUID")
	},
	{
		.name = discard_const_p(char, "birthVolumeId"),
		.get = py_fscc_FileObjectIdBuffer_2_get_birthVolumeId,
		.set = py_fscc_FileObjectIdBuffer_2_set_birthVolumeId,
		.doc = discard_const_p(char, "PIDL-generated element of base type GUID")
	},
	{
		.name = discard_const_p(char, "initialObjectId"),
		.get = py_fscc_FileObjectIdBuffer_2_get_initialObjectId,
		.set = py_fscc_FileObjectIdBuffer_2_set_initialObjectId,
		.doc = discard_const_p(char, "PIDL-generated element of base type GUID")
	},
	{
		.name = discard_const_p(char, "domainId"),
		.get = py_fscc_FileObjectIdBuffer_2_get_domainId,
		.set = py_fscc_FileObjectIdBuffer_2_set_domainId,
		.doc = discard_const_p(char, "PIDL-generated element of base type GUID")
	},
	{ .name = NULL }
};

static PyObject *py_fscc_FileObjectIdBuffer_2_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct fscc_FileObjectIdBuffer_2, type);
}

static PyObject *py_fscc_FileObjectIdBuffer_2_ndr_pack(PyObject *py_obj)
{
	struct fscc_FileObjectIdBuffer_2 *object = (struct fscc_FileObjectIdBuffer_2 *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_fscc_FileObjectIdBuffer_2);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_fscc_FileObjectIdBuffer_2_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct fscc_FileObjectIdBuffer_2 *object = (struct fscc_FileObjectIdBuffer_2 *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_fscc_FileObjectIdBuffer_2);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_fscc_FileObjectIdBuffer_2);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_fscc_FileObjectIdBuffer_2_ndr_print(PyObject *py_obj)
{
	struct fscc_FileObjectIdBuffer_2 *object = (struct fscc_FileObjectIdBuffer_2 *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_fscc_FileObjectIdBuffer_2, "fscc_FileObjectIdBuffer_2", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_fscc_FileObjectIdBuffer_2_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_fscc_FileObjectIdBuffer_2_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_fscc_FileObjectIdBuffer_2_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_fscc_FileObjectIdBuffer_2_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject fscc_FileObjectIdBuffer_2_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "fscc.FileObjectIdBuffer_2",
	.tp_getset = py_fscc_FileObjectIdBuffer_2_getsetters,
	.tp_methods = py_fscc_FileObjectIdBuffer_2_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_fscc_FileObjectIdBuffer_2_new,
};


static PyObject *py_fscc_FileNetworkOpenInformation_get_creationTime(PyObject *obj, void *closure)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(obj);
	PyObject *py_creationTime;
	py_creationTime = ndr_PyLong_FromUnsignedLongLong(object->creationTime);
	return py_creationTime;
}

static int py_fscc_FileNetworkOpenInformation_set_creationTime(PyObject *py_obj, PyObject *value, void *closure)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->creationTime");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->creationTime));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->creationTime = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->creationTime = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_fscc_FileNetworkOpenInformation_get_lastAccessTime(PyObject *obj, void *closure)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(obj);
	PyObject *py_lastAccessTime;
	py_lastAccessTime = ndr_PyLong_FromUnsignedLongLong(object->lastAccessTime);
	return py_lastAccessTime;
}

static int py_fscc_FileNetworkOpenInformation_set_lastAccessTime(PyObject *py_obj, PyObject *value, void *closure)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->lastAccessTime");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->lastAccessTime));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->lastAccessTime = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->lastAccessTime = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_fscc_FileNetworkOpenInformation_get_lastWriteTime(PyObject *obj, void *closure)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(obj);
	PyObject *py_lastWriteTime;
	py_lastWriteTime = ndr_PyLong_FromUnsignedLongLong(object->lastWriteTime);
	return py_lastWriteTime;
}

static int py_fscc_FileNetworkOpenInformation_set_lastWriteTime(PyObject *py_obj, PyObject *value, void *closure)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->lastWriteTime");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->lastWriteTime));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->lastWriteTime = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->lastWriteTime = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_fscc_FileNetworkOpenInformation_get_changeTime(PyObject *obj, void *closure)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(obj);
	PyObject *py_changeTime;
	py_changeTime = ndr_PyLong_FromUnsignedLongLong(object->changeTime);
	return py_changeTime;
}

static int py_fscc_FileNetworkOpenInformation_set_changeTime(PyObject *py_obj, PyObject *value, void *closure)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->changeTime");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->changeTime));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->changeTime = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->changeTime = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_fscc_FileNetworkOpenInformation_get_allocSize(PyObject *obj, void *closure)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(obj);
	PyObject *py_allocSize;
	py_allocSize = ndr_PyLong_FromUnsignedLongLong(object->allocSize);
	return py_allocSize;
}

static int py_fscc_FileNetworkOpenInformation_set_allocSize(PyObject *py_obj, PyObject *value, void *closure)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->allocSize");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->allocSize));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->allocSize = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->allocSize = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_fscc_FileNetworkOpenInformation_get_endOfFile(PyObject *obj, void *closure)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(obj);
	PyObject *py_endOfFile;
	py_endOfFile = ndr_PyLong_FromUnsignedLongLong(object->endOfFile);
	return py_endOfFile;
}

static int py_fscc_FileNetworkOpenInformation_set_endOfFile(PyObject *py_obj, PyObject *value, void *closure)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->endOfFile");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->endOfFile));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->endOfFile = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->endOfFile = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_fscc_FileNetworkOpenInformation_get_fileAttribute(PyObject *obj, void *closure)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(obj);
	PyObject *py_fileAttribute;
	py_fileAttribute = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->fileAttribute);
	return py_fileAttribute;
}

static int py_fscc_FileNetworkOpenInformation_set_fileAttribute(PyObject *py_obj, PyObject *value, void *closure)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->fileAttribute");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->fileAttribute));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->fileAttribute = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->fileAttribute = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_fscc_FileNetworkOpenInformation_get_reserved(PyObject *obj, void *closure)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(obj);
	PyObject *py_reserved;
	py_reserved = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->reserved);
	return py_reserved;
}

static int py_fscc_FileNetworkOpenInformation_set_reserved(PyObject *py_obj, PyObject *value, void *closure)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->reserved");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->reserved));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->reserved = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->reserved = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_fscc_FileNetworkOpenInformation_getsetters[] = {
	{
		.name = discard_const_p(char, "creationTime"),
		.get = py_fscc_FileNetworkOpenInformation_get_creationTime,
		.set = py_fscc_FileNetworkOpenInformation_set_creationTime,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{
		.name = discard_const_p(char, "lastAccessTime"),
		.get = py_fscc_FileNetworkOpenInformation_get_lastAccessTime,
		.set = py_fscc_FileNetworkOpenInformation_set_lastAccessTime,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{
		.name = discard_const_p(char, "lastWriteTime"),
		.get = py_fscc_FileNetworkOpenInformation_get_lastWriteTime,
		.set = py_fscc_FileNetworkOpenInformation_set_lastWriteTime,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{
		.name = discard_const_p(char, "changeTime"),
		.get = py_fscc_FileNetworkOpenInformation_get_changeTime,
		.set = py_fscc_FileNetworkOpenInformation_set_changeTime,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{
		.name = discard_const_p(char, "allocSize"),
		.get = py_fscc_FileNetworkOpenInformation_get_allocSize,
		.set = py_fscc_FileNetworkOpenInformation_set_allocSize,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{
		.name = discard_const_p(char, "endOfFile"),
		.get = py_fscc_FileNetworkOpenInformation_get_endOfFile,
		.set = py_fscc_FileNetworkOpenInformation_set_endOfFile,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{
		.name = discard_const_p(char, "fileAttribute"),
		.get = py_fscc_FileNetworkOpenInformation_get_fileAttribute,
		.set = py_fscc_FileNetworkOpenInformation_set_fileAttribute,
		.doc = discard_const_p(char, "PIDL-generated element of base type fscc_FileAttributes")
	},
	{
		.name = discard_const_p(char, "reserved"),
		.get = py_fscc_FileNetworkOpenInformation_get_reserved,
		.set = py_fscc_FileNetworkOpenInformation_set_reserved,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{ .name = NULL }
};

static PyObject *py_fscc_FileNetworkOpenInformation_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct fscc_FileNetworkOpenInformation, type);
}

static PyObject *py_fscc_FileNetworkOpenInformation_ndr_pack(PyObject *py_obj)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_fscc_FileNetworkOpenInformation);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_fscc_FileNetworkOpenInformation_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_fscc_FileNetworkOpenInformation);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_fscc_FileNetworkOpenInformation);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_fscc_FileNetworkOpenInformation_ndr_print(PyObject *py_obj)
{
	struct fscc_FileNetworkOpenInformation *object = (struct fscc_FileNetworkOpenInformation *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_fscc_FileNetworkOpenInformation, "fscc_FileNetworkOpenInformation", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_fscc_FileNetworkOpenInformation_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_fscc_FileNetworkOpenInformation_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_fscc_FileNetworkOpenInformation_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_fscc_FileNetworkOpenInformation_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject fscc_FileNetworkOpenInformation_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "fscc.FileNetworkOpenInformation",
	.tp_getset = py_fscc_FileNetworkOpenInformation_getsetters,
	.tp_methods = py_fscc_FileNetworkOpenInformation_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_fscc_FileNetworkOpenInformation_new,
};

static PyMethodDef fscc_methods[] = {
	{ NULL, NULL, 0, NULL }
};

static struct PyModuleDef moduledef = {
	PyModuleDef_HEAD_INIT,
	.m_name = "fscc",
	.m_doc = "fscc DCE/RPC",
	.m_size = -1,
	.m_methods = fscc_methods,
};
MODULE_INIT_FUNC(fscc)
{
	PyObject *m;
	PyObject *dep_samba_dcerpc_misc;
	PyObject *dep_talloc;

	dep_samba_dcerpc_misc = PyImport_ImportModule("samba.dcerpc.misc");
	if (dep_samba_dcerpc_misc == NULL)
		return NULL;

	dep_talloc = PyImport_ImportModule("talloc");
	if (dep_talloc == NULL)
		return NULL;

	GUID_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_misc, "GUID");
	if (GUID_Type == NULL)
		return NULL;

	BaseObject_Type = (PyTypeObject *)PyObject_GetAttrString(dep_talloc, "BaseObject");
	if (BaseObject_Type == NULL)
		return NULL;

	fscc_FileObjectIdBuffer_2_Type.tp_base = BaseObject_Type;
	fscc_FileObjectIdBuffer_2_Type.tp_basicsize = pytalloc_BaseObject_size();

	fscc_FileNetworkOpenInformation_Type.tp_base = BaseObject_Type;
	fscc_FileNetworkOpenInformation_Type.tp_basicsize = pytalloc_BaseObject_size();

	if (PyType_Ready(&fscc_FileObjectIdBuffer_2_Type) < 0)
		return NULL;
	if (PyType_Ready(&fscc_FileNetworkOpenInformation_Type) < 0)
		return NULL;
#ifdef PY_FILEOBJECTIDBUFFER_2_PATCH
	PY_FILEOBJECTIDBUFFER_2_PATCH(&fscc_FileObjectIdBuffer_2_Type);
#endif
#ifdef PY_FILENETWORKOPENINFORMATION_PATCH
	PY_FILENETWORKOPENINFORMATION_PATCH(&fscc_FileNetworkOpenInformation_Type);
#endif

	m = PyModule_Create(&moduledef);
	if (m == NULL)
		return NULL;

	PyModule_AddObject(m, "FSCC_FILE_ATTRIBUTE_READONLY", ndr_PyLong_FromUnsignedLongLong((uint32_t)FSCC_FILE_ATTRIBUTE_READONLY));
	PyModule_AddObject(m, "FSCC_FILE_ATTRIBUTE_HIDDEN", ndr_PyLong_FromUnsignedLongLong((uint32_t)FSCC_FILE_ATTRIBUTE_HIDDEN));
	PyModule_AddObject(m, "FSCC_FILE_ATTRIBUTE_SYSTEM", ndr_PyLong_FromUnsignedLongLong((uint32_t)FSCC_FILE_ATTRIBUTE_SYSTEM));
	PyModule_AddObject(m, "FSCC_FILE_ATTRIBUTE_NORMAL", ndr_PyLong_FromUnsignedLongLong((uint32_t)FSCC_FILE_ATTRIBUTE_NORMAL));
	PyModule_AddObject(m, "FSCC_FILE_ATTRIBUTE_DIRECTORY", ndr_PyLong_FromUnsignedLongLong((uint32_t)FSCC_FILE_ATTRIBUTE_DIRECTORY));
	PyModule_AddObject(m, "FSCC_FILE_ATTRIBUTE_ARCHIVE", ndr_PyLong_FromUnsignedLongLong((uint32_t)FSCC_FILE_ATTRIBUTE_ARCHIVE));
	PyModule_AddObject(m, "FSCC_FILE_ATTRIBUTE_TEMPORARY", ndr_PyLong_FromUnsignedLongLong((uint32_t)FSCC_FILE_ATTRIBUTE_TEMPORARY));
	PyModule_AddObject(m, "FSCC_FILE_ATTRIBUTE_SPARSE_FILE", ndr_PyLong_FromUnsignedLongLong((uint32_t)FSCC_FILE_ATTRIBUTE_SPARSE_FILE));
	PyModule_AddObject(m, "FSCC_FILE_ATTRIBUTE_REPARSE_POINT", ndr_PyLong_FromUnsignedLongLong((uint32_t)FSCC_FILE_ATTRIBUTE_REPARSE_POINT));
	PyModule_AddObject(m, "FSCC_FILE_ATTRIBUTE_COMPRESSED", ndr_PyLong_FromUnsignedLongLong((uint32_t)FSCC_FILE_ATTRIBUTE_COMPRESSED));
	PyModule_AddObject(m, "FSCC_FILE_ATTRIBUTE_OFFLINE", ndr_PyLong_FromUnsignedLongLong((uint32_t)FSCC_FILE_ATTRIBUTE_OFFLINE));
	PyModule_AddObject(m, "FSCC_FILE_ATTRIBUTE_NOT_CONTENT_INDEXED", ndr_PyLong_FromUnsignedLongLong((uint32_t)FSCC_FILE_ATTRIBUTE_NOT_CONTENT_INDEXED));
	PyModule_AddObject(m, "FSCC_FILE_ATTRIBUTE_ENCRYPTED", ndr_PyLong_FromUnsignedLongLong((uint32_t)FSCC_FILE_ATTRIBUTE_ENCRYPTED));
	Py_INCREF((PyObject *)(void *)&fscc_FileObjectIdBuffer_2_Type);
	PyModule_AddObject(m, "FileObjectIdBuffer_2", (PyObject *)(void *)&fscc_FileObjectIdBuffer_2_Type);
	Py_INCREF((PyObject *)(void *)&fscc_FileNetworkOpenInformation_Type);
	PyModule_AddObject(m, "FileNetworkOpenInformation", (PyObject *)(void *)&fscc_FileNetworkOpenInformation_Type);
#ifdef PY_MOD_FSCC_PATCH
	PY_MOD_FSCC_PATCH(m);
#endif
	return m;

}
