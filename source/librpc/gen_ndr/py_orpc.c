
/* Python wrapper functions auto-generated by pidl */
#define PY_SSIZE_T_CLEAN 1 /* We use Py_ssize_t for PyArg_ParseTupleAndKeywords */
#include <Python.h>
#include "python/py3compat.h"
#include "includes.h"
#include <pytalloc.h>
#include "librpc/rpc/pyrpc.h"
#include "librpc/rpc/pyrpc_util.h"
#include "bin/default/librpc/gen_ndr/ndr_orpc.h"
#include "bin/default/librpc/gen_ndr/ndr_orpc_c.h"

/*
 * These functions are here to ensure they can be optimized out by
 * the compiler based on the constant input values
 */

static inline unsigned long long ndr_sizeof2uintmax(size_t var_size)
{
	switch (var_size) {
	case 8:
		return UINT64_MAX;
	case 4:
		return UINT32_MAX;
	case 2:
		return UINT16_MAX;
	case 1:
		return UINT8_MAX;
	}

	return 0;
}

static inline long long ndr_sizeof2intmax(size_t var_size)
{
	switch (var_size) {
	case 8:
		return INT64_MAX;
	case 4:
		return INT32_MAX;
	case 2:
		return INT16_MAX;
	case 1:
		return INT8_MAX;
	}

	return 0;
}

static inline PyObject *ndr_PyLong_FromLongLong(long long v)
{
	if (v > LONG_MAX || v < LONG_MIN) {
		return PyLong_FromLongLong(v);
	} else {
		return PyInt_FromLong(v);
	}
}

static inline PyObject *ndr_PyLong_FromUnsignedLongLong(unsigned long long v)
{
	if (v > LONG_MAX) {
		return PyLong_FromUnsignedLongLong(v);
	} else {
		return PyInt_FromLong(v);
	}
}

#include "librpc/gen_ndr/misc.h"
static PyTypeObject COMVERSION_Type;
static PyTypeObject ORPC_EXTENT_Type;
static PyTypeObject ORPC_EXTENT_ARRAY_Type;
static PyTypeObject ORPCTHIS_Type;
static PyTypeObject ORPCTHAT_Type;
static PyTypeObject STRINGBINDING_Type;
static PyTypeObject STRINGARRAY_Type;
static PyTypeObject DUALSTRINGARRAY_Type;
static PyTypeObject SECURITYBINDING_Type;
static PyTypeObject STDOBJREF_Type;
static PyTypeObject u_standard_Type;
static PyTypeObject u_handler_Type;
static PyTypeObject u_custom_Type;
static PyTypeObject u_null_Type;
static PyTypeObject OBJREF_Types_Type;
static PyTypeObject OBJREF_Type;
static PyTypeObject MInterfacePointer_Type;

static PyTypeObject *BaseObject_Type;
static PyTypeObject *GUID_Type;

static PyObject *py_COMVERSION_get_MajorVersion(PyObject *obj, void *closure)
{
	struct COMVERSION *object = (struct COMVERSION *)pytalloc_get_ptr(obj);
	PyObject *py_MajorVersion;
	py_MajorVersion = PyInt_FromLong((uint16_t)object->MajorVersion);
	return py_MajorVersion;
}

static int py_COMVERSION_set_MajorVersion(PyObject *py_obj, PyObject *value, void *closure)
{
	struct COMVERSION *object = (struct COMVERSION *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->MajorVersion");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->MajorVersion));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->MajorVersion = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->MajorVersion = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_COMVERSION_get_MinorVersion(PyObject *obj, void *closure)
{
	struct COMVERSION *object = (struct COMVERSION *)pytalloc_get_ptr(obj);
	PyObject *py_MinorVersion;
	py_MinorVersion = PyInt_FromLong((uint16_t)object->MinorVersion);
	return py_MinorVersion;
}

static int py_COMVERSION_set_MinorVersion(PyObject *py_obj, PyObject *value, void *closure)
{
	struct COMVERSION *object = (struct COMVERSION *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->MinorVersion");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->MinorVersion));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->MinorVersion = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->MinorVersion = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyGetSetDef py_COMVERSION_getsetters[] = {
	{
		.name = discard_const_p(char, "MajorVersion"),
		.get = py_COMVERSION_get_MajorVersion,
		.set = py_COMVERSION_set_MajorVersion,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "MinorVersion"),
		.get = py_COMVERSION_get_MinorVersion,
		.set = py_COMVERSION_set_MinorVersion,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{ .name = NULL }
};

static PyObject *py_COMVERSION_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct COMVERSION, type);
}

static PyObject *py_COMVERSION_ndr_pack(PyObject *py_obj)
{
	struct COMVERSION *object = (struct COMVERSION *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_COMVERSION);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_COMVERSION_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct COMVERSION *object = (struct COMVERSION *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_COMVERSION);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_COMVERSION);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_COMVERSION_ndr_print(PyObject *py_obj)
{
	struct COMVERSION *object = (struct COMVERSION *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_COMVERSION, "COMVERSION", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_COMVERSION_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_COMVERSION_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_COMVERSION_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_COMVERSION_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject COMVERSION_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "orpc.COMVERSION",
	.tp_getset = py_COMVERSION_getsetters,
	.tp_methods = py_COMVERSION_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_COMVERSION_new,
};


static PyObject *py_ORPC_EXTENT_get_id(PyObject *obj, void *closure)
{
	struct ORPC_EXTENT *object = (struct ORPC_EXTENT *)pytalloc_get_ptr(obj);
	PyObject *py_id;
	py_id = pytalloc_reference_ex(GUID_Type, pytalloc_get_mem_ctx(obj), &object->id);
	return py_id;
}

static int py_ORPC_EXTENT_set_id(PyObject *py_obj, PyObject *value, void *closure)
{
	struct ORPC_EXTENT *object = (struct ORPC_EXTENT *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->id");
		return -1;
	}
	PY_CHECK_TYPE(GUID_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->id = *(struct GUID *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_ORPC_EXTENT_get_size(PyObject *obj, void *closure)
{
	struct ORPC_EXTENT *object = (struct ORPC_EXTENT *)pytalloc_get_ptr(obj);
	PyObject *py_size;
	py_size = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->size);
	return py_size;
}

static int py_ORPC_EXTENT_set_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct ORPC_EXTENT *object = (struct ORPC_EXTENT *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_ORPC_EXTENT_get_data(PyObject *obj, void *closure)
{
	struct ORPC_EXTENT *object = (struct ORPC_EXTENT *)pytalloc_get_ptr(obj);
	PyObject *py_data;
	py_data = PyList_New(((object->size + 7) & ~7));
	if (py_data == NULL) {
		return NULL;
	}
	{
		int data_cntr_0;
		for (data_cntr_0 = 0; data_cntr_0 < (((object->size + 7) & ~7)); data_cntr_0++) {
			PyObject *py_data_0;
			py_data_0 = PyInt_FromLong((uint16_t)object->data[data_cntr_0]);
			PyList_SetItem(py_data, data_cntr_0, py_data_0);
		}
	}
	return py_data;
}

static int py_ORPC_EXTENT_set_data(PyObject *py_obj, PyObject *value, void *closure)
{
	struct ORPC_EXTENT *object = (struct ORPC_EXTENT *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->data");
		return -1;
	}
	PY_CHECK_TYPE(&PyList_Type, value, return -1;);
	{
		int data_cntr_0;
		object->data = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->data, PyList_GET_SIZE(value));
		if (!object->data) { return -1;; }
		talloc_set_name_const(object->data, "ARRAY: object->data");
		for (data_cntr_0 = 0; data_cntr_0 < PyList_GET_SIZE(value); data_cntr_0++) {
			if (PyList_GET_ITEM(value, data_cntr_0) == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->data[data_cntr_0]");
				return -1;
			}
			{
				const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->data[data_cntr_0]));
				if (PyLong_Check(PyList_GET_ITEM(value, data_cntr_0))) {
					unsigned long long test_var;
					test_var = PyLong_AsUnsignedLongLong(PyList_GET_ITEM(value, data_cntr_0));
					if (PyErr_Occurred() != NULL) {
						return -1;
					}
					if (test_var > uint_max) {
						PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
						  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
						return -1;
					}
					object->data[data_cntr_0] = test_var;
				} else if (PyInt_Check(PyList_GET_ITEM(value, data_cntr_0))) {
					long test_var;
					test_var = PyInt_AsLong(PyList_GET_ITEM(value, data_cntr_0));
					if (test_var < 0 || test_var > uint_max) {
						PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
						  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
						return -1;
					}
					object->data[data_cntr_0] = test_var;
				} else {
					PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name);
					return -1;
				}
			}
		}
	}
	return 0;
}

static PyGetSetDef py_ORPC_EXTENT_getsetters[] = {
	{
		.name = discard_const_p(char, "id"),
		.get = py_ORPC_EXTENT_get_id,
		.set = py_ORPC_EXTENT_set_id,
		.doc = discard_const_p(char, "PIDL-generated element of base type GUID")
	},
	{
		.name = discard_const_p(char, "size"),
		.get = py_ORPC_EXTENT_get_size,
		.set = py_ORPC_EXTENT_set_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "data"),
		.get = py_ORPC_EXTENT_get_data,
		.set = py_ORPC_EXTENT_set_data,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{ .name = NULL }
};

static PyObject *py_ORPC_EXTENT_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct ORPC_EXTENT, type);
}

static PyObject *py_ORPC_EXTENT_ndr_pack(PyObject *py_obj)
{
	struct ORPC_EXTENT *object = (struct ORPC_EXTENT *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_ORPC_EXTENT);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_ORPC_EXTENT_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct ORPC_EXTENT *object = (struct ORPC_EXTENT *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_ORPC_EXTENT);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_ORPC_EXTENT);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_ORPC_EXTENT_ndr_print(PyObject *py_obj)
{
	struct ORPC_EXTENT *object = (struct ORPC_EXTENT *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_ORPC_EXTENT, "ORPC_EXTENT", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_ORPC_EXTENT_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_ORPC_EXTENT_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_ORPC_EXTENT_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_ORPC_EXTENT_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject ORPC_EXTENT_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "orpc.ORPC_EXTENT",
	.tp_getset = py_ORPC_EXTENT_getsetters,
	.tp_methods = py_ORPC_EXTENT_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_ORPC_EXTENT_new,
};


static PyObject *py_ORPC_EXTENT_ARRAY_get_size(PyObject *obj, void *closure)
{
	struct ORPC_EXTENT_ARRAY *object = (struct ORPC_EXTENT_ARRAY *)pytalloc_get_ptr(obj);
	PyObject *py_size;
	py_size = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->size);
	return py_size;
}

static int py_ORPC_EXTENT_ARRAY_set_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct ORPC_EXTENT_ARRAY *object = (struct ORPC_EXTENT_ARRAY *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_ORPC_EXTENT_ARRAY_get_reserved(PyObject *obj, void *closure)
{
	struct ORPC_EXTENT_ARRAY *object = (struct ORPC_EXTENT_ARRAY *)pytalloc_get_ptr(obj);
	PyObject *py_reserved;
	py_reserved = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->reserved);
	return py_reserved;
}

static int py_ORPC_EXTENT_ARRAY_set_reserved(PyObject *py_obj, PyObject *value, void *closure)
{
	struct ORPC_EXTENT_ARRAY *object = (struct ORPC_EXTENT_ARRAY *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->reserved");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->reserved));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->reserved = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->reserved = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_ORPC_EXTENT_ARRAY_get_extent(PyObject *obj, void *closure)
{
	struct ORPC_EXTENT_ARRAY *object = (struct ORPC_EXTENT_ARRAY *)pytalloc_get_ptr(obj);
	PyObject *py_extent;
	if (object->extent == NULL) {
		py_extent = Py_None;
		Py_INCREF(py_extent);
	} else {
		py_extent = PyList_New(((object->size + 1) & ~1));
		if (py_extent == NULL) {
			return NULL;
		}
		{
			int extent_cntr_1;
			for (extent_cntr_1 = 0; extent_cntr_1 < (((object->size + 1) & ~1)); extent_cntr_1++) {
				PyObject *py_extent_1;
				if (object->extent[extent_cntr_1] == NULL) {
					py_extent_1 = Py_None;
					Py_INCREF(py_extent_1);
				} else {
					py_extent_1 = pytalloc_reference_ex(&ORPC_EXTENT_Type, object->extent[extent_cntr_1], object->extent[extent_cntr_1]);
				}
				PyList_SetItem(py_extent, extent_cntr_1, py_extent_1);
			}
		}
	}
	return py_extent;
}

static int py_ORPC_EXTENT_ARRAY_set_extent(PyObject *py_obj, PyObject *value, void *closure)
{
	struct ORPC_EXTENT_ARRAY *object = (struct ORPC_EXTENT_ARRAY *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->extent));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->extent");
		return -1;
	}
	if (value == Py_None) {
		object->extent = NULL;
	} else {
		object->extent = NULL;
		PY_CHECK_TYPE(&PyList_Type, value, return -1;);
		{
			int extent_cntr_1;
			object->extent = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->extent, PyList_GET_SIZE(value));
			if (!object->extent) { return -1;; }
			talloc_set_name_const(object->extent, "ARRAY: object->extent");
			for (extent_cntr_1 = 0; extent_cntr_1 < PyList_GET_SIZE(value); extent_cntr_1++) {
				if (PyList_GET_ITEM(value, extent_cntr_1) == NULL) {
					PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->extent[extent_cntr_1]");
					return -1;
				}
				if (PyList_GET_ITEM(value, extent_cntr_1) == Py_None) {
					object->extent[extent_cntr_1] = NULL;
				} else {
					object->extent[extent_cntr_1] = NULL;
					PY_CHECK_TYPE(&ORPC_EXTENT_Type, PyList_GET_ITEM(value, extent_cntr_1), return -1;);
					if (talloc_reference(object->extent, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, extent_cntr_1))) == NULL) {
						PyErr_NoMemory();
						return -1;
					}
					object->extent[extent_cntr_1] = (struct ORPC_EXTENT *)pytalloc_get_ptr(PyList_GET_ITEM(value, extent_cntr_1));
				}
			}
		}
	}
	return 0;
}

static PyGetSetDef py_ORPC_EXTENT_ARRAY_getsetters[] = {
	{
		.name = discard_const_p(char, "size"),
		.get = py_ORPC_EXTENT_ARRAY_get_size,
		.set = py_ORPC_EXTENT_ARRAY_set_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "reserved"),
		.get = py_ORPC_EXTENT_ARRAY_get_reserved,
		.set = py_ORPC_EXTENT_ARRAY_set_reserved,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "extent"),
		.get = py_ORPC_EXTENT_ARRAY_get_extent,
		.set = py_ORPC_EXTENT_ARRAY_set_extent,
		.doc = discard_const_p(char, "PIDL-generated element of base type ORPC_EXTENT")
	},
	{ .name = NULL }
};

static PyObject *py_ORPC_EXTENT_ARRAY_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct ORPC_EXTENT_ARRAY, type);
}


static PyTypeObject ORPC_EXTENT_ARRAY_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "orpc.ORPC_EXTENT_ARRAY",
	.tp_getset = py_ORPC_EXTENT_ARRAY_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_ORPC_EXTENT_ARRAY_new,
};


static PyObject *py_ORPCTHIS_get_version(PyObject *obj, void *closure)
{
	struct ORPCTHIS *object = (struct ORPCTHIS *)pytalloc_get_ptr(obj);
	PyObject *py_version;
	py_version = pytalloc_reference_ex(&COMVERSION_Type, pytalloc_get_mem_ctx(obj), &object->version);
	return py_version;
}

static int py_ORPCTHIS_set_version(PyObject *py_obj, PyObject *value, void *closure)
{
	struct ORPCTHIS *object = (struct ORPCTHIS *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->version");
		return -1;
	}
	PY_CHECK_TYPE(&COMVERSION_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->version = *(struct COMVERSION *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_ORPCTHIS_get_flags(PyObject *obj, void *closure)
{
	struct ORPCTHIS *object = (struct ORPCTHIS *)pytalloc_get_ptr(obj);
	PyObject *py_flags;
	py_flags = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->flags);
	return py_flags;
}

static int py_ORPCTHIS_set_flags(PyObject *py_obj, PyObject *value, void *closure)
{
	struct ORPCTHIS *object = (struct ORPCTHIS *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->flags");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->flags));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->flags = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->flags = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_ORPCTHIS_get_reserved1(PyObject *obj, void *closure)
{
	struct ORPCTHIS *object = (struct ORPCTHIS *)pytalloc_get_ptr(obj);
	PyObject *py_reserved1;
	py_reserved1 = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->reserved1);
	return py_reserved1;
}

static int py_ORPCTHIS_set_reserved1(PyObject *py_obj, PyObject *value, void *closure)
{
	struct ORPCTHIS *object = (struct ORPCTHIS *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->reserved1");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->reserved1));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->reserved1 = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->reserved1 = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_ORPCTHIS_get_cid(PyObject *obj, void *closure)
{
	struct ORPCTHIS *object = (struct ORPCTHIS *)pytalloc_get_ptr(obj);
	PyObject *py_cid;
	py_cid = pytalloc_reference_ex(GUID_Type, pytalloc_get_mem_ctx(obj), &object->cid);
	return py_cid;
}

static int py_ORPCTHIS_set_cid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct ORPCTHIS *object = (struct ORPCTHIS *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cid");
		return -1;
	}
	PY_CHECK_TYPE(GUID_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->cid = *(struct GUID *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_ORPCTHIS_get_extensions(PyObject *obj, void *closure)
{
	struct ORPCTHIS *object = (struct ORPCTHIS *)pytalloc_get_ptr(obj);
	PyObject *py_extensions;
	if (object->extensions == NULL) {
		py_extensions = Py_None;
		Py_INCREF(py_extensions);
	} else {
		py_extensions = pytalloc_reference_ex(&ORPC_EXTENT_ARRAY_Type, object->extensions, object->extensions);
	}
	return py_extensions;
}

static int py_ORPCTHIS_set_extensions(PyObject *py_obj, PyObject *value, void *closure)
{
	struct ORPCTHIS *object = (struct ORPCTHIS *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->extensions));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->extensions");
		return -1;
	}
	if (value == Py_None) {
		object->extensions = NULL;
	} else {
		object->extensions = NULL;
		PY_CHECK_TYPE(&ORPC_EXTENT_ARRAY_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->extensions = (struct ORPC_EXTENT_ARRAY *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyGetSetDef py_ORPCTHIS_getsetters[] = {
	{
		.name = discard_const_p(char, "version"),
		.get = py_ORPCTHIS_get_version,
		.set = py_ORPCTHIS_set_version,
		.doc = discard_const_p(char, "PIDL-generated element of base type COMVERSION")
	},
	{
		.name = discard_const_p(char, "flags"),
		.get = py_ORPCTHIS_get_flags,
		.set = py_ORPCTHIS_set_flags,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "reserved1"),
		.get = py_ORPCTHIS_get_reserved1,
		.set = py_ORPCTHIS_set_reserved1,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "cid"),
		.get = py_ORPCTHIS_get_cid,
		.set = py_ORPCTHIS_set_cid,
		.doc = discard_const_p(char, "PIDL-generated element of base type GUID")
	},
	{
		.name = discard_const_p(char, "extensions"),
		.get = py_ORPCTHIS_get_extensions,
		.set = py_ORPCTHIS_set_extensions,
		.doc = discard_const_p(char, "PIDL-generated element of base type ORPC_EXTENT_ARRAY")
	},
	{ .name = NULL }
};

static PyObject *py_ORPCTHIS_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct ORPCTHIS, type);
}

static PyObject *py_ORPCTHIS_ndr_pack(PyObject *py_obj)
{
	struct ORPCTHIS *object = (struct ORPCTHIS *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_ORPCTHIS);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_ORPCTHIS_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct ORPCTHIS *object = (struct ORPCTHIS *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_ORPCTHIS);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_ORPCTHIS);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_ORPCTHIS_ndr_print(PyObject *py_obj)
{
	struct ORPCTHIS *object = (struct ORPCTHIS *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_ORPCTHIS, "ORPCTHIS", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_ORPCTHIS_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_ORPCTHIS_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_ORPCTHIS_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_ORPCTHIS_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject ORPCTHIS_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "orpc.ORPCTHIS",
	.tp_getset = py_ORPCTHIS_getsetters,
	.tp_methods = py_ORPCTHIS_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_ORPCTHIS_new,
};


static PyObject *py_ORPCTHAT_get_flags(PyObject *obj, void *closure)
{
	struct ORPCTHAT *object = (struct ORPCTHAT *)pytalloc_get_ptr(obj);
	PyObject *py_flags;
	py_flags = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->flags);
	return py_flags;
}

static int py_ORPCTHAT_set_flags(PyObject *py_obj, PyObject *value, void *closure)
{
	struct ORPCTHAT *object = (struct ORPCTHAT *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->flags");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->flags));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->flags = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->flags = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_ORPCTHAT_get_extensions(PyObject *obj, void *closure)
{
	struct ORPCTHAT *object = (struct ORPCTHAT *)pytalloc_get_ptr(obj);
	PyObject *py_extensions;
	if (object->extensions == NULL) {
		py_extensions = Py_None;
		Py_INCREF(py_extensions);
	} else {
		py_extensions = pytalloc_reference_ex(&ORPC_EXTENT_ARRAY_Type, object->extensions, object->extensions);
	}
	return py_extensions;
}

static int py_ORPCTHAT_set_extensions(PyObject *py_obj, PyObject *value, void *closure)
{
	struct ORPCTHAT *object = (struct ORPCTHAT *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->extensions));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->extensions");
		return -1;
	}
	if (value == Py_None) {
		object->extensions = NULL;
	} else {
		object->extensions = NULL;
		PY_CHECK_TYPE(&ORPC_EXTENT_ARRAY_Type, value, return -1;);
		if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->extensions = (struct ORPC_EXTENT_ARRAY *)pytalloc_get_ptr(value);
	}
	return 0;
}

static PyGetSetDef py_ORPCTHAT_getsetters[] = {
	{
		.name = discard_const_p(char, "flags"),
		.get = py_ORPCTHAT_get_flags,
		.set = py_ORPCTHAT_set_flags,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "extensions"),
		.get = py_ORPCTHAT_get_extensions,
		.set = py_ORPCTHAT_set_extensions,
		.doc = discard_const_p(char, "PIDL-generated element of base type ORPC_EXTENT_ARRAY")
	},
	{ .name = NULL }
};

static PyObject *py_ORPCTHAT_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct ORPCTHAT, type);
}

static PyObject *py_ORPCTHAT_ndr_pack(PyObject *py_obj)
{
	struct ORPCTHAT *object = (struct ORPCTHAT *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_ORPCTHAT);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_ORPCTHAT_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct ORPCTHAT *object = (struct ORPCTHAT *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_ORPCTHAT);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_ORPCTHAT);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_ORPCTHAT_ndr_print(PyObject *py_obj)
{
	struct ORPCTHAT *object = (struct ORPCTHAT *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_ORPCTHAT, "ORPCTHAT", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_ORPCTHAT_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_ORPCTHAT_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_ORPCTHAT_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_ORPCTHAT_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject ORPCTHAT_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "orpc.ORPCTHAT",
	.tp_getset = py_ORPCTHAT_getsetters,
	.tp_methods = py_ORPCTHAT_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_ORPCTHAT_new,
};


static PyObject *py_STRINGBINDING_get_wTowerId(PyObject *obj, void *closure)
{
	struct STRINGBINDING *object = (struct STRINGBINDING *)pytalloc_get_ptr(obj);
	PyObject *py_wTowerId;
	py_wTowerId = PyInt_FromLong((uint16_t)object->wTowerId);
	return py_wTowerId;
}

static int py_STRINGBINDING_set_wTowerId(PyObject *py_obj, PyObject *value, void *closure)
{
	struct STRINGBINDING *object = (struct STRINGBINDING *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->wTowerId");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->wTowerId));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->wTowerId = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->wTowerId = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_STRINGBINDING_get_NetworkAddr(PyObject *obj, void *closure)
{
	struct STRINGBINDING *object = (struct STRINGBINDING *)pytalloc_get_ptr(obj);
	PyObject *py_NetworkAddr;
	py_NetworkAddr = PyString_FromStringOrNULL(object->NetworkAddr);
	return py_NetworkAddr;
}

static int py_STRINGBINDING_set_NetworkAddr(PyObject *py_obj, PyObject *value, void *closure)
{
	struct STRINGBINDING *object = (struct STRINGBINDING *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->NetworkAddr");
		return -1;
	}
	{
		const char *test_str;
		const char *talloc_str;
		PyObject *unicode = NULL;
		if (PyUnicode_Check(value)) {
			unicode = PyUnicode_AsEncodedString(value, "utf-8", "ignore");
			if (unicode == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			test_str = PyBytes_AS_STRING(unicode);
		} else if (PyBytes_Check(value)) {
			test_str = PyBytes_AS_STRING(value);
		} else {
			PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
			return -1;
		}
		talloc_str = talloc_strdup(pytalloc_get_mem_ctx(py_obj), test_str);
		if (unicode != NULL) {
			Py_DECREF(unicode);
		}
		if (talloc_str == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->NetworkAddr = talloc_str;
	}
	return 0;
}

static PyGetSetDef py_STRINGBINDING_getsetters[] = {
	{
		.name = discard_const_p(char, "wTowerId"),
		.get = py_STRINGBINDING_get_wTowerId,
		.set = py_STRINGBINDING_set_wTowerId,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "NetworkAddr"),
		.get = py_STRINGBINDING_get_NetworkAddr,
		.set = py_STRINGBINDING_set_NetworkAddr,
		.doc = discard_const_p(char, "PIDL-generated element of base type string")
	},
	{ .name = NULL }
};

static PyObject *py_STRINGBINDING_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct STRINGBINDING, type);
}

static PyObject *py_STRINGBINDING_ndr_pack(PyObject *py_obj)
{
	struct STRINGBINDING *object = (struct STRINGBINDING *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_STRINGBINDING);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_STRINGBINDING_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct STRINGBINDING *object = (struct STRINGBINDING *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_STRINGBINDING);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_STRINGBINDING);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_STRINGBINDING_ndr_print(PyObject *py_obj)
{
	struct STRINGBINDING *object = (struct STRINGBINDING *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_STRINGBINDING, "STRINGBINDING", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_STRINGBINDING_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_STRINGBINDING_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_STRINGBINDING_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_STRINGBINDING_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject STRINGBINDING_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "orpc.STRINGBINDING",
	.tp_getset = py_STRINGBINDING_getsetters,
	.tp_methods = py_STRINGBINDING_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_STRINGBINDING_new,
};


static PyObject *py_STRINGARRAY_get_stringbindings(PyObject *obj, void *closure)
{
	struct STRINGARRAY *object = (struct STRINGARRAY *)pytalloc_get_ptr(obj);
	PyObject *py_stringbindings;
	if (object->stringbindings == NULL) {
		py_stringbindings = Py_None;
		Py_INCREF(py_stringbindings);
	} else {
		if (*object->stringbindings == NULL) {
			py_stringbindings = Py_None;
			Py_INCREF(py_stringbindings);
		} else {
			py_stringbindings = pytalloc_reference_ex(&STRINGBINDING_Type, *object->stringbindings, *object->stringbindings);
		}
	}
	return py_stringbindings;
}

static int py_STRINGARRAY_set_stringbindings(PyObject *py_obj, PyObject *value, void *closure)
{
	struct STRINGARRAY *object = (struct STRINGARRAY *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->stringbindings));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->stringbindings");
		return -1;
	}
	if (value == Py_None) {
		object->stringbindings = NULL;
	} else {
		object->stringbindings = NULL;
		if (value == Py_None) {
			*object->stringbindings = NULL;
		} else {
			*object->stringbindings = NULL;
			PY_CHECK_TYPE(&STRINGBINDING_Type, value, return -1;);
			if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			*object->stringbindings = (struct STRINGBINDING *)pytalloc_get_ptr(value);
		}
	}
	return 0;
}

static PyGetSetDef py_STRINGARRAY_getsetters[] = {
	{
		.name = discard_const_p(char, "stringbindings"),
		.get = py_STRINGARRAY_get_stringbindings,
		.set = py_STRINGARRAY_set_stringbindings,
		.doc = discard_const_p(char, "PIDL-generated element of base type STRINGBINDING")
	},
	{ .name = NULL }
};

static PyObject *py_STRINGARRAY_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct STRINGARRAY, type);
}

static PyObject *py_STRINGARRAY_ndr_pack(PyObject *py_obj)
{
	struct STRINGARRAY *object = (struct STRINGARRAY *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_STRINGARRAY);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_STRINGARRAY_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct STRINGARRAY *object = (struct STRINGARRAY *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_STRINGARRAY);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_STRINGARRAY);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_STRINGARRAY_ndr_print(PyObject *py_obj)
{
	struct STRINGARRAY *object = (struct STRINGARRAY *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_STRINGARRAY, "STRINGARRAY", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_STRINGARRAY_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_STRINGARRAY_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_STRINGARRAY_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_STRINGARRAY_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject STRINGARRAY_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "orpc.STRINGARRAY",
	.tp_getset = py_STRINGARRAY_getsetters,
	.tp_methods = py_STRINGARRAY_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_STRINGARRAY_new,
};


static PyObject *py_DUALSTRINGARRAY_get_stringbindings(PyObject *obj, void *closure)
{
	struct DUALSTRINGARRAY *object = (struct DUALSTRINGARRAY *)pytalloc_get_ptr(obj);
	PyObject *py_stringbindings;
	if (object->stringbindings == NULL) {
		py_stringbindings = Py_None;
		Py_INCREF(py_stringbindings);
	} else {
		if (*object->stringbindings == NULL) {
			py_stringbindings = Py_None;
			Py_INCREF(py_stringbindings);
		} else {
			py_stringbindings = pytalloc_reference_ex(&STRINGBINDING_Type, *object->stringbindings, *object->stringbindings);
		}
	}
	return py_stringbindings;
}

static int py_DUALSTRINGARRAY_set_stringbindings(PyObject *py_obj, PyObject *value, void *closure)
{
	struct DUALSTRINGARRAY *object = (struct DUALSTRINGARRAY *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->stringbindings));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->stringbindings");
		return -1;
	}
	if (value == Py_None) {
		object->stringbindings = NULL;
	} else {
		object->stringbindings = NULL;
		if (value == Py_None) {
			*object->stringbindings = NULL;
		} else {
			*object->stringbindings = NULL;
			PY_CHECK_TYPE(&STRINGBINDING_Type, value, return -1;);
			if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			*object->stringbindings = (struct STRINGBINDING *)pytalloc_get_ptr(value);
		}
	}
	return 0;
}

static PyObject *py_DUALSTRINGARRAY_get_securitybindings(PyObject *obj, void *closure)
{
	struct DUALSTRINGARRAY *object = (struct DUALSTRINGARRAY *)pytalloc_get_ptr(obj);
	PyObject *py_securitybindings;
	if (object->securitybindings == NULL) {
		py_securitybindings = Py_None;
		Py_INCREF(py_securitybindings);
	} else {
		if (*object->securitybindings == NULL) {
			py_securitybindings = Py_None;
			Py_INCREF(py_securitybindings);
		} else {
			py_securitybindings = pytalloc_reference_ex(&SECURITYBINDING_Type, *object->securitybindings, *object->securitybindings);
		}
	}
	return py_securitybindings;
}

static int py_DUALSTRINGARRAY_set_securitybindings(PyObject *py_obj, PyObject *value, void *closure)
{
	struct DUALSTRINGARRAY *object = (struct DUALSTRINGARRAY *)pytalloc_get_ptr(py_obj);
	talloc_unlink(pytalloc_get_mem_ctx(py_obj), discard_const(object->securitybindings));
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->securitybindings");
		return -1;
	}
	if (value == Py_None) {
		object->securitybindings = NULL;
	} else {
		object->securitybindings = NULL;
		if (value == Py_None) {
			*object->securitybindings = NULL;
		} else {
			*object->securitybindings = NULL;
			PY_CHECK_TYPE(&SECURITYBINDING_Type, value, return -1;);
			if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			*object->securitybindings = (struct SECURITYBINDING *)pytalloc_get_ptr(value);
		}
	}
	return 0;
}

static PyGetSetDef py_DUALSTRINGARRAY_getsetters[] = {
	{
		.name = discard_const_p(char, "stringbindings"),
		.get = py_DUALSTRINGARRAY_get_stringbindings,
		.set = py_DUALSTRINGARRAY_set_stringbindings,
		.doc = discard_const_p(char, "PIDL-generated element of base type STRINGBINDING")
	},
	{
		.name = discard_const_p(char, "securitybindings"),
		.get = py_DUALSTRINGARRAY_get_securitybindings,
		.set = py_DUALSTRINGARRAY_set_securitybindings,
		.doc = discard_const_p(char, "PIDL-generated element of base type SECURITYBINDING")
	},
	{ .name = NULL }
};

static PyObject *py_DUALSTRINGARRAY_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct DUALSTRINGARRAY, type);
}

static PyObject *py_DUALSTRINGARRAY_ndr_pack(PyObject *py_obj)
{
	struct DUALSTRINGARRAY *object = (struct DUALSTRINGARRAY *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_DUALSTRINGARRAY);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_DUALSTRINGARRAY_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct DUALSTRINGARRAY *object = (struct DUALSTRINGARRAY *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_DUALSTRINGARRAY);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_DUALSTRINGARRAY);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_DUALSTRINGARRAY_ndr_print(PyObject *py_obj)
{
	struct DUALSTRINGARRAY *object = (struct DUALSTRINGARRAY *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_DUALSTRINGARRAY, "DUALSTRINGARRAY", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_DUALSTRINGARRAY_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_DUALSTRINGARRAY_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_DUALSTRINGARRAY_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_DUALSTRINGARRAY_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject DUALSTRINGARRAY_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "orpc.DUALSTRINGARRAY",
	.tp_getset = py_DUALSTRINGARRAY_getsetters,
	.tp_methods = py_DUALSTRINGARRAY_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_DUALSTRINGARRAY_new,
};


static PyObject *py_SECURITYBINDING_get_wAuthnSvc(PyObject *obj, void *closure)
{
	struct SECURITYBINDING *object = (struct SECURITYBINDING *)pytalloc_get_ptr(obj);
	PyObject *py_wAuthnSvc;
	py_wAuthnSvc = PyInt_FromLong((uint16_t)object->wAuthnSvc);
	return py_wAuthnSvc;
}

static int py_SECURITYBINDING_set_wAuthnSvc(PyObject *py_obj, PyObject *value, void *closure)
{
	struct SECURITYBINDING *object = (struct SECURITYBINDING *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->wAuthnSvc");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->wAuthnSvc));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->wAuthnSvc = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->wAuthnSvc = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_SECURITYBINDING_get_wAuthzSvc(PyObject *obj, void *closure)
{
	struct SECURITYBINDING *object = (struct SECURITYBINDING *)pytalloc_get_ptr(obj);
	PyObject *py_wAuthzSvc;
	py_wAuthzSvc = PyInt_FromLong((uint16_t)object->wAuthzSvc);
	return py_wAuthzSvc;
}

static int py_SECURITYBINDING_set_wAuthzSvc(PyObject *py_obj, PyObject *value, void *closure)
{
	struct SECURITYBINDING *object = (struct SECURITYBINDING *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->wAuthzSvc");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->wAuthzSvc));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->wAuthzSvc = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->wAuthzSvc = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_SECURITYBINDING_get_PrincName(PyObject *obj, void *closure)
{
	struct SECURITYBINDING *object = (struct SECURITYBINDING *)pytalloc_get_ptr(obj);
	PyObject *py_PrincName;
	py_PrincName = PyString_FromStringOrNULL(object->PrincName);
	return py_PrincName;
}

static int py_SECURITYBINDING_set_PrincName(PyObject *py_obj, PyObject *value, void *closure)
{
	struct SECURITYBINDING *object = (struct SECURITYBINDING *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->PrincName");
		return -1;
	}
	{
		const char *test_str;
		const char *talloc_str;
		PyObject *unicode = NULL;
		if (PyUnicode_Check(value)) {
			unicode = PyUnicode_AsEncodedString(value, "utf-8", "ignore");
			if (unicode == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			test_str = PyBytes_AS_STRING(unicode);
		} else if (PyBytes_Check(value)) {
			test_str = PyBytes_AS_STRING(value);
		} else {
			PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
			return -1;
		}
		talloc_str = talloc_strdup(pytalloc_get_mem_ctx(py_obj), test_str);
		if (unicode != NULL) {
			Py_DECREF(unicode);
		}
		if (talloc_str == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->PrincName = talloc_str;
	}
	return 0;
}

static PyGetSetDef py_SECURITYBINDING_getsetters[] = {
	{
		.name = discard_const_p(char, "wAuthnSvc"),
		.get = py_SECURITYBINDING_get_wAuthnSvc,
		.set = py_SECURITYBINDING_set_wAuthnSvc,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "wAuthzSvc"),
		.get = py_SECURITYBINDING_get_wAuthzSvc,
		.set = py_SECURITYBINDING_set_wAuthzSvc,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "PrincName"),
		.get = py_SECURITYBINDING_get_PrincName,
		.set = py_SECURITYBINDING_set_PrincName,
		.doc = discard_const_p(char, "PIDL-generated element of base type string")
	},
	{ .name = NULL }
};

static PyObject *py_SECURITYBINDING_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct SECURITYBINDING, type);
}

static PyObject *py_SECURITYBINDING_ndr_pack(PyObject *py_obj)
{
	struct SECURITYBINDING *object = (struct SECURITYBINDING *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_SECURITYBINDING);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_SECURITYBINDING_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct SECURITYBINDING *object = (struct SECURITYBINDING *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_SECURITYBINDING);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_SECURITYBINDING);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_SECURITYBINDING_ndr_print(PyObject *py_obj)
{
	struct SECURITYBINDING *object = (struct SECURITYBINDING *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_SECURITYBINDING, "SECURITYBINDING", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_SECURITYBINDING_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_SECURITYBINDING_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_SECURITYBINDING_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_SECURITYBINDING_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject SECURITYBINDING_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "orpc.SECURITYBINDING",
	.tp_getset = py_SECURITYBINDING_getsetters,
	.tp_methods = py_SECURITYBINDING_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_SECURITYBINDING_new,
};


static PyObject *py_STDOBJREF_get_flags(PyObject *obj, void *closure)
{
	struct STDOBJREF *object = (struct STDOBJREF *)pytalloc_get_ptr(obj);
	PyObject *py_flags;
	py_flags = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->flags);
	return py_flags;
}

static int py_STDOBJREF_set_flags(PyObject *py_obj, PyObject *value, void *closure)
{
	struct STDOBJREF *object = (struct STDOBJREF *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->flags");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->flags));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->flags = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->flags = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_STDOBJREF_get_cPublicRefs(PyObject *obj, void *closure)
{
	struct STDOBJREF *object = (struct STDOBJREF *)pytalloc_get_ptr(obj);
	PyObject *py_cPublicRefs;
	py_cPublicRefs = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->cPublicRefs);
	return py_cPublicRefs;
}

static int py_STDOBJREF_set_cPublicRefs(PyObject *py_obj, PyObject *value, void *closure)
{
	struct STDOBJREF *object = (struct STDOBJREF *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cPublicRefs");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->cPublicRefs));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cPublicRefs = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cPublicRefs = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_STDOBJREF_get_oxid(PyObject *obj, void *closure)
{
	struct STDOBJREF *object = (struct STDOBJREF *)pytalloc_get_ptr(obj);
	PyObject *py_oxid;
	py_oxid = ndr_PyLong_FromUnsignedLongLong(object->oxid);
	return py_oxid;
}

static int py_STDOBJREF_set_oxid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct STDOBJREF *object = (struct STDOBJREF *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->oxid");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->oxid));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->oxid = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->oxid = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_STDOBJREF_get_oid(PyObject *obj, void *closure)
{
	struct STDOBJREF *object = (struct STDOBJREF *)pytalloc_get_ptr(obj);
	PyObject *py_oid;
	py_oid = ndr_PyLong_FromUnsignedLongLong(object->oid);
	return py_oid;
}

static int py_STDOBJREF_set_oid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct STDOBJREF *object = (struct STDOBJREF *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->oid");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->oid));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->oid = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->oid = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_STDOBJREF_get_ipid(PyObject *obj, void *closure)
{
	struct STDOBJREF *object = (struct STDOBJREF *)pytalloc_get_ptr(obj);
	PyObject *py_ipid;
	py_ipid = pytalloc_reference_ex(GUID_Type, pytalloc_get_mem_ctx(obj), &object->ipid);
	return py_ipid;
}

static int py_STDOBJREF_set_ipid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct STDOBJREF *object = (struct STDOBJREF *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->ipid");
		return -1;
	}
	PY_CHECK_TYPE(GUID_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->ipid = *(struct GUID *)pytalloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_STDOBJREF_getsetters[] = {
	{
		.name = discard_const_p(char, "flags"),
		.get = py_STDOBJREF_get_flags,
		.set = py_STDOBJREF_set_flags,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "cPublicRefs"),
		.get = py_STDOBJREF_get_cPublicRefs,
		.set = py_STDOBJREF_set_cPublicRefs,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "oxid"),
		.get = py_STDOBJREF_get_oxid,
		.set = py_STDOBJREF_set_oxid,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{
		.name = discard_const_p(char, "oid"),
		.get = py_STDOBJREF_get_oid,
		.set = py_STDOBJREF_set_oid,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{
		.name = discard_const_p(char, "ipid"),
		.get = py_STDOBJREF_get_ipid,
		.set = py_STDOBJREF_set_ipid,
		.doc = discard_const_p(char, "PIDL-generated element of base type GUID")
	},
	{ .name = NULL }
};

static PyObject *py_STDOBJREF_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct STDOBJREF, type);
}

static PyObject *py_STDOBJREF_ndr_pack(PyObject *py_obj)
{
	struct STDOBJREF *object = (struct STDOBJREF *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_STDOBJREF);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_STDOBJREF_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct STDOBJREF *object = (struct STDOBJREF *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_STDOBJREF);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_STDOBJREF);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_STDOBJREF_ndr_print(PyObject *py_obj)
{
	struct STDOBJREF *object = (struct STDOBJREF *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_STDOBJREF, "STDOBJREF", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_STDOBJREF_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_STDOBJREF_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_STDOBJREF_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_STDOBJREF_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject STDOBJREF_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "orpc.STDOBJREF",
	.tp_getset = py_STDOBJREF_getsetters,
	.tp_methods = py_STDOBJREF_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_STDOBJREF_new,
};


static PyObject *py_u_standard_get_std(PyObject *obj, void *closure)
{
	struct u_standard *object = (struct u_standard *)pytalloc_get_ptr(obj);
	PyObject *py_std;
	py_std = pytalloc_reference_ex(&STDOBJREF_Type, pytalloc_get_mem_ctx(obj), &object->std);
	return py_std;
}

static int py_u_standard_set_std(PyObject *py_obj, PyObject *value, void *closure)
{
	struct u_standard *object = (struct u_standard *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->std");
		return -1;
	}
	PY_CHECK_TYPE(&STDOBJREF_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->std = *(struct STDOBJREF *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_u_standard_get_saResAddr(PyObject *obj, void *closure)
{
	struct u_standard *object = (struct u_standard *)pytalloc_get_ptr(obj);
	PyObject *py_saResAddr;
	py_saResAddr = pytalloc_reference_ex(&STRINGARRAY_Type, pytalloc_get_mem_ctx(obj), &object->saResAddr);
	return py_saResAddr;
}

static int py_u_standard_set_saResAddr(PyObject *py_obj, PyObject *value, void *closure)
{
	struct u_standard *object = (struct u_standard *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->saResAddr");
		return -1;
	}
	PY_CHECK_TYPE(&STRINGARRAY_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->saResAddr = *(struct STRINGARRAY *)pytalloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_u_standard_getsetters[] = {
	{
		.name = discard_const_p(char, "std"),
		.get = py_u_standard_get_std,
		.set = py_u_standard_set_std,
		.doc = discard_const_p(char, "PIDL-generated element of base type STDOBJREF")
	},
	{
		.name = discard_const_p(char, "saResAddr"),
		.get = py_u_standard_get_saResAddr,
		.set = py_u_standard_set_saResAddr,
		.doc = discard_const_p(char, "PIDL-generated element of base type STRINGARRAY")
	},
	{ .name = NULL }
};

static PyObject *py_u_standard_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct u_standard, type);
}


static PyTypeObject u_standard_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "orpc.u_standard",
	.tp_getset = py_u_standard_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_u_standard_new,
};


static PyObject *py_u_handler_get_std(PyObject *obj, void *closure)
{
	struct u_handler *object = (struct u_handler *)pytalloc_get_ptr(obj);
	PyObject *py_std;
	py_std = pytalloc_reference_ex(&STDOBJREF_Type, pytalloc_get_mem_ctx(obj), &object->std);
	return py_std;
}

static int py_u_handler_set_std(PyObject *py_obj, PyObject *value, void *closure)
{
	struct u_handler *object = (struct u_handler *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->std");
		return -1;
	}
	PY_CHECK_TYPE(&STDOBJREF_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->std = *(struct STDOBJREF *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_u_handler_get_clsid(PyObject *obj, void *closure)
{
	struct u_handler *object = (struct u_handler *)pytalloc_get_ptr(obj);
	PyObject *py_clsid;
	py_clsid = pytalloc_reference_ex(GUID_Type, pytalloc_get_mem_ctx(obj), &object->clsid);
	return py_clsid;
}

static int py_u_handler_set_clsid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct u_handler *object = (struct u_handler *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->clsid");
		return -1;
	}
	PY_CHECK_TYPE(GUID_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->clsid = *(struct GUID *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_u_handler_get_saResAddr(PyObject *obj, void *closure)
{
	struct u_handler *object = (struct u_handler *)pytalloc_get_ptr(obj);
	PyObject *py_saResAddr;
	py_saResAddr = pytalloc_reference_ex(&STRINGARRAY_Type, pytalloc_get_mem_ctx(obj), &object->saResAddr);
	return py_saResAddr;
}

static int py_u_handler_set_saResAddr(PyObject *py_obj, PyObject *value, void *closure)
{
	struct u_handler *object = (struct u_handler *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->saResAddr");
		return -1;
	}
	PY_CHECK_TYPE(&STRINGARRAY_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->saResAddr = *(struct STRINGARRAY *)pytalloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_u_handler_getsetters[] = {
	{
		.name = discard_const_p(char, "std"),
		.get = py_u_handler_get_std,
		.set = py_u_handler_set_std,
		.doc = discard_const_p(char, "PIDL-generated element of base type STDOBJREF")
	},
	{
		.name = discard_const_p(char, "clsid"),
		.get = py_u_handler_get_clsid,
		.set = py_u_handler_set_clsid,
		.doc = discard_const_p(char, "PIDL-generated element of base type GUID")
	},
	{
		.name = discard_const_p(char, "saResAddr"),
		.get = py_u_handler_get_saResAddr,
		.set = py_u_handler_set_saResAddr,
		.doc = discard_const_p(char, "PIDL-generated element of base type STRINGARRAY")
	},
	{ .name = NULL }
};

static PyObject *py_u_handler_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct u_handler, type);
}


static PyTypeObject u_handler_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "orpc.u_handler",
	.tp_getset = py_u_handler_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_u_handler_new,
};


static PyObject *py_u_custom_get_clsid(PyObject *obj, void *closure)
{
	struct u_custom *object = (struct u_custom *)pytalloc_get_ptr(obj);
	PyObject *py_clsid;
	py_clsid = pytalloc_reference_ex(GUID_Type, pytalloc_get_mem_ctx(obj), &object->clsid);
	return py_clsid;
}

static int py_u_custom_set_clsid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct u_custom *object = (struct u_custom *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->clsid");
		return -1;
	}
	PY_CHECK_TYPE(GUID_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->clsid = *(struct GUID *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_u_custom_get_cbExtension(PyObject *obj, void *closure)
{
	struct u_custom *object = (struct u_custom *)pytalloc_get_ptr(obj);
	PyObject *py_cbExtension;
	py_cbExtension = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->cbExtension);
	return py_cbExtension;
}

static int py_u_custom_set_cbExtension(PyObject *py_obj, PyObject *value, void *closure)
{
	struct u_custom *object = (struct u_custom *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->cbExtension");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->cbExtension));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cbExtension = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->cbExtension = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_u_custom_get_size(PyObject *obj, void *closure)
{
	struct u_custom *object = (struct u_custom *)pytalloc_get_ptr(obj);
	PyObject *py_size;
	py_size = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->size);
	return py_size;
}

static int py_u_custom_set_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct u_custom *object = (struct u_custom *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_u_custom_get_pData(PyObject *obj, void *closure)
{
	struct u_custom *object = (struct u_custom *)pytalloc_get_ptr(obj);
	PyObject *py_pData;
	py_pData = PyList_New(object->size);
	if (py_pData == NULL) {
		return NULL;
	}
	{
		int pData_cntr_0;
		for (pData_cntr_0 = 0; pData_cntr_0 < (object->size); pData_cntr_0++) {
			PyObject *py_pData_0;
			py_pData_0 = PyInt_FromLong((uint16_t)object->pData[pData_cntr_0]);
			PyList_SetItem(py_pData, pData_cntr_0, py_pData_0);
		}
	}
	return py_pData;
}

static int py_u_custom_set_pData(PyObject *py_obj, PyObject *value, void *closure)
{
	struct u_custom *object = (struct u_custom *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->pData");
		return -1;
	}
	PY_CHECK_TYPE(&PyList_Type, value, return -1;);
	{
		int pData_cntr_0;
		object->pData = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->pData, PyList_GET_SIZE(value));
		if (!object->pData) { return -1;; }
		talloc_set_name_const(object->pData, "ARRAY: object->pData");
		for (pData_cntr_0 = 0; pData_cntr_0 < PyList_GET_SIZE(value); pData_cntr_0++) {
			if (PyList_GET_ITEM(value, pData_cntr_0) == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->pData[pData_cntr_0]");
				return -1;
			}
			{
				const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->pData[pData_cntr_0]));
				if (PyLong_Check(PyList_GET_ITEM(value, pData_cntr_0))) {
					unsigned long long test_var;
					test_var = PyLong_AsUnsignedLongLong(PyList_GET_ITEM(value, pData_cntr_0));
					if (PyErr_Occurred() != NULL) {
						return -1;
					}
					if (test_var > uint_max) {
						PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
						  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
						return -1;
					}
					object->pData[pData_cntr_0] = test_var;
				} else if (PyInt_Check(PyList_GET_ITEM(value, pData_cntr_0))) {
					long test_var;
					test_var = PyInt_AsLong(PyList_GET_ITEM(value, pData_cntr_0));
					if (test_var < 0 || test_var > uint_max) {
						PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
						  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
						return -1;
					}
					object->pData[pData_cntr_0] = test_var;
				} else {
					PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
					  PyInt_Type.tp_name, PyLong_Type.tp_name);
					return -1;
				}
			}
		}
	}
	return 0;
}

static PyGetSetDef py_u_custom_getsetters[] = {
	{
		.name = discard_const_p(char, "clsid"),
		.get = py_u_custom_get_clsid,
		.set = py_u_custom_set_clsid,
		.doc = discard_const_p(char, "PIDL-generated element of base type GUID")
	},
	{
		.name = discard_const_p(char, "cbExtension"),
		.get = py_u_custom_get_cbExtension,
		.set = py_u_custom_set_cbExtension,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "size"),
		.get = py_u_custom_get_size,
		.set = py_u_custom_set_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "pData"),
		.get = py_u_custom_get_pData,
		.set = py_u_custom_set_pData,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint8")
	},
	{ .name = NULL }
};

static PyObject *py_u_custom_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct u_custom, type);
}


static PyTypeObject u_custom_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "orpc.u_custom",
	.tp_getset = py_u_custom_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_u_custom_new,
};


static PyObject *py_u_null_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct u_null, type);
}


static PyTypeObject u_null_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "orpc.u_null",
	.tp_getset = NULL,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_u_null_new,
};

static PyObject *py_import_OBJREF_Types(TALLOC_CTX *mem_ctx, int level, union OBJREF_Types *in)
{
	PyObject *ret;

	switch (level) {
		case OBJREF_NULL:
			ret = pytalloc_reference_ex(&u_null_Type, mem_ctx, &in->u_null);
			return ret;

		case OBJREF_STANDARD:
			ret = pytalloc_reference_ex(&u_standard_Type, mem_ctx, &in->u_standard);
			return ret;

		case OBJREF_HANDLER:
			ret = pytalloc_reference_ex(&u_handler_Type, mem_ctx, &in->u_handler);
			return ret;

		case OBJREF_CUSTOM:
			ret = pytalloc_reference_ex(&u_custom_Type, mem_ctx, &in->u_custom);
			return ret;

	}
	PyErr_SetString(PyExc_TypeError, "unknown union level");
	return NULL;
}

static union OBJREF_Types *py_export_OBJREF_Types(TALLOC_CTX *mem_ctx, int level, PyObject *in)
{
	union OBJREF_Types *ret = talloc_zero(mem_ctx, union OBJREF_Types);
	switch (level) {
		case OBJREF_NULL:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->u_null");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&u_null_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->u_null = *(struct u_null *)pytalloc_get_ptr(in);
			break;

		case OBJREF_STANDARD:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->u_standard");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&u_standard_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->u_standard = *(struct u_standard *)pytalloc_get_ptr(in);
			break;

		case OBJREF_HANDLER:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->u_handler");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&u_handler_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->u_handler = *(struct u_handler *)pytalloc_get_ptr(in);
			break;

		case OBJREF_CUSTOM:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->u_custom");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(&u_custom_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->u_custom = *(struct u_custom *)pytalloc_get_ptr(in);
			break;

		default:
			PyErr_SetString(PyExc_TypeError, "invalid union level value");
			talloc_free(ret);
			ret = NULL;
	}

	return ret;
}

static PyObject *py_OBJREF_Types_import(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "mem_ctx", "level", "in", NULL };
	PyObject *mem_ctx_obj = NULL;
	TALLOC_CTX *mem_ctx = NULL;
	int level = 0;
	PyObject *in_obj = NULL;
	union OBJREF_Types *in = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiO:import",
		discard_const_p(char *, kwnames),
		&mem_ctx_obj,
		&level,
		&in_obj)) {
		return NULL;
	}
	mem_ctx = pytalloc_get_ptr(mem_ctx_obj);
	if (mem_ctx == NULL) {
		PyErr_SetString(PyExc_TypeError, "mem_ctx is NULL)!");
		return NULL;
	}
	in = (union OBJREF_Types *)pytalloc_get_ptr(in_obj);
	if (in == NULL) {
		PyErr_Format(PyExc_TypeError, "in needs to be a pointer to union OBJREF_Types!");
		return NULL;
	}

	return py_import_OBJREF_Types(mem_ctx, level, in);
}

static PyObject *py_OBJREF_Types_export(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "mem_ctx", "level", "in", NULL };
	PyObject *mem_ctx_obj = NULL;
	TALLOC_CTX *mem_ctx = NULL;
	int level = 0;
	PyObject *in = NULL;
	union OBJREF_Types *out = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiO:import",
		discard_const_p(char *, kwnames),
		&mem_ctx_obj,
		&level,
		&in)) {
		return NULL;
	}
	mem_ctx = pytalloc_get_ptr(mem_ctx_obj);
	if (mem_ctx == NULL) {
		PyErr_SetString(PyExc_TypeError, "mem_ctx is NULL)!");
		return NULL;
	}

	out = py_export_OBJREF_Types(mem_ctx, level, in);
	if (out == NULL) {
		return NULL;
	}

	return pytalloc_GenericObject_reference(out);
}

static PyMethodDef py_OBJREF_Types_methods[] = {
	{ "__import__", (PyCFunction)py_OBJREF_Types_import,
		METH_VARARGS|METH_KEYWORDS|METH_CLASS,
		"T.__import__(mem_ctx, level, in) => ret." },
	{ "__export__", (PyCFunction)py_OBJREF_Types_export,
		METH_VARARGS|METH_KEYWORDS|METH_CLASS,
		"T.__export__(mem_ctx, level, in) => ret." },
	{ NULL, NULL, 0, NULL }
};

static PyObject *py_OBJREF_Types_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	PyErr_Format(PyExc_TypeError, "New %s Objects are not supported", type->tp_name);
	return NULL;
}


static PyTypeObject OBJREF_Types_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "orpc.OBJREF_Types",
	.tp_getset = NULL,
	.tp_methods = py_OBJREF_Types_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_OBJREF_Types_new,
};


static PyObject *py_OBJREF_get_signature(PyObject *obj, void *closure)
{
	struct OBJREF *object = (struct OBJREF *)pytalloc_get_ptr(obj);
	PyObject *py_signature;
	py_signature = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->signature);
	return py_signature;
}

static int py_OBJREF_set_signature(PyObject *py_obj, PyObject *value, void *closure)
{
	struct OBJREF *object = (struct OBJREF *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->signature");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->signature));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->signature = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->signature = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_OBJREF_get_flags(PyObject *obj, void *closure)
{
	struct OBJREF *object = (struct OBJREF *)pytalloc_get_ptr(obj);
	PyObject *py_flags;
	py_flags = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->flags);
	return py_flags;
}

static int py_OBJREF_set_flags(PyObject *py_obj, PyObject *value, void *closure)
{
	struct OBJREF *object = (struct OBJREF *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->flags");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->flags));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->flags = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->flags = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_OBJREF_get_iid(PyObject *obj, void *closure)
{
	struct OBJREF *object = (struct OBJREF *)pytalloc_get_ptr(obj);
	PyObject *py_iid;
	py_iid = pytalloc_reference_ex(GUID_Type, pytalloc_get_mem_ctx(obj), &object->iid);
	return py_iid;
}

static int py_OBJREF_set_iid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct OBJREF *object = (struct OBJREF *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->iid");
		return -1;
	}
	PY_CHECK_TYPE(GUID_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->iid = *(struct GUID *)pytalloc_get_ptr(value);
	return 0;
}

static PyObject *py_OBJREF_get_u_objref(PyObject *obj, void *closure)
{
	struct OBJREF *object = (struct OBJREF *)pytalloc_get_ptr(obj);
	PyObject *py_u_objref;
	py_u_objref = pyrpc_import_union(&OBJREF_Types_Type, pytalloc_get_mem_ctx(obj), object->flags, &object->u_objref, "union OBJREF_Types");
	if (py_u_objref == NULL) {
		return NULL;
	}
	return py_u_objref;
}

static int py_OBJREF_set_u_objref(PyObject *py_obj, PyObject *value, void *closure)
{
	struct OBJREF *object = (struct OBJREF *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->u_objref");
		return -1;
	}
	{
		union OBJREF_Types *u_objref_switch_0;
		u_objref_switch_0 = (union OBJREF_Types *)pyrpc_export_union(&OBJREF_Types_Type, pytalloc_get_mem_ctx(py_obj), object->flags, value, "union OBJREF_Types");
		if (u_objref_switch_0 == NULL) {
			return -1;
		}
		object->u_objref = *u_objref_switch_0;
	}
	return 0;
}

static PyGetSetDef py_OBJREF_getsetters[] = {
	{
		.name = discard_const_p(char, "signature"),
		.get = py_OBJREF_get_signature,
		.set = py_OBJREF_set_signature,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "flags"),
		.get = py_OBJREF_get_flags,
		.set = py_OBJREF_set_flags,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "iid"),
		.get = py_OBJREF_get_iid,
		.set = py_OBJREF_set_iid,
		.doc = discard_const_p(char, "PIDL-generated element of base type GUID")
	},
	{
		.name = discard_const_p(char, "u_objref"),
		.get = py_OBJREF_get_u_objref,
		.set = py_OBJREF_set_u_objref,
		.doc = discard_const_p(char, "PIDL-generated element of base type OBJREF_Types")
	},
	{ .name = NULL }
};

static PyObject *py_OBJREF_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct OBJREF, type);
}

static PyObject *py_OBJREF_ndr_pack(PyObject *py_obj)
{
	struct OBJREF *object = (struct OBJREF *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_OBJREF);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_OBJREF_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct OBJREF *object = (struct OBJREF *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_OBJREF);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_OBJREF);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_OBJREF_ndr_print(PyObject *py_obj)
{
	struct OBJREF *object = (struct OBJREF *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_OBJREF, "OBJREF", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_OBJREF_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_OBJREF_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_OBJREF_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_OBJREF_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject OBJREF_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "orpc.OBJREF",
	.tp_getset = py_OBJREF_getsetters,
	.tp_methods = py_OBJREF_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_OBJREF_new,
};


static PyObject *py_MInterfacePointer_get_size(PyObject *obj, void *closure)
{
	struct MInterfacePointer *object = (struct MInterfacePointer *)pytalloc_get_ptr(obj);
	PyObject *py_size;
	py_size = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->size);
	return py_size;
}

static int py_MInterfacePointer_set_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct MInterfacePointer *object = (struct MInterfacePointer *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_MInterfacePointer_get_obj(PyObject *obj, void *closure)
{
	struct MInterfacePointer *object = (struct MInterfacePointer *)pytalloc_get_ptr(obj);
	PyObject *py_obj;
	py_obj = pytalloc_reference_ex(&OBJREF_Type, pytalloc_get_mem_ctx(obj), &object->obj);
	return py_obj;
}

static int py_MInterfacePointer_set_obj(PyObject *py_obj, PyObject *value, void *closure)
{
	struct MInterfacePointer *object = (struct MInterfacePointer *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->obj");
		return -1;
	}
	PY_CHECK_TYPE(&OBJREF_Type, value, return -1;);
	if (talloc_reference(pytalloc_get_mem_ctx(py_obj), pytalloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->obj = *(struct OBJREF *)pytalloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_MInterfacePointer_getsetters[] = {
	{
		.name = discard_const_p(char, "size"),
		.get = py_MInterfacePointer_get_size,
		.set = py_MInterfacePointer_set_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "obj"),
		.get = py_MInterfacePointer_get_obj,
		.set = py_MInterfacePointer_set_obj,
		.doc = discard_const_p(char, "PIDL-generated element of base type OBJREF")
	},
	{ .name = NULL }
};

static PyObject *py_MInterfacePointer_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct MInterfacePointer, type);
}

static PyObject *py_MInterfacePointer_ndr_pack(PyObject *py_obj)
{
	struct MInterfacePointer *object = (struct MInterfacePointer *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_MInterfacePointer);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_MInterfacePointer_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct MInterfacePointer *object = (struct MInterfacePointer *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_MInterfacePointer);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_MInterfacePointer);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_MInterfacePointer_ndr_print(PyObject *py_obj)
{
	struct MInterfacePointer *object = (struct MInterfacePointer *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_MInterfacePointer, "MInterfacePointer", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_MInterfacePointer_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_MInterfacePointer_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_MInterfacePointer_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_MInterfacePointer_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject MInterfacePointer_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "orpc.MInterfacePointer",
	.tp_getset = py_MInterfacePointer_getsetters,
	.tp_methods = py_MInterfacePointer_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_MInterfacePointer_new,
};

static PyMethodDef orpc_methods[] = {
	{ NULL, NULL, 0, NULL }
};

static struct PyModuleDef moduledef = {
	PyModuleDef_HEAD_INIT,
	.m_name = "orpc",
	.m_doc = "orpc DCE/RPC",
	.m_size = -1,
	.m_methods = orpc_methods,
};
MODULE_INIT_FUNC(orpc)
{
	PyObject *m;
	PyObject *dep_samba_dcerpc_misc;
	PyObject *dep_talloc;

	dep_samba_dcerpc_misc = PyImport_ImportModule("samba.dcerpc.misc");
	if (dep_samba_dcerpc_misc == NULL)
		return NULL;

	dep_talloc = PyImport_ImportModule("talloc");
	if (dep_talloc == NULL)
		return NULL;

	BaseObject_Type = (PyTypeObject *)PyObject_GetAttrString(dep_talloc, "BaseObject");
	if (BaseObject_Type == NULL)
		return NULL;

	GUID_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_misc, "GUID");
	if (GUID_Type == NULL)
		return NULL;

	COMVERSION_Type.tp_base = BaseObject_Type;
	COMVERSION_Type.tp_basicsize = pytalloc_BaseObject_size();

	ORPC_EXTENT_Type.tp_base = BaseObject_Type;
	ORPC_EXTENT_Type.tp_basicsize = pytalloc_BaseObject_size();

	ORPC_EXTENT_ARRAY_Type.tp_base = BaseObject_Type;
	ORPC_EXTENT_ARRAY_Type.tp_basicsize = pytalloc_BaseObject_size();

	ORPCTHIS_Type.tp_base = BaseObject_Type;
	ORPCTHIS_Type.tp_basicsize = pytalloc_BaseObject_size();

	ORPCTHAT_Type.tp_base = BaseObject_Type;
	ORPCTHAT_Type.tp_basicsize = pytalloc_BaseObject_size();

	STRINGBINDING_Type.tp_base = BaseObject_Type;
	STRINGBINDING_Type.tp_basicsize = pytalloc_BaseObject_size();

	STRINGARRAY_Type.tp_base = BaseObject_Type;
	STRINGARRAY_Type.tp_basicsize = pytalloc_BaseObject_size();

	DUALSTRINGARRAY_Type.tp_base = BaseObject_Type;
	DUALSTRINGARRAY_Type.tp_basicsize = pytalloc_BaseObject_size();

	SECURITYBINDING_Type.tp_base = BaseObject_Type;
	SECURITYBINDING_Type.tp_basicsize = pytalloc_BaseObject_size();

	STDOBJREF_Type.tp_base = BaseObject_Type;
	STDOBJREF_Type.tp_basicsize = pytalloc_BaseObject_size();

	u_standard_Type.tp_base = BaseObject_Type;
	u_standard_Type.tp_basicsize = pytalloc_BaseObject_size();

	u_handler_Type.tp_base = BaseObject_Type;
	u_handler_Type.tp_basicsize = pytalloc_BaseObject_size();

	u_custom_Type.tp_base = BaseObject_Type;
	u_custom_Type.tp_basicsize = pytalloc_BaseObject_size();

	u_null_Type.tp_base = BaseObject_Type;
	u_null_Type.tp_basicsize = pytalloc_BaseObject_size();

	OBJREF_Types_Type.tp_base = BaseObject_Type;
	OBJREF_Types_Type.tp_basicsize = pytalloc_BaseObject_size();

	OBJREF_Type.tp_base = BaseObject_Type;
	OBJREF_Type.tp_basicsize = pytalloc_BaseObject_size();

	MInterfacePointer_Type.tp_base = BaseObject_Type;
	MInterfacePointer_Type.tp_basicsize = pytalloc_BaseObject_size();

	if (PyType_Ready(&COMVERSION_Type) < 0)
		return NULL;
	if (PyType_Ready(&ORPC_EXTENT_Type) < 0)
		return NULL;
	if (PyType_Ready(&ORPC_EXTENT_ARRAY_Type) < 0)
		return NULL;
	if (PyType_Ready(&ORPCTHIS_Type) < 0)
		return NULL;
	if (PyType_Ready(&ORPCTHAT_Type) < 0)
		return NULL;
	if (PyType_Ready(&STRINGBINDING_Type) < 0)
		return NULL;
	if (PyType_Ready(&STRINGARRAY_Type) < 0)
		return NULL;
	if (PyType_Ready(&DUALSTRINGARRAY_Type) < 0)
		return NULL;
	if (PyType_Ready(&SECURITYBINDING_Type) < 0)
		return NULL;
	if (PyType_Ready(&STDOBJREF_Type) < 0)
		return NULL;
	if (PyType_Ready(&u_standard_Type) < 0)
		return NULL;
	if (PyType_Ready(&u_handler_Type) < 0)
		return NULL;
	if (PyType_Ready(&u_custom_Type) < 0)
		return NULL;
	if (PyType_Ready(&u_null_Type) < 0)
		return NULL;
	if (PyType_Ready(&OBJREF_Types_Type) < 0)
		return NULL;
	if (PyType_Ready(&OBJREF_Type) < 0)
		return NULL;
	if (PyType_Ready(&MInterfacePointer_Type) < 0)
		return NULL;
#ifdef PY_COMVERSION_PATCH
	PY_COMVERSION_PATCH(&COMVERSION_Type);
#endif
#ifdef PY_ORPC_EXTENT_PATCH
	PY_ORPC_EXTENT_PATCH(&ORPC_EXTENT_Type);
#endif
#ifdef PY_ORPC_EXTENT_ARRAY_PATCH
	PY_ORPC_EXTENT_ARRAY_PATCH(&ORPC_EXTENT_ARRAY_Type);
#endif
#ifdef PY_ORPCTHIS_PATCH
	PY_ORPCTHIS_PATCH(&ORPCTHIS_Type);
#endif
#ifdef PY_ORPCTHAT_PATCH
	PY_ORPCTHAT_PATCH(&ORPCTHAT_Type);
#endif
#ifdef PY_STRINGBINDING_PATCH
	PY_STRINGBINDING_PATCH(&STRINGBINDING_Type);
#endif
#ifdef PY_STRINGARRAY_PATCH
	PY_STRINGARRAY_PATCH(&STRINGARRAY_Type);
#endif
#ifdef PY_DUALSTRINGARRAY_PATCH
	PY_DUALSTRINGARRAY_PATCH(&DUALSTRINGARRAY_Type);
#endif
#ifdef PY_SECURITYBINDING_PATCH
	PY_SECURITYBINDING_PATCH(&SECURITYBINDING_Type);
#endif
#ifdef PY_STDOBJREF_PATCH
	PY_STDOBJREF_PATCH(&STDOBJREF_Type);
#endif
#ifdef PY_U_STANDARD_PATCH
	PY_U_STANDARD_PATCH(&u_standard_Type);
#endif
#ifdef PY_U_HANDLER_PATCH
	PY_U_HANDLER_PATCH(&u_handler_Type);
#endif
#ifdef PY_U_CUSTOM_PATCH
	PY_U_CUSTOM_PATCH(&u_custom_Type);
#endif
#ifdef PY_U_NULL_PATCH
	PY_U_NULL_PATCH(&u_null_Type);
#endif
#ifdef PY_OBJREF_TYPES_PATCH
	PY_OBJREF_TYPES_PATCH(&OBJREF_Types_Type);
#endif
#ifdef PY_OBJREF_PATCH
	PY_OBJREF_PATCH(&OBJREF_Type);
#endif
#ifdef PY_MINTERFACEPOINTER_PATCH
	PY_MINTERFACEPOINTER_PATCH(&MInterfacePointer_Type);
#endif

	m = PyModule_Create(&moduledef);
	if (m == NULL)
		return NULL;

	PyModule_AddObject(m, "COM_MAJOR_VERSION", ndr_PyLong_FromUnsignedLongLong(5));
	PyModule_AddObject(m, "COM_MINOR_VERSION", ndr_PyLong_FromUnsignedLongLong(1));
	PyModule_AddObject(m, "dcom_ext_debugging", PyStr_FromString("f1f19680-4d2a-11ce-a66a-0020af6e72f4"));
	PyModule_AddObject(m, "dcom_ext_extended_error", PyStr_FromString("f1f19681-4d2a-11ce-a66a-0020af6e72f4"));
	PyModule_AddObject(m, "COM_C_AUTHZ_NONE", ndr_PyLong_FromUnsignedLongLong(0xffff));
	PyModule_AddObject(m, "OBJREF_SIGNATURE", ndr_PyLong_FromUnsignedLongLong(0x574f454d));
	PyModule_AddObject(m, "ORPCF_NULL", ndr_PyLong_FromUnsignedLongLong((uint32_t)ORPCF_NULL));
	PyModule_AddObject(m, "ORPCF_LOCAL", ndr_PyLong_FromUnsignedLongLong((uint32_t)ORPCF_LOCAL));
	PyModule_AddObject(m, "ORPCF_RESERVED1", ndr_PyLong_FromUnsignedLongLong((uint32_t)ORPCF_RESERVED1));
	PyModule_AddObject(m, "ORPCF_RESERVED2", ndr_PyLong_FromUnsignedLongLong((uint32_t)ORPCF_RESERVED2));
	PyModule_AddObject(m, "ORPCF_RESERVED3", ndr_PyLong_FromUnsignedLongLong((uint32_t)ORPCF_RESERVED3));
	PyModule_AddObject(m, "ORPCF_RESERVED4", ndr_PyLong_FromUnsignedLongLong((uint32_t)ORPCF_RESERVED4));
	PyModule_AddObject(m, "OBJREF_NULL", PyInt_FromLong((uint16_t)OBJREF_NULL));
	PyModule_AddObject(m, "OBJREF_STANDARD", PyInt_FromLong((uint16_t)OBJREF_STANDARD));
	PyModule_AddObject(m, "OBJREF_HANDLER", PyInt_FromLong((uint16_t)OBJREF_HANDLER));
	PyModule_AddObject(m, "OBJREF_CUSTOM", PyInt_FromLong((uint16_t)OBJREF_CUSTOM));
	PyModule_AddObject(m, "SORF_NULL", ndr_PyLong_FromUnsignedLongLong((uint32_t)SORF_NULL));
	PyModule_AddObject(m, "SORF_OXRES1", ndr_PyLong_FromUnsignedLongLong((uint32_t)SORF_OXRES1));
	PyModule_AddObject(m, "SORF_OXRES2", ndr_PyLong_FromUnsignedLongLong((uint32_t)SORF_OXRES2));
	PyModule_AddObject(m, "SORF_OXRES3", ndr_PyLong_FromUnsignedLongLong((uint32_t)SORF_OXRES3));
	PyModule_AddObject(m, "SORF_OXRES4", ndr_PyLong_FromUnsignedLongLong((uint32_t)SORF_OXRES4));
	PyModule_AddObject(m, "SORF_OXRES5", ndr_PyLong_FromUnsignedLongLong((uint32_t)SORF_OXRES5));
	PyModule_AddObject(m, "SORF_OXRES6", ndr_PyLong_FromUnsignedLongLong((uint32_t)SORF_OXRES6));
	PyModule_AddObject(m, "SORF_OXRES7", ndr_PyLong_FromUnsignedLongLong((uint32_t)SORF_OXRES7));
	PyModule_AddObject(m, "SORF_OXRES8", ndr_PyLong_FromUnsignedLongLong((uint32_t)SORF_OXRES8));
	PyModule_AddObject(m, "SORF_NOPING", ndr_PyLong_FromUnsignedLongLong((uint32_t)SORF_NOPING));
	PyModule_AddObject(m, "COM_OK", ndr_PyLong_FromUnsignedLongLong((uint32_t)COM_OK));
	PyModule_AddObject(m, "COM_OUTOFMEMORY", ndr_PyLong_FromUnsignedLongLong((uint32_t)COM_OUTOFMEMORY));
	PyModule_AddObject(m, "COM_INVALIDARG", ndr_PyLong_FromUnsignedLongLong((uint32_t)COM_INVALIDARG));
	PyModule_AddObject(m, "COM_NOINTERFACE", ndr_PyLong_FromUnsignedLongLong((uint32_t)COM_NOINTERFACE));
	PyModule_AddObject(m, "COM_ACCESSDENIED", ndr_PyLong_FromUnsignedLongLong((uint32_t)COM_ACCESSDENIED));
	PyModule_AddObject(m, "COM_INVALID_OXID", ndr_PyLong_FromUnsignedLongLong((uint32_t)COM_INVALID_OXID));
	PyModule_AddObject(m, "COM_INVALID_OID", ndr_PyLong_FromUnsignedLongLong((uint32_t)COM_INVALID_OID));
	PyModule_AddObject(m, "COM_INVALID_SET", ndr_PyLong_FromUnsignedLongLong((uint32_t)COM_INVALID_SET));
	PyModule_AddObject(m, "COM_UNEXPECTED", ndr_PyLong_FromUnsignedLongLong((uint32_t)COM_UNEXPECTED));
	PyModule_AddObject(m, "COM_CLSNOTFOUND", ndr_PyLong_FromUnsignedLongLong((uint32_t)COM_CLSNOTFOUND));
	Py_INCREF((PyObject *)(void *)&COMVERSION_Type);
	PyModule_AddObject(m, "COMVERSION", (PyObject *)(void *)&COMVERSION_Type);
	Py_INCREF((PyObject *)(void *)&ORPC_EXTENT_Type);
	PyModule_AddObject(m, "ORPC_EXTENT", (PyObject *)(void *)&ORPC_EXTENT_Type);
	Py_INCREF((PyObject *)(void *)&ORPC_EXTENT_ARRAY_Type);
	PyModule_AddObject(m, "ORPC_EXTENT_ARRAY", (PyObject *)(void *)&ORPC_EXTENT_ARRAY_Type);
	Py_INCREF((PyObject *)(void *)&ORPCTHIS_Type);
	PyModule_AddObject(m, "ORPCTHIS", (PyObject *)(void *)&ORPCTHIS_Type);
	Py_INCREF((PyObject *)(void *)&ORPCTHAT_Type);
	PyModule_AddObject(m, "ORPCTHAT", (PyObject *)(void *)&ORPCTHAT_Type);
	Py_INCREF((PyObject *)(void *)&STRINGBINDING_Type);
	PyModule_AddObject(m, "STRINGBINDING", (PyObject *)(void *)&STRINGBINDING_Type);
	Py_INCREF((PyObject *)(void *)&STRINGARRAY_Type);
	PyModule_AddObject(m, "STRINGARRAY", (PyObject *)(void *)&STRINGARRAY_Type);
	Py_INCREF((PyObject *)(void *)&DUALSTRINGARRAY_Type);
	PyModule_AddObject(m, "DUALSTRINGARRAY", (PyObject *)(void *)&DUALSTRINGARRAY_Type);
	Py_INCREF((PyObject *)(void *)&SECURITYBINDING_Type);
	PyModule_AddObject(m, "SECURITYBINDING", (PyObject *)(void *)&SECURITYBINDING_Type);
	Py_INCREF((PyObject *)(void *)&STDOBJREF_Type);
	PyModule_AddObject(m, "STDOBJREF", (PyObject *)(void *)&STDOBJREF_Type);
	Py_INCREF((PyObject *)(void *)&u_standard_Type);
	PyModule_AddObject(m, "u_standard", (PyObject *)(void *)&u_standard_Type);
	Py_INCREF((PyObject *)(void *)&u_handler_Type);
	PyModule_AddObject(m, "u_handler", (PyObject *)(void *)&u_handler_Type);
	Py_INCREF((PyObject *)(void *)&u_custom_Type);
	PyModule_AddObject(m, "u_custom", (PyObject *)(void *)&u_custom_Type);
	Py_INCREF((PyObject *)(void *)&u_null_Type);
	PyModule_AddObject(m, "u_null", (PyObject *)(void *)&u_null_Type);
	Py_INCREF((PyObject *)(void *)&OBJREF_Types_Type);
	PyModule_AddObject(m, "OBJREF_Types", (PyObject *)(void *)&OBJREF_Types_Type);
	Py_INCREF((PyObject *)(void *)&OBJREF_Type);
	PyModule_AddObject(m, "OBJREF", (PyObject *)(void *)&OBJREF_Type);
	Py_INCREF((PyObject *)(void *)&MInterfacePointer_Type);
	PyModule_AddObject(m, "MInterfacePointer", (PyObject *)(void *)&MInterfacePointer_Type);
#ifdef PY_MOD_ORPC_PATCH
	PY_MOD_ORPC_PATCH(m);
#endif
	return m;

}
