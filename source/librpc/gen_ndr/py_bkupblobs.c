
/* Python wrapper functions auto-generated by pidl */
#define PY_SSIZE_T_CLEAN 1 /* We use Py_ssize_t for PyArg_ParseTupleAndKeywords */
#include <Python.h>
#include "python/py3compat.h"
#include "includes.h"
#include <pytalloc.h>
#include "librpc/rpc/pyrpc.h"
#include "librpc/rpc/pyrpc_util.h"
#include "bin/default/librpc/gen_ndr/ndr_bkupblobs.h"
#include "bin/default/librpc/gen_ndr/ndr_bkupblobs_c.h"

/*
 * These functions are here to ensure they can be optimized out by
 * the compiler based on the constant input values
 */

static inline unsigned long long ndr_sizeof2uintmax(size_t var_size)
{
	switch (var_size) {
	case 8:
		return UINT64_MAX;
	case 4:
		return UINT32_MAX;
	case 2:
		return UINT16_MAX;
	case 1:
		return UINT8_MAX;
	}

	return 0;
}

static inline long long ndr_sizeof2intmax(size_t var_size)
{
	switch (var_size) {
	case 8:
		return INT64_MAX;
	case 4:
		return INT32_MAX;
	case 2:
		return INT16_MAX;
	case 1:
		return INT8_MAX;
	}

	return 0;
}

static inline PyObject *ndr_PyLong_FromLongLong(long long v)
{
	if (v > LONG_MAX || v < LONG_MIN) {
		return PyLong_FromLongLong(v);
	} else {
		return PyInt_FromLong(v);
	}
}

static inline PyObject *ndr_PyLong_FromUnsignedLongLong(unsigned long long v)
{
	if (v > LONG_MAX) {
		return PyLong_FromUnsignedLongLong(v);
	} else {
		return PyInt_FromLong(v);
	}
}

#include "librpc/gen_ndr/misc.h"
#include "librpc/gen_ndr/security.h"
#include "librpc/gen_ndr/fscc.h"
static PyTypeObject bkup_StreamData_Type;
static PyTypeObject bkup_Win32StreamId_Type;
static PyTypeObject bkup_NTBackupFile_Type;

static PyTypeObject *security_descriptor_Type;
static PyTypeObject *fscc_FileObjectIdBuffer_2_Type;
static PyTypeObject *BaseObject_Type;
static PyObject *py_import_bkup_StreamData(TALLOC_CTX *mem_ctx, int level, union bkup_StreamData *in)
{
	PyObject *ret;

	switch (level) {
		default:
			ret = PyBytes_FromStringAndSize((char *)(in->blob).data, (in->blob).length);
			return ret;

		case STREAM_ID_SECURITY_DATA:
			ret = pytalloc_reference_ex(security_descriptor_Type, mem_ctx, &in->sd);
			return ret;

		case STREAM_ID_OBJECTID:
			ret = pytalloc_reference_ex(fscc_FileObjectIdBuffer_2_Type, mem_ctx, &in->object);
			return ret;

	}
	PyErr_SetString(PyExc_TypeError, "unknown union level");
	return NULL;
}

static union bkup_StreamData *py_export_bkup_StreamData(TALLOC_CTX *mem_ctx, int level, PyObject *in)
{
	union bkup_StreamData *ret = talloc_zero(mem_ctx, union bkup_StreamData);
	switch (level) {
		default:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->blob");
				talloc_free(ret); return NULL;
			}
			ret->blob = data_blob_talloc(mem_ctx, PyBytes_AS_STRING(in), PyBytes_GET_SIZE(in));
			break;

		case STREAM_ID_SECURITY_DATA:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->sd");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(security_descriptor_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->sd = *(struct security_descriptor *)pytalloc_get_ptr(in);
			break;

		case STREAM_ID_OBJECTID:
			if (in == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct ret->object");
				talloc_free(ret); return NULL;
			}
			PY_CHECK_TYPE(fscc_FileObjectIdBuffer_2_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, pytalloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->object = *(struct fscc_FileObjectIdBuffer_2 *)pytalloc_get_ptr(in);
			break;

	}

	return ret;
}

static PyObject *py_bkup_StreamData_import(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "mem_ctx", "level", "in", NULL };
	PyObject *mem_ctx_obj = NULL;
	TALLOC_CTX *mem_ctx = NULL;
	int level = 0;
	PyObject *in_obj = NULL;
	union bkup_StreamData *in = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiO:import",
		discard_const_p(char *, kwnames),
		&mem_ctx_obj,
		&level,
		&in_obj)) {
		return NULL;
	}
	mem_ctx = pytalloc_get_ptr(mem_ctx_obj);
	if (mem_ctx == NULL) {
		PyErr_SetString(PyExc_TypeError, "mem_ctx is NULL)!");
		return NULL;
	}
	in = (union bkup_StreamData *)pytalloc_get_ptr(in_obj);
	if (in == NULL) {
		PyErr_Format(PyExc_TypeError, "in needs to be a pointer to union bkup_StreamData!");
		return NULL;
	}

	return py_import_bkup_StreamData(mem_ctx, level, in);
}

static PyObject *py_bkup_StreamData_export(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	const char * const kwnames[] = { "mem_ctx", "level", "in", NULL };
	PyObject *mem_ctx_obj = NULL;
	TALLOC_CTX *mem_ctx = NULL;
	int level = 0;
	PyObject *in = NULL;
	union bkup_StreamData *out = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiO:import",
		discard_const_p(char *, kwnames),
		&mem_ctx_obj,
		&level,
		&in)) {
		return NULL;
	}
	mem_ctx = pytalloc_get_ptr(mem_ctx_obj);
	if (mem_ctx == NULL) {
		PyErr_SetString(PyExc_TypeError, "mem_ctx is NULL)!");
		return NULL;
	}

	out = py_export_bkup_StreamData(mem_ctx, level, in);
	if (out == NULL) {
		return NULL;
	}

	return pytalloc_GenericObject_reference(out);
}

static PyMethodDef py_bkup_StreamData_methods[] = {
	{ "__import__", (PyCFunction)py_bkup_StreamData_import,
		METH_VARARGS|METH_KEYWORDS|METH_CLASS,
		"T.__import__(mem_ctx, level, in) => ret." },
	{ "__export__", (PyCFunction)py_bkup_StreamData_export,
		METH_VARARGS|METH_KEYWORDS|METH_CLASS,
		"T.__export__(mem_ctx, level, in) => ret." },
	{ NULL, NULL, 0, NULL }
};

static PyObject *py_bkup_StreamData_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	PyErr_Format(PyExc_TypeError, "New %s Objects are not supported", type->tp_name);
	return NULL;
}


static PyTypeObject bkup_StreamData_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "bkupblobs.bkup_StreamData",
	.tp_getset = NULL,
	.tp_methods = py_bkup_StreamData_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_bkup_StreamData_new,
};


static PyObject *py_bkup_Win32StreamId_get_id(PyObject *obj, void *closure)
{
	struct bkup_Win32StreamId *object = (struct bkup_Win32StreamId *)pytalloc_get_ptr(obj);
	PyObject *py_id;
	py_id = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->id);
	return py_id;
}

static int py_bkup_Win32StreamId_set_id(PyObject *py_obj, PyObject *value, void *closure)
{
	struct bkup_Win32StreamId *object = (struct bkup_Win32StreamId *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->id");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->id));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->id = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->id = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_bkup_Win32StreamId_get_attribute(PyObject *obj, void *closure)
{
	struct bkup_Win32StreamId *object = (struct bkup_Win32StreamId *)pytalloc_get_ptr(obj);
	PyObject *py_attribute;
	py_attribute = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->attribute);
	return py_attribute;
}

static int py_bkup_Win32StreamId_set_attribute(PyObject *py_obj, PyObject *value, void *closure)
{
	struct bkup_Win32StreamId *object = (struct bkup_Win32StreamId *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->attribute");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->attribute));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->attribute = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->attribute = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_bkup_Win32StreamId_get_size(PyObject *obj, void *closure)
{
	struct bkup_Win32StreamId *object = (struct bkup_Win32StreamId *)pytalloc_get_ptr(obj);
	PyObject *py_size;
	py_size = ndr_PyLong_FromUnsignedLongLong(object->size);
	return py_size;
}

static int py_bkup_Win32StreamId_set_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct bkup_Win32StreamId *object = (struct bkup_Win32StreamId *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_bkup_Win32StreamId_get_stream_name_size(PyObject *obj, void *closure)
{
	struct bkup_Win32StreamId *object = (struct bkup_Win32StreamId *)pytalloc_get_ptr(obj);
	PyObject *py_stream_name_size;
	py_stream_name_size = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->stream_name_size);
	return py_stream_name_size;
}

static int py_bkup_Win32StreamId_set_stream_name_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct bkup_Win32StreamId *object = (struct bkup_Win32StreamId *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->stream_name_size");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->stream_name_size));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->stream_name_size = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->stream_name_size = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_bkup_Win32StreamId_get_stream_name(PyObject *obj, void *closure)
{
	struct bkup_Win32StreamId *object = (struct bkup_Win32StreamId *)pytalloc_get_ptr(obj);
	PyObject *py_stream_name;
	if (object->stream_name == NULL) {
		py_stream_name = Py_None;
		Py_INCREF(py_stream_name);
	} else {
		py_stream_name = PyUnicode_Decode(object->stream_name, strlen(object->stream_name), "utf-8", "ignore");
	}
	return py_stream_name;
}

static int py_bkup_Win32StreamId_set_stream_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct bkup_Win32StreamId *object = (struct bkup_Win32StreamId *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->stream_name");
		return -1;
	}
	{
		const char *test_str;
		const char *talloc_str;
		PyObject *unicode = NULL;
		if (PyUnicode_Check(value)) {
			unicode = PyUnicode_AsEncodedString(value, "utf-8", "ignore");
			if (unicode == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			test_str = PyBytes_AS_STRING(unicode);
		} else if (PyBytes_Check(value)) {
			test_str = PyBytes_AS_STRING(value);
		} else {
			PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
			return -1;
		}
		talloc_str = talloc_strdup(pytalloc_get_mem_ctx(py_obj), test_str);
		if (unicode != NULL) {
			Py_DECREF(unicode);
		}
		if (talloc_str == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->stream_name = talloc_str;
	}
	return 0;
}

static PyObject *py_bkup_Win32StreamId_get_data(PyObject *obj, void *closure)
{
	struct bkup_Win32StreamId *object = (struct bkup_Win32StreamId *)pytalloc_get_ptr(obj);
	PyObject *py_data;
	py_data = pyrpc_import_union(&bkup_StreamData_Type, pytalloc_get_mem_ctx(obj), object->id, &object->data, "union bkup_StreamData");
	if (py_data == NULL) {
		return NULL;
	}
	return py_data;
}

static int py_bkup_Win32StreamId_set_data(PyObject *py_obj, PyObject *value, void *closure)
{
	struct bkup_Win32StreamId *object = (struct bkup_Win32StreamId *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->data");
		return -1;
	}
	{
		union bkup_StreamData *data_switch_1;
		data_switch_1 = (union bkup_StreamData *)pyrpc_export_union(&bkup_StreamData_Type, pytalloc_get_mem_ctx(py_obj), object->id, value, "union bkup_StreamData");
		if (data_switch_1 == NULL) {
			return -1;
		}
		object->data = *data_switch_1;
	}
	return 0;
}

static PyGetSetDef py_bkup_Win32StreamId_getsetters[] = {
	{
		.name = discard_const_p(char, "id"),
		.get = py_bkup_Win32StreamId_get_id,
		.set = py_bkup_Win32StreamId_set_id,
		.doc = discard_const_p(char, "PIDL-generated element of base type bkup_StreamId")
	},
	{
		.name = discard_const_p(char, "attribute"),
		.get = py_bkup_Win32StreamId_get_attribute,
		.set = py_bkup_Win32StreamId_set_attribute,
		.doc = discard_const_p(char, "PIDL-generated element of base type bkup_StreamAttribute")
	},
	{
		.name = discard_const_p(char, "size"),
		.get = py_bkup_Win32StreamId_get_size,
		.set = py_bkup_Win32StreamId_set_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type hyper")
	},
	{
		.name = discard_const_p(char, "stream_name_size"),
		.get = py_bkup_Win32StreamId_get_stream_name_size,
		.set = py_bkup_Win32StreamId_set_stream_name_size,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "stream_name"),
		.get = py_bkup_Win32StreamId_get_stream_name,
		.set = py_bkup_Win32StreamId_set_stream_name,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint16")
	},
	{
		.name = discard_const_p(char, "data"),
		.get = py_bkup_Win32StreamId_get_data,
		.set = py_bkup_Win32StreamId_set_data,
		.doc = discard_const_p(char, "PIDL-generated element of base type bkup_StreamData")
	},
	{ .name = NULL }
};

static PyObject *py_bkup_Win32StreamId_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct bkup_Win32StreamId, type);
}

static PyObject *py_bkup_Win32StreamId_ndr_pack(PyObject *py_obj)
{
	struct bkup_Win32StreamId *object = (struct bkup_Win32StreamId *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_bkup_Win32StreamId);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_bkup_Win32StreamId_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct bkup_Win32StreamId *object = (struct bkup_Win32StreamId *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_bkup_Win32StreamId);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_bkup_Win32StreamId);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_bkup_Win32StreamId_ndr_print(PyObject *py_obj)
{
	struct bkup_Win32StreamId *object = (struct bkup_Win32StreamId *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_bkup_Win32StreamId, "bkup_Win32StreamId", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_bkup_Win32StreamId_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_bkup_Win32StreamId_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_bkup_Win32StreamId_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_bkup_Win32StreamId_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject bkup_Win32StreamId_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "bkupblobs.bkup_Win32StreamId",
	.tp_getset = py_bkup_Win32StreamId_getsetters,
	.tp_methods = py_bkup_Win32StreamId_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_bkup_Win32StreamId_new,
};


static PyObject *py_bkup_NTBackupFile_get_num_stream(PyObject *obj, void *closure)
{
	struct bkup_NTBackupFile *object = (struct bkup_NTBackupFile *)pytalloc_get_ptr(obj);
	PyObject *py_num_stream;
	py_num_stream = ndr_PyLong_FromUnsignedLongLong((uint32_t)object->num_stream);
	return py_num_stream;
}

static int py_bkup_NTBackupFile_set_num_stream(PyObject *py_obj, PyObject *value, void *closure)
{
	struct bkup_NTBackupFile *object = (struct bkup_NTBackupFile *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->num_stream");
		return -1;
	}
	{
		const unsigned long long uint_max = ndr_sizeof2uintmax(sizeof(object->num_stream));
		if (PyLong_Check(value)) {
			unsigned long long test_var;
			test_var = PyLong_AsUnsignedLongLong(value);
			if (PyErr_Occurred() != NULL) {
				return -1;
			}
			if (test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %llu",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->num_stream = test_var;
		} else if (PyInt_Check(value)) {
			long test_var;
			test_var = PyInt_AsLong(value);
			if (test_var < 0 || test_var > uint_max) {
				PyErr_Format(PyExc_OverflowError, "Expected type %s or %s within range 0 - %llu, got %ld",\
				  PyInt_Type.tp_name, PyLong_Type.tp_name, uint_max, test_var);
				return -1;
			}
			object->num_stream = test_var;
		} else {
			PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
			  PyInt_Type.tp_name, PyLong_Type.tp_name);
			return -1;
		}
	}
	return 0;
}

static PyObject *py_bkup_NTBackupFile_get_streams(PyObject *obj, void *closure)
{
	struct bkup_NTBackupFile *object = (struct bkup_NTBackupFile *)pytalloc_get_ptr(obj);
	PyObject *py_streams;
	py_streams = PyList_New(object->num_stream);
	if (py_streams == NULL) {
		return NULL;
	}
	{
		int streams_cntr_0;
		for (streams_cntr_0 = 0; streams_cntr_0 < (object->num_stream); streams_cntr_0++) {
			PyObject *py_streams_0;
			py_streams_0 = pytalloc_reference_ex(&bkup_Win32StreamId_Type, object->streams, &object->streams[streams_cntr_0]);
			PyList_SetItem(py_streams, streams_cntr_0, py_streams_0);
		}
	}
	return py_streams;
}

static int py_bkup_NTBackupFile_set_streams(PyObject *py_obj, PyObject *value, void *closure)
{
	struct bkup_NTBackupFile *object = (struct bkup_NTBackupFile *)pytalloc_get_ptr(py_obj);
	if (value == NULL) {
		PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->streams");
		return -1;
	}
	PY_CHECK_TYPE(&PyList_Type, value, return -1;);
	{
		int streams_cntr_0;
		object->streams = talloc_array_ptrtype(pytalloc_get_mem_ctx(py_obj), object->streams, PyList_GET_SIZE(value));
		if (!object->streams) { return -1;; }
		talloc_set_name_const(object->streams, "ARRAY: object->streams");
		for (streams_cntr_0 = 0; streams_cntr_0 < PyList_GET_SIZE(value); streams_cntr_0++) {
			if (PyList_GET_ITEM(value, streams_cntr_0) == NULL) {
				PyErr_Format(PyExc_AttributeError, "Cannot delete NDR object: struct object->streams[streams_cntr_0]");
				return -1;
			}
			PY_CHECK_TYPE(&bkup_Win32StreamId_Type, PyList_GET_ITEM(value, streams_cntr_0), return -1;);
			if (talloc_reference(object->streams, pytalloc_get_mem_ctx(PyList_GET_ITEM(value, streams_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->streams[streams_cntr_0] = *(struct bkup_Win32StreamId *)pytalloc_get_ptr(PyList_GET_ITEM(value, streams_cntr_0));
		}
	}
	return 0;
}

static PyGetSetDef py_bkup_NTBackupFile_getsetters[] = {
	{
		.name = discard_const_p(char, "num_stream"),
		.get = py_bkup_NTBackupFile_get_num_stream,
		.set = py_bkup_NTBackupFile_set_num_stream,
		.doc = discard_const_p(char, "PIDL-generated element of base type uint32")
	},
	{
		.name = discard_const_p(char, "streams"),
		.get = py_bkup_NTBackupFile_get_streams,
		.set = py_bkup_NTBackupFile_set_streams,
		.doc = discard_const_p(char, "PIDL-generated element of base type bkup_Win32StreamId")
	},
	{ .name = NULL }
};

static PyObject *py_bkup_NTBackupFile_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return pytalloc_new(struct bkup_NTBackupFile, type);
}

static PyObject *py_bkup_NTBackupFile_ndr_pack(PyObject *py_obj)
{
	struct bkup_NTBackupFile *object = (struct bkup_NTBackupFile *)pytalloc_get_ptr(py_obj);
	PyObject *ret = NULL;
	DATA_BLOB blob;
	enum ndr_err_code err;
	TALLOC_CTX *tmp_ctx = talloc_new(pytalloc_get_mem_ctx(py_obj));
	if (tmp_ctx == NULL) {
		PyErr_SetNdrError(NDR_ERR_ALLOC);
		return NULL;
	}
	err = ndr_push_struct_blob(&blob, tmp_ctx, object, (ndr_push_flags_fn_t)ndr_push_bkup_NTBackupFile);
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		TALLOC_FREE(tmp_ctx);
		PyErr_SetNdrError(err);
		return NULL;
	}

	ret = PyBytes_FromStringAndSize((char *)blob.data, blob.length);
	TALLOC_FREE(tmp_ctx);
	return ret;
}

static PyObject *py_bkup_NTBackupFile_ndr_unpack(PyObject *py_obj, PyObject *args, PyObject *kwargs)
{
	struct bkup_NTBackupFile *object = (struct bkup_NTBackupFile *)pytalloc_get_ptr(py_obj);
	DATA_BLOB blob;
	Py_ssize_t blob_length = 0;
	enum ndr_err_code err;
	const char * const kwnames[] = { "data_blob", "allow_remaining", NULL };
	PyObject *allow_remaining_obj = NULL;
	bool allow_remaining = false;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, PYARG_BYTES_LEN "|O:__ndr_unpack__",
		discard_const_p(char *, kwnames),
		&blob.data, &blob_length,
		&allow_remaining_obj)) {
		return NULL;
	}
	blob.length = blob_length;

	if (allow_remaining_obj && PyObject_IsTrue(allow_remaining_obj)) {
		allow_remaining = true;
	}

	if (allow_remaining) {
		err = ndr_pull_struct_blob(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_bkup_NTBackupFile);
	} else {
		err = ndr_pull_struct_blob_all(&blob, pytalloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_bkup_NTBackupFile);
	}
	if (!NDR_ERR_CODE_IS_SUCCESS(err)) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_bkup_NTBackupFile_ndr_print(PyObject *py_obj)
{
	struct bkup_NTBackupFile *object = (struct bkup_NTBackupFile *)pytalloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(pytalloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_bkup_NTBackupFile, "bkup_NTBackupFile", object);
	ret = PyStr_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_bkup_NTBackupFile_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_bkup_NTBackupFile_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_bkup_NTBackupFile_ndr_unpack, METH_VARARGS|METH_KEYWORDS, "S.ndr_unpack(class, blob, allow_remaining=False) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_bkup_NTBackupFile_ndr_print, METH_NOARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject bkup_NTBackupFile_Type = {
	PyVarObject_HEAD_INIT(NULL, 0)
	.tp_name = "bkupblobs.bkup_NTBackupFile",
	.tp_getset = py_bkup_NTBackupFile_getsetters,
	.tp_methods = py_bkup_NTBackupFile_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = py_bkup_NTBackupFile_new,
};

static PyMethodDef bkupblobs_methods[] = {
	{ NULL, NULL, 0, NULL }
};

static struct PyModuleDef moduledef = {
	PyModuleDef_HEAD_INIT,
	.m_name = "bkupblobs",
	.m_doc = "bkupblobs DCE/RPC",
	.m_size = -1,
	.m_methods = bkupblobs_methods,
};
MODULE_INIT_FUNC(bkupblobs)
{
	PyObject *m;
	PyObject *dep_samba_dcerpc_misc;
	PyObject *dep_samba_dcerpc_security;
	PyObject *dep_samba_dcerpc_fscc;
	PyObject *dep_talloc;

	dep_samba_dcerpc_misc = PyImport_ImportModule("samba.dcerpc.misc");
	if (dep_samba_dcerpc_misc == NULL)
		return NULL;

	dep_samba_dcerpc_security = PyImport_ImportModule("samba.dcerpc.security");
	if (dep_samba_dcerpc_security == NULL)
		return NULL;

	dep_samba_dcerpc_fscc = PyImport_ImportModule("samba.dcerpc.fscc");
	if (dep_samba_dcerpc_fscc == NULL)
		return NULL;

	dep_talloc = PyImport_ImportModule("talloc");
	if (dep_talloc == NULL)
		return NULL;

	security_descriptor_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_security, "descriptor");
	if (security_descriptor_Type == NULL)
		return NULL;

	fscc_FileObjectIdBuffer_2_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_fscc, "FileObjectIdBuffer_2");
	if (fscc_FileObjectIdBuffer_2_Type == NULL)
		return NULL;

	BaseObject_Type = (PyTypeObject *)PyObject_GetAttrString(dep_talloc, "BaseObject");
	if (BaseObject_Type == NULL)
		return NULL;

	bkup_StreamData_Type.tp_base = BaseObject_Type;
	bkup_StreamData_Type.tp_basicsize = pytalloc_BaseObject_size();

	bkup_Win32StreamId_Type.tp_base = BaseObject_Type;
	bkup_Win32StreamId_Type.tp_basicsize = pytalloc_BaseObject_size();

	bkup_NTBackupFile_Type.tp_base = BaseObject_Type;
	bkup_NTBackupFile_Type.tp_basicsize = pytalloc_BaseObject_size();

	if (PyType_Ready(&bkup_StreamData_Type) < 0)
		return NULL;
	if (PyType_Ready(&bkup_Win32StreamId_Type) < 0)
		return NULL;
	if (PyType_Ready(&bkup_NTBackupFile_Type) < 0)
		return NULL;
#ifdef PY_BKUP_STREAMDATA_PATCH
	PY_BKUP_STREAMDATA_PATCH(&bkup_StreamData_Type);
#endif
#ifdef PY_BKUP_WIN32STREAMID_PATCH
	PY_BKUP_WIN32STREAMID_PATCH(&bkup_Win32StreamId_Type);
#endif
#ifdef PY_BKUP_NTBACKUPFILE_PATCH
	PY_BKUP_NTBACKUPFILE_PATCH(&bkup_NTBackupFile_Type);
#endif

	m = PyModule_Create(&moduledef);
	if (m == NULL)
		return NULL;

	PyModule_AddObject(m, "STREAM_ID_DATA", ndr_PyLong_FromUnsignedLongLong((uint32_t)STREAM_ID_DATA));
	PyModule_AddObject(m, "STREAM_ID_EX_DATA", ndr_PyLong_FromUnsignedLongLong((uint32_t)STREAM_ID_EX_DATA));
	PyModule_AddObject(m, "STREAM_ID_SECURITY_DATA", ndr_PyLong_FromUnsignedLongLong((uint32_t)STREAM_ID_SECURITY_DATA));
	PyModule_AddObject(m, "STREAM_ID_ALTERNATE_DATA", ndr_PyLong_FromUnsignedLongLong((uint32_t)STREAM_ID_ALTERNATE_DATA));
	PyModule_AddObject(m, "STREAM_ID_LINK", ndr_PyLong_FromUnsignedLongLong((uint32_t)STREAM_ID_LINK));
	PyModule_AddObject(m, "STREAM_ID_OBJECTID", ndr_PyLong_FromUnsignedLongLong((uint32_t)STREAM_ID_OBJECTID));
	PyModule_AddObject(m, "STREAM_ID_REPARSE_DATA", ndr_PyLong_FromUnsignedLongLong((uint32_t)STREAM_ID_REPARSE_DATA));
	PyModule_AddObject(m, "STREAM_ID_SPARSE_BLOCK", ndr_PyLong_FromUnsignedLongLong((uint32_t)STREAM_ID_SPARSE_BLOCK));
	PyModule_AddObject(m, "STREAM_ID_TXFS_DATA", ndr_PyLong_FromUnsignedLongLong((uint32_t)STREAM_ID_TXFS_DATA));
	PyModule_AddObject(m, "STREAM_ATTRIBUTE_NORMAL", ndr_PyLong_FromUnsignedLongLong((uint32_t)STREAM_ATTRIBUTE_NORMAL));
	PyModule_AddObject(m, "STREAM_ATTRIBUTE_SECURITY", ndr_PyLong_FromUnsignedLongLong((uint32_t)STREAM_ATTRIBUTE_SECURITY));
	PyModule_AddObject(m, "STREAM_ATTRIBUTE_SPARSE", ndr_PyLong_FromUnsignedLongLong((uint32_t)STREAM_ATTRIBUTE_SPARSE));
	Py_INCREF((PyObject *)(void *)&bkup_StreamData_Type);
	PyModule_AddObject(m, "bkup_StreamData", (PyObject *)(void *)&bkup_StreamData_Type);
	Py_INCREF((PyObject *)(void *)&bkup_Win32StreamId_Type);
	PyModule_AddObject(m, "bkup_Win32StreamId", (PyObject *)(void *)&bkup_Win32StreamId_Type);
	Py_INCREF((PyObject *)(void *)&bkup_NTBackupFile_Type);
	PyModule_AddObject(m, "bkup_NTBackupFile", (PyObject *)(void *)&bkup_NTBackupFile_Type);
#ifdef PY_MOD_BKUPBLOBS_PATCH
	PY_MOD_BKUPBLOBS_PATCH(m);
#endif
	return m;

}
