/* parser auto-generated by pidl */

#include "includes.h"
#include "bin/default/librpc/gen_ndr/ndr_ioctl.h"

_PUBLIC_ enum ndr_err_code ndr_push_req_resume_key_rsp(struct ndr_push *ndr, int ndr_flags, const struct req_resume_key_rsp *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->resume_key, 24));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->context_len));
		NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->context, 4));
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_req_resume_key_rsp(struct ndr_pull *ndr, int ndr_flags, struct req_resume_key_rsp *r)
{
	uint32_t size_resume_key_0 = 0;
	uint32_t size_context_0 = 0;
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		size_resume_key_0 = 24;
		NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->resume_key, size_resume_key_0));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->context_len));
		size_context_0 = 4;
		NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->context, size_context_0));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_req_resume_key_rsp(struct ndr_print *ndr, const char *name, const struct req_resume_key_rsp *r)
{
	ndr_print_struct(ndr, name, "req_resume_key_rsp");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_array_uint8(ndr, "resume_key", r->resume_key, 24);
	ndr_print_uint32(ndr, "context_len", r->context_len);
	ndr_print_array_uint8(ndr, "context", r->context, 4);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_srv_copychunk(struct ndr_push *ndr, int ndr_flags, const struct srv_copychunk *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->source_off));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->target_off));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->length));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_srv_copychunk(struct ndr_pull *ndr, int ndr_flags, struct srv_copychunk *r)
{
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->source_off));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->target_off));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->length));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_srv_copychunk(struct ndr_print *ndr, const char *name, const struct srv_copychunk *r)
{
	ndr_print_struct(ndr, name, "srv_copychunk");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_hyper(ndr, "source_off", r->source_off);
	ndr_print_hyper(ndr, "target_off", r->target_off);
	ndr_print_uint32(ndr, "length", r->length);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_srv_copychunk_copy(struct ndr_push *ndr, int ndr_flags, const struct srv_copychunk_copy *r)
{
	uint32_t cntr_chunks_0;
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->source_key, 24));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->chunk_count));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		for (cntr_chunks_0 = 0; cntr_chunks_0 < (r->chunk_count); cntr_chunks_0++) {
			NDR_CHECK(ndr_push_srv_copychunk(ndr, NDR_SCALARS, &r->chunks[cntr_chunks_0]));
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_srv_copychunk_copy(struct ndr_pull *ndr, int ndr_flags, struct srv_copychunk_copy *r)
{
	uint32_t size_source_key_0 = 0;
	uint32_t size_chunks_0 = 0;
	uint32_t cntr_chunks_0;
	TALLOC_CTX *_mem_save_chunks_0 = NULL;
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		size_source_key_0 = 24;
		NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->source_key, size_source_key_0));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->chunk_count));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		size_chunks_0 = r->chunk_count;
		NDR_PULL_ALLOC_N(ndr, r->chunks, size_chunks_0);
		_mem_save_chunks_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->chunks, 0);
		for (cntr_chunks_0 = 0; cntr_chunks_0 < (size_chunks_0); cntr_chunks_0++) {
			NDR_CHECK(ndr_pull_srv_copychunk(ndr, NDR_SCALARS, &r->chunks[cntr_chunks_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_chunks_0, 0);
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_srv_copychunk_copy(struct ndr_print *ndr, const char *name, const struct srv_copychunk_copy *r)
{
	uint32_t cntr_chunks_0;
	ndr_print_struct(ndr, name, "srv_copychunk_copy");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_array_uint8(ndr, "source_key", r->source_key, 24);
	ndr_print_uint32(ndr, "chunk_count", r->chunk_count);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr->print(ndr, "%s: ARRAY(%d)", "chunks", (int)r->chunk_count);
	ndr->depth++;
	for (cntr_chunks_0 = 0; cntr_chunks_0 < (r->chunk_count); cntr_chunks_0++) {
		ndr_print_srv_copychunk(ndr, "chunks", &r->chunks[cntr_chunks_0]);
	}
	ndr->depth--;
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_srv_copychunk_rsp(struct ndr_push *ndr, int ndr_flags, const struct srv_copychunk_rsp *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->chunks_written));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->chunk_bytes_written));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->total_bytes_written));
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_srv_copychunk_rsp(struct ndr_pull *ndr, int ndr_flags, struct srv_copychunk_rsp *r)
{
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->chunks_written));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->chunk_bytes_written));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->total_bytes_written));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_srv_copychunk_rsp(struct ndr_print *ndr, const char *name, const struct srv_copychunk_rsp *r)
{
	ndr_print_struct(ndr, name, "srv_copychunk_rsp");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "chunks_written", r->chunks_written);
	ndr_print_uint32(ndr, "chunk_bytes_written", r->chunk_bytes_written);
	ndr_print_uint32(ndr, "total_bytes_written", r->total_bytes_written);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_device_copy_offload_descriptor(struct ndr_push *ndr, int ndr_flags, const struct device_copy_offload_descriptor *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->size));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->maximum_token_lifetime));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->default_token_lifetime));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->maximum_xfer_size));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->optimal_xfer_count));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->maximum_data_descriptors));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->maximum_xfer_length_per_descriptor));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->optimal_xfer_length_per_descriptor));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->optimal_xfer_length_granularity));
		NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->reserved, 2));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_device_copy_offload_descriptor(struct ndr_pull *ndr, int ndr_flags, struct device_copy_offload_descriptor *r)
{
	uint32_t size_reserved_0 = 0;
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->size));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->maximum_token_lifetime));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->default_token_lifetime));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->maximum_xfer_size));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->optimal_xfer_count));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->maximum_data_descriptors));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->maximum_xfer_length_per_descriptor));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->optimal_xfer_length_per_descriptor));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->optimal_xfer_length_granularity));
		size_reserved_0 = 2;
		NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->reserved, size_reserved_0));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_device_copy_offload_descriptor(struct ndr_print *ndr, const char *name, const struct device_copy_offload_descriptor *r)
{
	ndr_print_struct(ndr, name, "device_copy_offload_descriptor");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "version", r->version);
	ndr_print_uint32(ndr, "size", r->size);
	ndr_print_uint32(ndr, "maximum_token_lifetime", r->maximum_token_lifetime);
	ndr_print_uint32(ndr, "default_token_lifetime", r->default_token_lifetime);
	ndr_print_hyper(ndr, "maximum_xfer_size", r->maximum_xfer_size);
	ndr_print_hyper(ndr, "optimal_xfer_count", r->optimal_xfer_count);
	ndr_print_uint32(ndr, "maximum_data_descriptors", r->maximum_data_descriptors);
	ndr_print_uint32(ndr, "maximum_xfer_length_per_descriptor", r->maximum_xfer_length_per_descriptor);
	ndr_print_uint32(ndr, "optimal_xfer_length_per_descriptor", r->optimal_xfer_length_per_descriptor);
	ndr_print_uint16(ndr, "optimal_xfer_length_granularity", r->optimal_xfer_length_granularity);
	ndr_print_array_uint8(ndr, "reserved", r->reserved, 2);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_storage_offload_token(struct ndr_push *ndr, int ndr_flags, const struct storage_offload_token *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, r->token_id_len));
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->token_type));
		NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->reserved, 2));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->token_id_len));
		NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->token, r->token_id_len));
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_storage_offload_token(struct ndr_pull *ndr, int ndr_flags, struct storage_offload_token *r)
{
	uint32_t size_reserved_0 = 0;
	uint32_t size_token_0 = 0;
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_array_size(ndr, &r->token));
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->token_type));
		size_reserved_0 = 2;
		NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->reserved, size_reserved_0));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->token_id_len));
		size_token_0 = ndr_get_array_size(ndr, &r->token);
		NDR_PULL_ALLOC_N(ndr, r->token, size_token_0);
		NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->token, size_token_0));
		if (r->token) {
			NDR_CHECK(ndr_check_array_size(ndr, (void*)&r->token, r->token_id_len));
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_storage_offload_token(struct ndr_print *ndr, const char *name, const struct storage_offload_token *r)
{
	ndr_print_struct(ndr, name, "storage_offload_token");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "token_type", r->token_type);
	ndr_print_array_uint8(ndr, "reserved", r->reserved, 2);
	ndr_print_uint16(ndr, "token_id_len", r->token_id_len);
	ndr_print_array_uint8(ndr, "token", r->token, r->token_id_len);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_fsctl_offload_read_input(struct ndr_push *ndr, int ndr_flags, const struct fsctl_offload_read_input *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->size));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->flags));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->token_time_to_live));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->file_offset));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->length));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_fsctl_offload_read_input(struct ndr_pull *ndr, int ndr_flags, struct fsctl_offload_read_input *r)
{
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->size));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->flags));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->token_time_to_live));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->file_offset));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->length));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_fsctl_offload_read_input(struct ndr_print *ndr, const char *name, const struct fsctl_offload_read_input *r)
{
	ndr_print_struct(ndr, name, "fsctl_offload_read_input");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "size", r->size);
	ndr_print_uint32(ndr, "flags", r->flags);
	ndr_print_uint32(ndr, "token_time_to_live", r->token_time_to_live);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr_print_hyper(ndr, "file_offset", r->file_offset);
	ndr_print_hyper(ndr, "length", r->length);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_offload_flags(struct ndr_push *ndr, int ndr_flags, uint32_t r)
{
	NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r));
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_offload_flags(struct ndr_pull *ndr, int ndr_flags, uint32_t *r)
{
	uint32_t v;
	NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &v));
	*r = v;
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_offload_flags(struct ndr_print *ndr, const char *name, uint32_t r)
{
	ndr_print_uint32(ndr, name, r);
	ndr->depth++;
	ndr_print_bitmap_flag(ndr, sizeof(uint32_t), "OFFLOAD_READ_FLAG_FILE_TOO_SMALL", OFFLOAD_READ_FLAG_FILE_TOO_SMALL, r);
	ndr_print_bitmap_flag(ndr, sizeof(uint32_t), "OFFLOAD_READ_FLAG_ALL_ZERO_BEYOND_RANGE", OFFLOAD_READ_FLAG_ALL_ZERO_BEYOND_RANGE, r);
	ndr_print_bitmap_flag(ndr, sizeof(uint32_t), "OFFLOAD_READ_FLAG_CANNOT_OFFLOAD_BEYOND_RANGE", OFFLOAD_READ_FLAG_CANNOT_OFFLOAD_BEYOND_RANGE, r);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_fsctl_offload_read_output(struct ndr_push *ndr, int ndr_flags, const struct fsctl_offload_read_output *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->size));
		NDR_CHECK(ndr_push_offload_flags(ndr, NDR_SCALARS, r->flags));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->xfer_length));
		NDR_CHECK(ndr_push_storage_offload_token(ndr, NDR_SCALARS, &r->token));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_fsctl_offload_read_output(struct ndr_pull *ndr, int ndr_flags, struct fsctl_offload_read_output *r)
{
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->size));
		NDR_CHECK(ndr_pull_offload_flags(ndr, NDR_SCALARS, &r->flags));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->xfer_length));
		NDR_CHECK(ndr_pull_storage_offload_token(ndr, NDR_SCALARS, &r->token));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_fsctl_offload_read_output(struct ndr_print *ndr, const char *name, const struct fsctl_offload_read_output *r)
{
	ndr_print_struct(ndr, name, "fsctl_offload_read_output");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "size", r->size);
	ndr_print_offload_flags(ndr, "flags", r->flags);
	ndr_print_hyper(ndr, "xfer_length", r->xfer_length);
	ndr_print_storage_offload_token(ndr, "token", &r->token);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_fsctl_offload_write_input(struct ndr_push *ndr, int ndr_flags, const struct fsctl_offload_write_input *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->size));
		NDR_CHECK(ndr_push_offload_flags(ndr, NDR_SCALARS, r->flags));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->file_offset));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->copy_length));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->xfer_offset));
		NDR_CHECK(ndr_push_storage_offload_token(ndr, NDR_SCALARS, &r->token));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_fsctl_offload_write_input(struct ndr_pull *ndr, int ndr_flags, struct fsctl_offload_write_input *r)
{
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->size));
		NDR_CHECK(ndr_pull_offload_flags(ndr, NDR_SCALARS, &r->flags));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->file_offset));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->copy_length));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->xfer_offset));
		NDR_CHECK(ndr_pull_storage_offload_token(ndr, NDR_SCALARS, &r->token));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_fsctl_offload_write_input(struct ndr_print *ndr, const char *name, const struct fsctl_offload_write_input *r)
{
	ndr_print_struct(ndr, name, "fsctl_offload_write_input");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "size", r->size);
	ndr_print_offload_flags(ndr, "flags", r->flags);
	ndr_print_hyper(ndr, "file_offset", r->file_offset);
	ndr_print_hyper(ndr, "copy_length", r->copy_length);
	ndr_print_hyper(ndr, "xfer_offset", r->xfer_offset);
	ndr_print_storage_offload_token(ndr, "token", &r->token);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_fsctl_offload_write_output(struct ndr_push *ndr, int ndr_flags, const struct fsctl_offload_write_output *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->size));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->flags));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->length_written));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_fsctl_offload_write_output(struct ndr_pull *ndr, int ndr_flags, struct fsctl_offload_write_output *r)
{
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->size));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->flags));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->length_written));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_fsctl_offload_write_output(struct ndr_print *ndr, const char *name, const struct fsctl_offload_write_output *r)
{
	ndr_print_struct(ndr, name, "fsctl_offload_write_output");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "size", r->size);
	ndr_print_uint32(ndr, "flags", r->flags);
	ndr_print_hyper(ndr, "length_written", r->length_written);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_fsctl_dup_extents_to_file(struct ndr_push *ndr, int ndr_flags, const struct fsctl_dup_extents_to_file *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->source_fid, 16));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->source_off));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->target_off));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->byte_count));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_fsctl_dup_extents_to_file(struct ndr_pull *ndr, int ndr_flags, struct fsctl_dup_extents_to_file *r)
{
	uint32_t size_source_fid_0 = 0;
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		size_source_fid_0 = 16;
		NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->source_fid, size_source_fid_0));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->source_off));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->target_off));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->byte_count));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_fsctl_dup_extents_to_file(struct ndr_print *ndr, const char *name, const struct fsctl_dup_extents_to_file *r)
{
	ndr_print_struct(ndr, name, "fsctl_dup_extents_to_file");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_array_uint8(ndr, "source_fid", r->source_fid, 16);
	ndr_print_hyper(ndr, "source_off", r->source_off);
	ndr_print_hyper(ndr, "target_off", r->target_off);
	ndr_print_hyper(ndr, "byte_count", r->byte_count);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_compression_state(struct ndr_push *ndr, int ndr_flags, const struct compression_state *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 2));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->format));
		NDR_CHECK(ndr_push_trailer_align(ndr, 2));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_compression_state(struct ndr_pull *ndr, int ndr_flags, struct compression_state *r)
{
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 2));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->format));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 2));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_compression_state(struct ndr_print *ndr, const char *name, const struct compression_state *r)
{
	ndr_print_struct(ndr, name, "compression_state");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint16(ndr, "format", r->format);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_fsctl_net_iface_capability(struct ndr_push *ndr, int ndr_flags, uint32_t r)
{
	NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r));
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_fsctl_net_iface_capability(struct ndr_pull *ndr, int ndr_flags, uint32_t *r)
{
	uint32_t v;
	NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &v));
	*r = v;
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_fsctl_net_iface_capability(struct ndr_print *ndr, const char *name, uint32_t r)
{
	ndr_print_uint32(ndr, name, r);
	ndr->depth++;
	ndr_print_bitmap_flag(ndr, sizeof(uint32_t), "FSCTL_NET_IFACE_NONE_CAPABLE", FSCTL_NET_IFACE_NONE_CAPABLE, r);
	ndr_print_bitmap_flag(ndr, sizeof(uint32_t), "FSCTL_NET_IFACE_RSS_CAPABLE", FSCTL_NET_IFACE_RSS_CAPABLE, r);
	ndr_print_bitmap_flag(ndr, sizeof(uint32_t), "FSCTL_NET_IFACE_RDMA_CAPABLE", FSCTL_NET_IFACE_RDMA_CAPABLE, r);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_fsctl_sockaddr_af(struct ndr_push *ndr, int ndr_flags, enum fsctl_sockaddr_af r)
{
	NDR_CHECK(ndr_push_enum_uint16(ndr, NDR_SCALARS, r));
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_fsctl_sockaddr_af(struct ndr_pull *ndr, int ndr_flags, enum fsctl_sockaddr_af *r)
{
	uint16_t v;
	NDR_CHECK(ndr_pull_enum_uint16(ndr, NDR_SCALARS, &v));
	*r = v;
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_fsctl_sockaddr_af(struct ndr_print *ndr, const char *name, enum fsctl_sockaddr_af r)
{
	const char *val = NULL;

	switch (r) {
		case FSCTL_NET_IFACE_AF_INET: val = "FSCTL_NET_IFACE_AF_INET"; break;
		case FSCTL_NET_IFACE_AF_INET6: val = "FSCTL_NET_IFACE_AF_INET6"; break;
	}
	ndr_print_enum(ndr, name, "ENUM", val, r);
}

static enum ndr_err_code ndr_push_fsctl_sockaddr_in(struct ndr_push *ndr, int ndr_flags, const struct fsctl_sockaddr_in *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_push_align(ndr, 8));
			NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 0));
			{
				uint32_t _flags_save_ipv4address = ndr->flags;
				ndr_set_flags(&ndr->flags, LIBNDR_FLAG_BIGENDIAN);
				NDR_CHECK(ndr_push_ipv4address(ndr, NDR_SCALARS, r->ipv4));
				ndr->flags = _flags_save_ipv4address;
			}
			NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, 0));
			NDR_CHECK(ndr_push_trailer_align(ndr, 8));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_fsctl_sockaddr_in(struct ndr_pull *ndr, int ndr_flags, struct fsctl_sockaddr_in *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_pull_align(ndr, 8));
			NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->port));
			{
				uint32_t _flags_save_ipv4address = ndr->flags;
				ndr_set_flags(&ndr->flags, LIBNDR_FLAG_BIGENDIAN);
				NDR_CHECK(ndr_pull_ipv4address(ndr, NDR_SCALARS, &r->ipv4));
				ndr->flags = _flags_save_ipv4address;
			}
			NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->reserved));
			NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_fsctl_sockaddr_in(struct ndr_print *ndr, const char *name, const struct fsctl_sockaddr_in *r)
{
	ndr_print_struct(ndr, name, "fsctl_sockaddr_in");
	if (r == NULL) { ndr_print_null(ndr); return; }
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		ndr->depth++;
		ndr_print_uint16(ndr, "port", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->port);
		{
			uint32_t _flags_save_ipv4address = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_BIGENDIAN);
			ndr_print_ipv4address(ndr, "ipv4", r->ipv4);
			ndr->flags = _flags_save_ipv4address;
		}
		ndr_print_hyper(ndr, "reserved", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved);
		ndr->depth--;
		ndr->flags = _flags_save_STRUCT;
	}
}

static enum ndr_err_code ndr_push_fsctl_sockaddr_in6(struct ndr_push *ndr, int ndr_flags, const struct fsctl_sockaddr_in6 *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_push_align(ndr, 4));
			NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 0));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
			{
				uint32_t _flags_save_ipv6address = ndr->flags;
				ndr_set_flags(&ndr->flags, LIBNDR_FLAG_BIGENDIAN);
				NDR_CHECK(ndr_push_ipv6address(ndr, NDR_SCALARS, r->ipv6));
				ndr->flags = _flags_save_ipv6address;
			}
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
			NDR_CHECK(ndr_push_trailer_align(ndr, 4));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_fsctl_sockaddr_in6(struct ndr_pull *ndr, int ndr_flags, struct fsctl_sockaddr_in6 *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_pull_align(ndr, 4));
			NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->port));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->flowinfo));
			{
				uint32_t _flags_save_ipv6address = ndr->flags;
				ndr_set_flags(&ndr->flags, LIBNDR_FLAG_BIGENDIAN);
				NDR_CHECK(ndr_pull_ipv6address(ndr, NDR_SCALARS, &r->ipv6));
				ndr->flags = _flags_save_ipv6address;
			}
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->scopeid));
			NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_fsctl_sockaddr_in6(struct ndr_print *ndr, const char *name, const struct fsctl_sockaddr_in6 *r)
{
	ndr_print_struct(ndr, name, "fsctl_sockaddr_in6");
	if (r == NULL) { ndr_print_null(ndr); return; }
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		ndr->depth++;
		ndr_print_uint16(ndr, "port", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->port);
		ndr_print_uint32(ndr, "flowinfo", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->flowinfo);
		{
			uint32_t _flags_save_ipv6address = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_BIGENDIAN);
			ndr_print_ipv6address(ndr, "ipv6", r->ipv6);
			ndr->flags = _flags_save_ipv6address;
		}
		ndr_print_uint32(ndr, "scopeid", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->scopeid);
		ndr->depth--;
		ndr->flags = _flags_save_STRUCT;
	}
}

static enum ndr_err_code ndr_push_fsctl_sockaddr_union(struct ndr_push *ndr, int ndr_flags, const union fsctl_sockaddr_union *r)
{
	{
		uint32_t _flags_save_UNION = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
		if (ndr_flags & NDR_SCALARS) {
			uint32_t level = ndr_push_get_switch_value(ndr, r);
			NDR_CHECK(ndr_push_union_align(ndr, 8));
			switch (level) {
				case FSCTL_NET_IFACE_AF_INET: {
					NDR_CHECK(ndr_push_fsctl_sockaddr_in(ndr, NDR_SCALARS, &r->saddr_in));
				break; }

				case FSCTL_NET_IFACE_AF_INET6: {
					NDR_CHECK(ndr_push_fsctl_sockaddr_in6(ndr, NDR_SCALARS, &r->saddr_in6));
				break; }

				default:
					return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
			}
		}
		if (ndr_flags & NDR_BUFFERS) {
			uint32_t level = ndr_push_get_switch_value(ndr, r);
			switch (level) {
				case FSCTL_NET_IFACE_AF_INET:
				break;

				case FSCTL_NET_IFACE_AF_INET6:
				break;

				default:
					return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
			}
		}
		ndr->flags = _flags_save_UNION;
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_fsctl_sockaddr_union(struct ndr_pull *ndr, int ndr_flags, union fsctl_sockaddr_union *r)
{
	uint32_t level;
	{
		uint32_t _flags_save_UNION = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
		if (ndr_flags & NDR_SCALARS) {
			level = ndr_pull_get_switch_value(ndr, r);
			NDR_CHECK(ndr_pull_union_align(ndr, 8));
			switch (level) {
				case FSCTL_NET_IFACE_AF_INET: {
					NDR_CHECK(ndr_pull_fsctl_sockaddr_in(ndr, NDR_SCALARS, &r->saddr_in));
				break; }

				case FSCTL_NET_IFACE_AF_INET6: {
					NDR_CHECK(ndr_pull_fsctl_sockaddr_in6(ndr, NDR_SCALARS, &r->saddr_in6));
				break; }

				default:
					return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
			}
		}
		if (ndr_flags & NDR_BUFFERS) {
			/* The token is not needed after this. */
			level = ndr_pull_steal_switch_value(ndr, r);
			switch (level) {
				case FSCTL_NET_IFACE_AF_INET:
				break;

				case FSCTL_NET_IFACE_AF_INET6:
				break;

				default:
					return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
			}
		}
		ndr->flags = _flags_save_UNION;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_fsctl_sockaddr_union(struct ndr_print *ndr, const char *name, const union fsctl_sockaddr_union *r)
{
	uint32_t level;
	{
		uint32_t _flags_save_UNION = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		level = ndr_print_get_switch_value(ndr, r);
		ndr_print_union(ndr, name, level, "fsctl_sockaddr_union");
		switch (level) {
			case FSCTL_NET_IFACE_AF_INET:
				ndr_print_fsctl_sockaddr_in(ndr, "saddr_in", &r->saddr_in);
			break;

			case FSCTL_NET_IFACE_AF_INET6:
				ndr_print_fsctl_sockaddr_in6(ndr, "saddr_in6", &r->saddr_in6);
			break;

			default:
				ndr_print_bad_level(ndr, name, level);
		}
		ndr->flags = _flags_save_UNION;
	}
}

static enum ndr_err_code ndr_push_fsctl_sockaddr_storage(struct ndr_push *ndr, int ndr_flags, const struct fsctl_sockaddr_storage *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_push_align(ndr, 8));
			NDR_CHECK(ndr_push_fsctl_sockaddr_af(ndr, NDR_SCALARS, r->family));
			{
				struct ndr_push *_ndr_saddr;
				NDR_CHECK(ndr_push_subcontext_start(ndr, &_ndr_saddr, 0, 126));
				NDR_CHECK(ndr_push_set_switch_value(_ndr_saddr, &r->saddr, r->family));
				NDR_CHECK(ndr_push_fsctl_sockaddr_union(_ndr_saddr, NDR_SCALARS, &r->saddr));
				NDR_CHECK(ndr_push_subcontext_end(ndr, _ndr_saddr, 0, 126));
			}
			NDR_CHECK(ndr_push_trailer_align(ndr, 8));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_fsctl_sockaddr_storage(struct ndr_pull *ndr, int ndr_flags, struct fsctl_sockaddr_storage *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_pull_align(ndr, 8));
			NDR_CHECK(ndr_pull_fsctl_sockaddr_af(ndr, NDR_SCALARS, &r->family));
			{
				struct ndr_pull *_ndr_saddr;
				NDR_CHECK(ndr_pull_subcontext_start(ndr, &_ndr_saddr, 0, 126));
				NDR_CHECK(ndr_pull_set_switch_value(_ndr_saddr, &r->saddr, r->family));
				NDR_CHECK(ndr_pull_fsctl_sockaddr_union(_ndr_saddr, NDR_SCALARS, &r->saddr));
				NDR_CHECK(ndr_pull_subcontext_end(ndr, _ndr_saddr, 0, 126));
			}
			NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_fsctl_sockaddr_storage(struct ndr_print *ndr, const char *name, const struct fsctl_sockaddr_storage *r)
{
	ndr_print_struct(ndr, name, "fsctl_sockaddr_storage");
	if (r == NULL) { ndr_print_null(ndr); return; }
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		ndr->depth++;
		ndr_print_fsctl_sockaddr_af(ndr, "family", r->family);
		ndr_print_set_switch_value(ndr, &r->saddr, r->family);
		ndr_print_fsctl_sockaddr_union(ndr, "saddr", &r->saddr);
		ndr->depth--;
		ndr->flags = _flags_save_STRUCT;
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_fsctl_net_iface_info(struct ndr_push *ndr, int ndr_flags, const struct fsctl_net_iface_info *r)
{
	uint32_t _save_relative_base_offset = ndr_push_get_relative_base_offset(ndr);
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_setup_relative_base_offset1(ndr, r, ndr->offset));
		NDR_CHECK(ndr_push_relative_ptr1(ndr, r->next));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->ifindex));
		NDR_CHECK(ndr_push_fsctl_net_iface_capability(ndr, NDR_SCALARS, r->capability));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->linkspeed));
		NDR_CHECK(ndr_push_fsctl_sockaddr_storage(ndr, NDR_SCALARS, &r->sockaddr));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_setup_relative_base_offset2(ndr, r));
		if (r->next) {
			NDR_CHECK(ndr_push_relative_ptr2_start(ndr, r->next));
			NDR_CHECK(ndr_push_fsctl_net_iface_info(ndr, NDR_SCALARS|NDR_BUFFERS, r->next));
			NDR_CHECK(ndr_push_relative_ptr2_end(ndr, r->next));
		}
	}
	ndr_push_restore_relative_base_offset(ndr, _save_relative_base_offset);
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_fsctl_net_iface_info(struct ndr_pull *ndr, int ndr_flags, struct fsctl_net_iface_info *r)
{
	uint32_t _save_relative_base_offset = ndr_pull_get_relative_base_offset(ndr);
	uint32_t _ptr_next;
	TALLOC_CTX *_mem_save_next_0 = NULL;
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_setup_relative_base_offset1(ndr, r, ndr->offset));
		NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_next));
		if (_ptr_next) {
			NDR_PULL_ALLOC(ndr, r->next);
			NDR_CHECK(ndr_pull_relative_ptr1(ndr, r->next, _ptr_next));
		} else {
			r->next = NULL;
		}
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->ifindex));
		NDR_CHECK(ndr_pull_fsctl_net_iface_capability(ndr, NDR_SCALARS, &r->capability));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->linkspeed));
		NDR_CHECK(ndr_pull_fsctl_sockaddr_storage(ndr, NDR_SCALARS, &r->sockaddr));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_setup_relative_base_offset2(ndr, r));
		if (r->next) {
			uint32_t _relative_save_offset;
			_relative_save_offset = ndr->offset;
			NDR_CHECK(ndr_pull_relative_ptr2(ndr, r->next));
			_mem_save_next_0 = NDR_PULL_GET_MEM_CTX(ndr);
			NDR_PULL_SET_MEM_CTX(ndr, r->next, 0);
			NDR_CHECK(ndr_pull_fsctl_net_iface_info(ndr, NDR_SCALARS|NDR_BUFFERS, r->next));
			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_next_0, 0);
			if (ndr->offset > ndr->relative_highest_offset) {
				ndr->relative_highest_offset = ndr->offset;
			}
			ndr->offset = _relative_save_offset;
		}
	}
	ndr_pull_restore_relative_base_offset(ndr, _save_relative_base_offset);
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_push_file_alloced_range_buf(struct ndr_push *ndr, int ndr_flags, const struct file_alloced_range_buf *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->file_off));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->len));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_file_alloced_range_buf(struct ndr_pull *ndr, int ndr_flags, struct file_alloced_range_buf *r)
{
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->file_off));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->len));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_file_alloced_range_buf(struct ndr_print *ndr, const char *name, const struct file_alloced_range_buf *r)
{
	ndr_print_struct(ndr, name, "file_alloced_range_buf");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_hyper(ndr, "file_off", r->file_off);
	ndr_print_hyper(ndr, "len", r->len);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_fsctl_query_alloced_ranges_req(struct ndr_push *ndr, int ndr_flags, const struct fsctl_query_alloced_ranges_req *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_file_alloced_range_buf(ndr, NDR_SCALARS, &r->buf));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_fsctl_query_alloced_ranges_req(struct ndr_pull *ndr, int ndr_flags, struct fsctl_query_alloced_ranges_req *r)
{
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_file_alloced_range_buf(ndr, NDR_SCALARS, &r->buf));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_fsctl_query_alloced_ranges_req(struct ndr_print *ndr, const char *name, const struct fsctl_query_alloced_ranges_req *r)
{
	ndr_print_struct(ndr, name, "fsctl_query_alloced_ranges_req");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_file_alloced_range_buf(ndr, "buf", &r->buf);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_fsctl_query_alloced_ranges_rsp(struct ndr_push *ndr, int ndr_flags, const struct fsctl_query_alloced_ranges_rsp *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_push_DATA_BLOB(ndr, NDR_SCALARS, r->far_buf_array));
			ndr->flags = _flags_save_DATA_BLOB;
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_fsctl_query_alloced_ranges_rsp(struct ndr_pull *ndr, int ndr_flags, struct fsctl_query_alloced_ranges_rsp *r)
{
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_pull_DATA_BLOB(ndr, NDR_SCALARS, &r->far_buf_array));
			ndr->flags = _flags_save_DATA_BLOB;
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_fsctl_query_alloced_ranges_rsp(struct ndr_print *ndr, const char *name, const struct fsctl_query_alloced_ranges_rsp *r)
{
	ndr_print_struct(ndr, name, "fsctl_query_alloced_ranges_rsp");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	{
		uint32_t _flags_save_DATA_BLOB = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
		ndr_print_DATA_BLOB(ndr, "far_buf_array", r->far_buf_array);
		ndr->flags = _flags_save_DATA_BLOB;
	}
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_file_zero_data_info(struct ndr_push *ndr, int ndr_flags, const struct file_zero_data_info *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->file_off));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->beyond_final_zero));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_file_zero_data_info(struct ndr_pull *ndr, int ndr_flags, struct file_zero_data_info *r)
{
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->file_off));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->beyond_final_zero));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_file_zero_data_info(struct ndr_print *ndr, const char *name, const struct file_zero_data_info *r)
{
	ndr_print_struct(ndr, name, "file_zero_data_info");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_hyper(ndr, "file_off", r->file_off);
	ndr_print_hyper(ndr, "beyond_final_zero", r->beyond_final_zero);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_fsctl_set_zero_data_req(struct ndr_push *ndr, int ndr_flags, const struct fsctl_set_zero_data_req *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_file_zero_data_info(ndr, NDR_SCALARS, &r->info));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_fsctl_set_zero_data_req(struct ndr_pull *ndr, int ndr_flags, struct fsctl_set_zero_data_req *r)
{
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_file_zero_data_info(ndr, NDR_SCALARS, &r->info));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_fsctl_set_zero_data_req(struct ndr_print *ndr, const char *name, const struct fsctl_set_zero_data_req *r)
{
	ndr_print_struct(ndr, name, "fsctl_set_zero_data_req");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_file_zero_data_info(ndr, "info", &r->info);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_network_resiliency_request(struct ndr_push *ndr, int ndr_flags, const struct network_resiliency_request *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->timeout));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->reserved));
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_network_resiliency_request(struct ndr_pull *ndr, int ndr_flags, struct network_resiliency_request *r)
{
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->timeout));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_network_resiliency_request(struct ndr_print *ndr, const char *name, const struct network_resiliency_request *r)
{
	ndr_print_struct(ndr, name, "network_resiliency_request");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "timeout", r->timeout);
	ndr_print_uint32(ndr, "reserved", r->reserved);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_file_level_trim_range(struct ndr_push *ndr, int ndr_flags, const struct file_level_trim_range *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->off));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->len));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_file_level_trim_range(struct ndr_pull *ndr, int ndr_flags, struct file_level_trim_range *r)
{
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->off));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->len));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_file_level_trim_range(struct ndr_print *ndr, const char *name, const struct file_level_trim_range *r)
{
	ndr_print_struct(ndr, name, "file_level_trim_range");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_hyper(ndr, "off", r->off);
	ndr_print_hyper(ndr, "len", r->len);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_fsctl_file_level_trim_req(struct ndr_push *ndr, int ndr_flags, const struct fsctl_file_level_trim_req *r)
{
	uint32_t cntr_ranges_0;
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->key));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->num_ranges));
		for (cntr_ranges_0 = 0; cntr_ranges_0 < (r->num_ranges); cntr_ranges_0++) {
			NDR_CHECK(ndr_push_file_level_trim_range(ndr, NDR_SCALARS, &r->ranges[cntr_ranges_0]));
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_fsctl_file_level_trim_req(struct ndr_pull *ndr, int ndr_flags, struct fsctl_file_level_trim_req *r)
{
	uint32_t size_ranges_0 = 0;
	uint32_t cntr_ranges_0;
	TALLOC_CTX *_mem_save_ranges_0 = NULL;
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->key));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->num_ranges));
		size_ranges_0 = r->num_ranges;
		NDR_PULL_ALLOC_N(ndr, r->ranges, size_ranges_0);
		_mem_save_ranges_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->ranges, 0);
		for (cntr_ranges_0 = 0; cntr_ranges_0 < (size_ranges_0); cntr_ranges_0++) {
			NDR_CHECK(ndr_pull_file_level_trim_range(ndr, NDR_SCALARS, &r->ranges[cntr_ranges_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_ranges_0, 0);
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_fsctl_file_level_trim_req(struct ndr_print *ndr, const char *name, const struct fsctl_file_level_trim_req *r)
{
	uint32_t cntr_ranges_0;
	ndr_print_struct(ndr, name, "fsctl_file_level_trim_req");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "key", r->key);
	ndr_print_uint32(ndr, "num_ranges", r->num_ranges);
	ndr->print(ndr, "%s: ARRAY(%d)", "ranges", (int)r->num_ranges);
	ndr->depth++;
	for (cntr_ranges_0 = 0; cntr_ranges_0 < (r->num_ranges); cntr_ranges_0++) {
		ndr_print_file_level_trim_range(ndr, "ranges", &r->ranges[cntr_ranges_0]);
	}
	ndr->depth--;
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_fsctl_file_level_trim_rsp(struct ndr_push *ndr, int ndr_flags, const struct fsctl_file_level_trim_rsp *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->num_ranges_processed));
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_fsctl_file_level_trim_rsp(struct ndr_pull *ndr, int ndr_flags, struct fsctl_file_level_trim_rsp *r)
{
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->num_ranges_processed));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_fsctl_file_level_trim_rsp(struct ndr_print *ndr, const char *name, const struct fsctl_file_level_trim_rsp *r)
{
	ndr_print_struct(ndr, name, "fsctl_file_level_trim_rsp");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "num_ranges_processed", r->num_ranges_processed);
	ndr->depth--;
}

